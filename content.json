{"meta":{"title":"A Kid","subtitle":null,"description":null,"author":"Fanfan999","url":"https://fanfan999.github.io","root":"/fanfan999.github.io/"},"pages":[{"title":"","date":"2019-04-12T15:55:49.785Z","updated":"2019-04-12T15:55:49.785Z","comments":true,"path":"about/index.html","permalink":"https://fanfan999.github.io/about/index.html","excerpt":"","text":"关于我 一个看似20,实则两岁的孩子; 一个正在努力复习的大三狗; 一个想走java开发的菜鸟一号; 还是一个想翻身的咸鱼 From 皮皮 QQ : 1058180192Email : 1058180192@qq.com"},{"title":"categories","date":"2019-04-13T13:13:08.000Z","updated":"2019-04-13T13:13:48.331Z","comments":true,"path":"categories/index.html","permalink":"https://fanfan999.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-04-13T13:12:18.000Z","updated":"2019-04-13T13:14:43.006Z","comments":true,"path":"tags/index.html","permalink":"https://fanfan999.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"JDBC-day01","slug":"JDBC-day01","date":"2019-05-05T01:55:00.000Z","updated":"2019-05-05T13:31:19.497Z","comments":true,"path":"2019/05/05/JDBC-day01/","link":"","permalink":"https://fanfan999.github.io/2019/05/05/JDBC-day01/","excerpt":"","text":"JDBC-day01JDBC基本概念 概念: Java DataBase Connectivity 即Java数据库连接, 用java语言操作数据库. JDBC本质: 我们期望使用统一的一套java代码可以操作所有的数据库,为此,sun公司就定义了医药操作所有关系型数据库的规则(也就是接口),而其每个数据库对这个接口的实现类由该数据库公司自己实现.所以, 我们可以说JDBC的本质就是:官方(sun公司)定义的一套操作所有关系型数据库的规则,即接口.同时各个数据库厂商自己去实现这个接口,提供数据库驱动的jar包.从而我们可以使用这套接口(JDBC)编程,真正执行的代码是驱动jar包中的实现类 JDBC快速入门 步骤: 导入对应数据库的驱动jar包,要用mysql就导入mysql的. 复制jar包,到项目下(可以新建一个目录libs,jar包都放在该目录下). 将libs目录–&gt;右键–&gt;添加为库. 注册驱动,让程序知道是用哪个数据库. Class.forName(&quot;com.mysql.jdbc.Driver&quot;);. 获取数据库连接对象Connection. Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/cart&quot;, &quot;root&quot;, &quot;root&quot;);. 定义sql语句. String sql = &quot;update product set name = &#39;话说&#39; where id = 1&quot;;. 获取执行sql语句的对象 Statement. Statement state = conn.createStatement();. 执行sql语句,接收返回的结果. int count = state.executeUpdate(sql);. 处理结果. 释放资源. 对JDBC中各个接口和类详解 详解各个对象 DriverManager(类): 驱动管理对象. 功能: 注册驱动,告诉我们的程序该使用哪个数据库的jar包. 使用的方法: public static void registerDriver​(Driver driver) throws SQLException. 写代码使用该方法:Class.forName(&quot;com.mysql.jdbc.Driver&quot;),通过查看Driver的源码,我们发现,在Driver类中存在静态代码块 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152 static &#123; try &#123; DriverManager.registerDriver(new Driver()); &#125; catch (SQLException var1) &#123; throw new RuntimeException(&quot;Can&apos;t register driver!&quot;); &#125; &#125; ``` * 注意:在导入mysql5的jar包以后,我们注册驱动的语句可以不用写,因为在jar包下的`META-INF`文件夹中的`services`中帮我们写了,不过我们还是建议写上,我们不知道驱动咋写的时候也可以去`META-INF`文件夹中的`services`中复制. 2. 获取数据库连接. * 使用的方法: `public static Connection getConnection​(String url, String user, String password)`. * 参数: * url:指定连接的路径 * 语法: jdbc:mysql://ip地址(或者域名,用于找到计算机):端口号(用于找到mysql软件)/数据库名称 * 例子:jdbc:mysql://localhost:3306/cart * 细节:如果连接的是本机的mysql服务器,并且mysql的默认端口是3306,则url中的`ip和端口`可以省略,所以url可以简写为:***jdbc:mysql:///数据库名称*** * user:用户名 * password:密码2. Connection(接口): 数据库连接对象 * 功能: 1. 获取执行sql语句的对象 * 方法1: `Statement createStatement()`. * 方法2: `PreparedStatement prepareStatement​(String sql)`. 2. 管理事务: * 开启事务: `void setAutoCommit​(boolean autoCommit)`,调用该方法设置参数为`false`则开启事务. * 提交事务: `void commit()`. * 回滚事务: `void rollback()`.3. Statement(接口,重要): 执行静态sql语句对象 * 方法1(了解): `boolean execute​(String sql)`,返回true表示执行的是DQL语句,返回false表示执行的是 DML语句. * 方法2: `int executeUpdate​(String sql)`,执行`DML语句(数据操作语言,增删改,insert,update,delete)`,`DDL语句(数据定义语言,创建/删除表和库,create,alter,drop)`. * 返回值: 表示影响的行数(针对DML语句,而对DDL永远返回0,因为它不返回任何内容). * 返回值作用: 可以通过影响的行数来判断DML语句是否执行成功,返回值&gt;0则执行成功,反之则执行失败. * 方法3: `ResultSet executeQuery（String sql）`,执行DQL语句(数据查询语言查询语句,select). * 练习,针对product表: 1. 添加一条记录:`String sql = &quot;insert into product(id,name,price) value(null , &apos;平板2&apos; , 500)&quot;,其中`product(id,name,price)`中的括号里的参数表示增加哪一个字段内容,不写就表示增加所有字段`. * 注意:这里`value`可以写成`values`,在插入一条数据时,用`values`较快,插入多行数据时,用`value`较快. 2. 删除一条记录: `String sql = &quot;delete from product where id = 2&quot;;`. 3. 修改一条记录: `String sql = &quot;update product set name = &apos;平板&apos; where id = 1&quot;;`. 4. 创建一张表: `String sql = &quot;create table student (id int, name varchar(20))&quot;;`. 5. 删除一张表: `String sql = &quot;drop table student&quot;;`.4. ResultSet(接口): 结果集对象,封装查询结果. * next(): 游标向下移动一行(默认光标指向位置是表头,此时是没有数据的,向下移动一行后就有数据了),同时可以通过该方法判断是否到达最后一行末尾(即是否有数据),如果有数据,则返回true,反之则返回false. * getXxx(参数): 获取数据. * Xxx代表`数据类型`,因为它是一次获取一行当中某一列的值,不是一次获取一整行的,例如: int getInt(). * 参数有两种情况: 1. int类型: 代表列的编号,从`1`开始,不是从0开始,如:getInt(1). 2. String类型: 代表列的名称,如:getString(&quot;id&quot;). * 注意: * ResultSet的使用步骤: 1. 游标向下移动一行. 2. 判断是否有数据. 3. 获取数据. while (rs.next()) { int id = rs.getInt(1); String name = rs.getString(&quot;name&quot;); double price = rs.getDouble(&quot;price&quot;); String data = &quot;id = &quot; + id + &quot;name = &quot; + name + &quot;price = &quot; + price; System.out.println(data); } ` 练习: 定义一个方法,查询db_student数据库中studentinfo中的数据,并将其封装为对象,然后打印. 思路:表其实和类的定义很类似,定义字段名,字段类型等,而表中每一行数据和一个对象类似,有表中每个字段的内容,所以我们可以把表映射成一个类,把查询的每一行数据封装成该类对象,然后用集合将所有对象都装载在一起返回. 定义一个Studentinfo类,封装数据库中表的各个字段. 定义方法 public List finaAll(),实现对数据库中所有数据的查询并将数据添加到list集合中. 调用方法. PreparedStatement(statement的子接口): 执行动态sql语句 SQL注入问题: 在拼接sql语句时,有一些sql的特殊关键字参与字符串的拼接,会造成一些安全性问题 例如: select * from usertable where username = &#39;abc&#39; and password = &#39;a&#39; or &#39;a&#39; = &#39;a&#39;,前面的账号密码是错的,但是这个sql语句是恒成立的,因为后面有个or &#39;a&#39; = &#39;a&#39;,这就会把数据库中所有数据都查出来,同时导致程序出问题. 解决sql注入问题: 使用PreparedStatement对象来解决. 预编译sql语句:参数使用?作为占位符,在执行的时候,给?赋值就行了,这个虽然步骤麻烦一点,但是安全一些. 使用步骤: 导入对应数据库的驱动jar包,要用mysql就导入mysql的.即复制jar包,到项目下(可以新建一个目录libs,jar包都放在该目录下). 将libs目录–&gt;右键–&gt;添加为库. 注册驱动,让程序知道是用哪个数据库. Class.forName(&quot;com.mysql.jdbc.Driver&quot;);. 获取数据库连接对象Connection. Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/cart&quot;, &quot;root&quot;, &quot;root&quot;);. 定义sql语句. 注意: sql的参数使用?作为占位符.如String sql = &quot;update product set name = ? where id = ?&quot;;. 获取执行sql语句的对象 PreparedStatement: 方法为PreparedStatement prepareStatement​(String sql). PreparedStatement ps = conn.prepareStatement(sql);. 给?赋值 用到PreparedStatement中的setXxx(参数1, 参数2)方法. 其中,参数1表示?的位置编号,从1开始,参数2表示?的值. 执行sql语句,接收返回的结果,在这里就不需要传递sql语句了,因为在步骤6中已经传递过了. 处理结果. 释放资源. 改造登录例子代码:PrepareStatement改进登录代码 注意:我们以后使用PrepareStatement来完成增删查改的所有操作 可以防止SQL注入. 效率比Statement高. 抽取JDBC工具类: JDBCUtils类 目的: 简化书写 分析: 抽取注册驱动. 抽取一个方法,获取连接对象. 需求: 不想传递参数(url,user,password等),因为太麻烦,但是 又想保证工具类的通用性,即不同url,user等也可以运行. 解决办法: 使用配置文件: jdbc.properties url = user = password = 抽取释放资源. 代码:JDBC工具类及测试代码 练习: 需求: 通过键盘录入用户名和密码判断用户是否登录成功,给出提示. 步骤 创建数据库表,包括用户名和密码两个字段. 创建一个类LoginUser.java测试. 代码:用户登录测试类 需要注意的点:1. JAVA中两个`基1`的点: 1. 在查询语句`ResultSet`中,参数是从`1`开始的. 2. 在预编译接口`PreparedStatement`对象中,参数也是从`1`开始的. 2. 上面提到的对象中,只有`DriverManager`是类,其它的都是接口.","categories":[{"name":"JDBC","slug":"JDBC","permalink":"https://fanfan999.github.io/categories/JDBC/"}],"tags":[{"name":"JDBC","slug":"JDBC","permalink":"https://fanfan999.github.io/tags/JDBC/"}]},{"title":"MySQL学习笔记_day01","slug":"MySQL学习笔记-day01","date":"2019-05-05T00:17:48.000Z","updated":"2019-05-05T02:03:36.032Z","comments":true,"path":"2019/05/05/MySQL学习笔记-day01/","link":"","permalink":"https://fanfan999.github.io/2019/05/05/MySQL学习笔记-day01/","excerpt":"","text":"MySQL笔记_day01数据库的基本概念 数据库的全称: DataBase 简称 : ＤＢ 什么是数据库？ 用于存储和管理数据的仓库. 数据库的特点,和存储在文件中有什么不一样呢? 持久化存储数据的,从这点来说,说白了数据库就是一个文件系统. 方便存储和管理数据. 使用统一的方式操作数据库 — SQL.MySQL数据库软件(Oracle公司的) 安装 反正我选择的是默认安装哈哈. 安装成功后,右键我的电脑,然后点击管理,点击服务和应用程序,点击服务,当看到mysql字样的时候说明安装成功了(也可以在dos窗口下输入services.nsc就可以直接跳转到服务界面了). 卸载 找到安装目录,找到my.ini文件,复制出来里面的datadir后面的路径 卸载mysql后,我们就要去通过刚才复制的路径去卸载其数据文件,就可以了. 配置 MySQL服务(service) 停止MySQL服务,在在dos窗口下输入net stop mysql SQL","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://fanfan999.github.io/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://fanfan999.github.io/tags/MySQL/"}]},{"title":"归并排序","slug":"归并排序","date":"2019-05-03T06:22:30.000Z","updated":"2019-05-03T14:19:46.534Z","comments":true,"path":"2019/05/03/归并排序/","link":"","permalink":"https://fanfan999.github.io/2019/05/03/归并排序/","excerpt":"","text":"归并排序 写在前面的话: 归并排序的时间复杂度为O(N*logN),额外空间复杂度为O(N). 什么是归并排序呢? 举例:以[2,5,7,1,6,4]为例 首先将其一分为二,划分成两个部分,分别为[2,5,7]和[1,6,4]. 然后分别对左右两部分进行排序,得到[2,5,7]和[1,4,6]. 申请一个辅助数组,长度和原来的数组相同. 左右两个部分分别从左到右进行比较,谁小就放到辅助数组中去,例如此例中,执行顺序是这样的 先2和1比较,2大,就把1放在辅助空间中,然后左边数组下标不动,右边下标＋1. 再2和4比较,4大,就把2放进辅助空间,然后左边数组下标＋1,右边数组下标不变. ……以此类推,当一个到了末尾之后,比较停止,剩下的直接全部放到辅助数组中. 最后得到有序数组[1,2,4,5,6,7],再将其复制回原数组即可.分析其时间复杂度 这是一个递归的过程,我们可以用master公式(): T(N) = a * T(N / b) + O(N^d)来套一下. 假设数组样本量为N,划分成了两部分,所以两边的样本量是(N/2),有因为有两部分,所以为2*T(N/2). 额外空间复杂度为O(N),因为要申请一个长度为N的辅助数组. 用master公式套,可得T(N) = 2 * T(N / 2) + O(N),即a=2,b=2,d=1. 由此可知,(log(b,a)) =&gt; 1,而d == 1,所以可得归并排序的时间复杂度为`O(N^d logN) == O(Nlog(N))`. 对于额外空间复杂度,就把它当作只生成了一个最大的数组(就是初始化数组的长度),不考虑中间的就好了,所以是O(N).代码: 行数有点多,我就直接放github上了,需要的话就自己看下: 归并排序 举例: 小和问题(以[1,3,4,2,5]为例) 什么是小和问题: 就是在一个数组中,每一个数左边比当前数小的数累加起来,叫做这个数组的小和,求一个数组的小和的和. 分析: 1左边比1小的数: 没得. 3左边比3小的数: 1. 4左边比4小的数: 1,3. 2左边比2小的数: 1. 5左边比5小的数: 1,3,4,2. 所以总的小和为:1+1+3+1+1+3+4+2 = 16. 解决办法 每个数都遍历一下左边,小的数就相加,其时间复杂度为O(N^2),我们对数器就可以这么写. 用归并思想,产生小和就在合并过程中产生,但是其中有一个要注意的点: 在合并的时候,假如左边为[1,3,4],右边为[2,5]. 先1和2进行比较,发现2 &gt; 1,而此时,2右边包含2本身一共有两个元素,所以此时需要将1×2,然后在将右边的1放到辅助数组中. 再将3和2比较,发现3 &gt; 2,此时不产生小和,直接将2放入辅助数组. ……以此类推. 其实就是,合并的时候左边比右边大,就产生小和,左边比右边小就不产生小和,同时要注意右边的数比左边大的时候,要看右边较大的这个数的右边还有几个数,此时左边较小的数就要乘以几. 逆序对问题","categories":[{"name":"算法","slug":"算法","permalink":"https://fanfan999.github.io/categories/算法/"}],"tags":[{"name":"归并排序","slug":"归并排序","permalink":"https://fanfan999.github.io/tags/归并排序/"}]},{"title":"关于递归和递归时间复杂度的估算","slug":"关于递归和递归时间复杂度的估算","date":"2019-05-02T09:29:30.000Z","updated":"2019-05-03T07:55:36.765Z","comments":true,"path":"2019/05/02/关于递归和递归时间复杂度的估算/","link":"","permalink":"https://fanfan999.github.io/2019/05/02/关于递归和递归时间复杂度的估算/","excerpt":"","text":"递归两个小例子: 举例1: 在一个数组中找到最大值 我先找左边最大值和右边最大值(以下标中间为界),两者相比较,较大的就是全局最大值 我直接贴代码了哈: 12345678910111213141516//结束条件 if (L &gt;= R) &#123; return array[L]; &#125; //找到中间位置,划分为左右两边 int mid = (L + R) / 2; //左边最大值 int maxLeft = getMax(array, 0, mid); //右边最大值 int maxRight = getMax(array, mid + 1, R); //返回左右两边最大值 return Math.max(maxLeft, maxRight); 怎么理解呢? 我画了个图: 举例2:冒泡排序的递归实现: 因为冒泡排序的原理就是每一圈都让数组中的前后两个元素比较,大的放后面,小的放前面,,所以我们这里采用递归就要分为两步: 说明,这里的start第一圈就是下标0,end在第一圈就是数组长度 每一圈递归,其实就是遍历数组,让其两两比较,代码如下: 12345678if (start &lt; end - 1) &#123; if (array[start] &gt; array[start + 1]) &#123; swap(start, start + 1, array); &#125; bubbleSort(array, start + 1, end); &#125; else &#123; return; &#125; 让数组不断变成一个更小的数组(因为每一圈结束最后一个都是最大的),可以理解为递归圈数,代码如下: 1bubbleSort(array, start, end - 1); 完整代码我放github了,要的话自己可以看看:冒泡排序的递归版 这个就拿来当作理解就可以了,正式用的时候还是循环,不要用递归!不要用递归!不要用递归! 注意: 任何递归行为都可以变成非递归. 递归实际上就是在不停的压栈弹栈,很浪费空间. 循环基本都可以变递归,不过不建议使用递归,递归容易出问题,还不好理解,占用空间还多,除了代码简练一点. 递归时间复杂度怎么分析: 看这样一个用于估计递归时间复杂度一个通式(叫做master公式): T(N) = a * T(N / b) + O(N^d). 这个式子是用做第一次划分的过程的时候的,后面的划分不用管. 其中,T(N)表示样本量为N的情况下的时间复杂度,你就理解为T就是Time的缩写;a表示子过程的次数;N / b表示子过程的样本量;O(N^d)(这是N的d次方哈)表示除了调用子过程以后所需要的时间复杂度,下面我们以求最大值为例进行分析. 由于我们把整个数组划分为了左右两个部分,两边的样本量都是(N/2),所以说左边的时间复杂度就是T(N/2),而又有左右两个部分,所以一共要两个T(N/2)的时间复杂度,即2*T(N/2). 除了调用子过程意外,我们只需要对数组中元素两两比较,这个是常数级别的操作,所以最后一项O(N^d)为O(1). 从这里我们可以看出,上述求最大值的时间复杂度为T(N) = 2T(N/2) + O(1),就相当于a=2,b=2,d=0**. master的公式是有适用范围的:那就是划分子过程的时候,划分的子过程的规模必须是一样(或者差不多,多一个两个有限个的都无所谓)的,才可以用master公式. 对满足这个公式的算法有几个快捷使用公式: log(b,a) &gt; d –&gt; 复杂度为O(N^log(b,a)). log(b,a) == d –&gt; 复杂度为O(N^d * logN),(logN表示以10为底). log(b,a) &lt; d –&gt; 复杂度为O(N^d). 注意: 这里的log(b,a)都是表示以b为底,a为指数,读作以b为底的a的对数. 以1为底的任何数的对数都是0. 1的对数永远是0. 以求最大值为例进行分析: 最大值的时间复杂度为T(N) = 2*T(N/2) + O(1),就相当于a=2,b=2,d=0,所以log(b,a) == log(2,2),其值为1,是大于d=0的,所以其具体复杂度为O(N^log(b,a)) =&gt; O(N^1) == O(N).","categories":[{"name":"算法","slug":"算法","permalink":"https://fanfan999.github.io/categories/算法/"}],"tags":[{"name":"递归","slug":"递归","permalink":"https://fanfan999.github.io/tags/递归/"}]},{"title":"算法中很好用的工具-对数器","slug":"对数器","date":"2019-05-02T05:46:42.000Z","updated":"2019-05-02T09:43:13.162Z","comments":true,"path":"2019/05/02/对数器/","link":"","permalink":"https://fanfan999.github.io/2019/05/02/对数器/","excerpt":"","text":"对数器 当你碰到一个题,写好代码以后,你想验证是否正确,那么我们应该怎么办呢? 可以自己多举几个例子,但是自己举例子考虑得可能不够周全. 去找OJ(Online Judge在线评测),但是可能我们不知道这个题在哪个平台上有. 自己写一个对数器进行验证,说白了对数器的作用就是给定一组样本,在你的算法和对数器上跑,跑出来结果永远一样的话,那就说明算法是正确的. 对数器是什么: 说到底,对数器就是一个对应于你的算法所写的绝对正确的(或者直接调用的绝对正确的方法)方法,这个方法和你写的算法可以达到相同效果的方法,例如,你自己写的冒泡排序和java中系统给的Arrays.sort()方法.这个Arrays.sort()方法就可以作为对数器标准使用,而且,这个绝对正确的方法不需要在乎复杂度,只需要保证绝对正确就行. 对数器的使用步骤: 有一个你想要测的方法a; 实现一个绝对正确但是复杂度不好的方法b; 实现一个随机样本产生器; 实现比对的方法; 把方法a和方法b比对很对此来验证方法a是否正确; 如果有一个样本使得比对出错,打印样本,分析是哪个方法出错; 当样本数量很多时比对测试依旧正确,我们就可以确定方法a是正确的. 例子: 以冒泡排序为例 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134//自己写的冒泡排序算法 private static void bubbleSort(int[] array) &#123; //首先判断array对象是否为空 //然后判断array是否是单个元素数组 if (array == null || array.length &lt; 2) &#123; //是就直接退出 return; &#125; //控制次数(第一个~最后一个--第一个~倒数第二个--以此类推) //array.length - 1才是最后一个元素的下标,因为下标是从0开始的 for (int end = array.length - 1; end &gt; 0; end--) &#123; //j只能指向倒数第二个元素,防止越界 for (int j = 0; j &lt; end; j++) &#123; //前一个比后一个元素值大,交换位置 if (array[j] &gt; array[j + 1]) &#123; swap(j, j + 1, array); &#125; &#125; &#125; &#125; //交换位置 private static void swap(int i, int j, int[] array) &#123; int temp = array[i]; array[i] = array[j]; array[j] = temp; &#125; //for test //一个绝对正确的排序算法 public static void rightMethod(int[] array) &#123; //调用Arrays的sort()方法进行排序,这是绝对正确的 Arrays.sort(array); &#125; //for test /** * @param length 表示数组的长度 * @param maxValue 表示数组中元素的最大值 * @return 返回一个长度随机, 元素随机的数组 */ public static int[] createRandomArray(int length, int maxValue) &#123; //生成[0,length]范围的随机数使得randomArray的长度随机,因为Math.random()是不能到达右边界的,所以需要加1使它取到length这个数 int[] randomArray = new int[(int) (Math.random() * (length + 1))]; // 给随机数组赋值 for (int i = 0; i &lt; randomArray.length; i++) &#123; //因为Math.random()方法是不会产生负数的,为了更好的模拟真实情况,我们采用两个随机数相减,就有可能产生负数了 randomArray[i] = (int) ((Math.random() * (maxValue + 1)) - (Math.random() * (maxValue + 1))); &#125; return randomArray; &#125; //for test /** * 用于对比两个算法跑出来结果是否相同 * * @param array1 表示自己写的算法跑出来的结果 * @param array2 表示对数器中的算法跑出来的结果 * @return 返回true表示两者完全相同, false就打印错误样本 */ public static boolean comparator(int[] array1, int[] array2) &#123; int len = array1.length; //如果两个数组长度不相同一定不相同 if (array1.length != array2.length) &#123; return false; &#125; //一个为空一个不为空,一定不相同 if ((array1 == null &amp;&amp; array2 != null) || (array2 == null &amp;&amp; array1 != null)) &#123; return false; &#125; //遍历数组,进行比较 for (int i = 0; i &lt; len; i++) &#123; if (array1[i] != array2[i]) &#123; System.out.println(&quot;出错了!,此时自定义算法的数据为 : &quot; + Arrays.toString(array1) + &quot;, 对数器样本数据为 : &quot; + Arrays.toString(array2)); System.out.println(array1[i]); System.out.println(array2[i]); return false; &#125; &#125; return true; &#125; // for test /** * * @param array 表示要复制的样本 */ private static int[] copyArray(int[] array) &#123; int[] copyArray = new int[array.length]; for (int i = 0; i &lt; array.length; i++) &#123; copyArray[i] = array[i]; &#125; return copyArray; &#125; // for test public static void main(String[] args) &#123; int[] a = new int[0]; int[] b = null; System.out.println(a.length); System.out.println(b.length); boolean flag = true; //产生样本 for (int i = 0; i &lt; 10000; i++) &#123; int[] array = createRandomArray(10, 1000); //复制样本 int[] array2 = copyArray(array); //通过两种算法排序 bubbleSort(array); rightMethod(array2); //判断两个数组此时是否相同 flag = comparator(array,array2); //一旦有不相同,就退出循环 if (flag != true) &#123; break; &#125; &#125; System.out.println(flag == true ? &quot;恭喜你,你的算法是正确的!&quot; : &quot;继续努力!&quot;); &#125; 注意事项: 对于Math.random()和Random类不懂的话,我在网上找了一篇很详细的文章,大家可以看看,我就不自己写了,超链接 : 关于生成随机数的两个方法. 区别一下int[] a = new int[0];和int[] b = null;这两条语句,后者不是长度为0,它不赋值去调用任何东西都是报错. 代码我放我github仓库了,有需自取 : BubbleSort.java","categories":[{"name":"算法","slug":"算法","permalink":"https://fanfan999.github.io/categories/算法/"}],"tags":[{"name":"对数器","slug":"对数器","permalink":"https://fanfan999.github.io/tags/对数器/"}]},{"title":"冒泡排序,选择排序,插入排序","slug":"冒泡排序,选择排序","date":"2019-04-29T12:56:29.000Z","updated":"2019-05-02T05:31:48.374Z","comments":true,"path":"2019/04/29/冒泡排序,选择排序/","link":"","permalink":"https://fanfan999.github.io/2019/04/29/冒泡排序,选择排序/","excerpt":"","text":"冒泡排序 理解:在水里小泡泡往上面浮,大泡泡往水下沉,所以冒泡排序其实就是前一个和后一个比较,小的放前面,大的放后面. 原理:以int[] arr = {2,3,4,1,9,7,5}为例. 第一圈: 先数组中第一个元素(下标为0)和数组中第二个元素(下标为1)比较大小. arr[0] &gt; arr[1],两者交换. arr[0] &lt;= arr[1],两者不交换 然后比较数组第一个元素(下标为1)和数组第二个元素(下标为2)的大小. arr[1] &gt; arr[2],两者交换. arr[1] &lt;= arr[2],两者不交换 ……以此类推 第一圈结束后,数组中最后一个元素为当前数组最大值. 第二圈(不管第N-1个数): 先数组中第一个元素(下标为0)和数组中第二个元素(下标为1)比较大小. arr[0] &gt; arr[1],两者交换. arr[0] &lt;= arr[1],两者不交换 然后比较数组第一个元素(下标为1)和数组第二个元素(下标为2)的大小. arr[1] &gt; arr[2],两者交换. arr[1] &lt;= arr[2],两者不交换 ……以此类推 第二圈结束后,数组中倒数第二个为当前数组第二个最大值. ……以此类推,共执行N次 代码1234567891011121314151617181920212223242526272829303132333435363738394041public class BubbleSort &#123; public static void main(String[] args) &#123; int[] array = new int[]&#123;2,1,6,9,13,3,4,2&#125;; System.out.println(array.length); //排序前 System.out.println(Arrays.toString(array)); bubbleSort(array); //排序后 System.out.println(Arrays.toString(array)); &#125; private static void bubbleSort(int[] array) &#123; //首先判断array对象是否为空 //然后判断array是否是单个元素数组 if (array == null || array.length &lt; 2) &#123; //是就直接退出 return; &#125; //控制次数(第一个~最后一个--第一个~倒数第二个--以此类推) //array.length - 1才是最后一个元素的下标,因为下标是从0开始的 for (int end = array.length - 1; end &gt; 0; end--) &#123; //j只能指向倒数第二个元素,防止越界 for (int j = 0; j &lt; end; j++) &#123; //前一个比后一个元素值大,交换位置 if (array[j] &gt; array[j + 1]) &#123; swap(j, j + 1, array); &#125; &#125; &#125; &#125; //交换位置 private static void swap(int i, int j, int[] array) &#123; int temp = array[i]; array[i] = array[j]; array[j] = temp; &#125;&#125; 分析: 数组中两两交换和数组寻址都是常数时间O(1)的. 第一个for一共执行N次,第二个for一共执行N-1次,所以一共要执行N^2 + N次. 不要高阶项系数,不要低阶项,所以我们就可以评估冒泡排序的时间复杂度为O(N^2). 其空间复杂度为O(1),因为只用了一个变量没有开辟多余空间. 选择排序 理解:和冒泡排序相反,选择排序是第一个元素依次和后面的每一个元素相比,比后面的小就交换,所以结束第一圈后最小的数就放在了最前面…以此类推,就可以将数组从小到大排序好. 代码1234567891011121314151617181920212223242526272829303132333435363738public class SelectionSort &#123; public static void main(String[] args) &#123; int[] array = new int[]&#123;7, 6, 8, 9, 1, 2, 7, 6, 4&#125;; //排序前 System.out.println(Arrays.toString(array)); selectionSort(array); //排序后 System.out.println(Arrays.toString(array)); &#125; //选择排序代码 private static void selectionSort(int[] array) &#123; //首先判断数组对象是否为空以及是否为单个元素数组 if (array == null || array.length &lt; 2)&#123; return; &#125; //控制循环次数 for (int start = 0; start &lt; array.length; start++) &#123; //注意这里的i只能取到倒数第二个数,防止i+1越界 for (int i = star t; i &lt; array.length - 1; i++) &#123; //如果前一个比后面的大,就交换 if (array[start] &gt; array[i + 1]) &#123; swap(start,i + 1, array); &#125; &#125; &#125; &#125; private static void swap(int start, int i, int[] array) &#123; int temp = array[i]; array[i] = array[start]; array[start] = temp; &#125;&#125; 分析: 数组中两两交换和数组寻址都是常数时间O(1)的. 第一个for一共执行N次,第二个for一共执行N-1次,所以一共要执行N^2 + N次. 不要高阶项系数,不要低阶项,所以我们就可以评估选择排序的时间复杂度为O(N^2). 其空间复杂度为O(1),因为只用了一个变量没有开辟多余空间. 插入排序(重点) 理解:以int[] arr = {3,1,4,1,6}为例,可以理解为斗地主嘛,你手上的牌都从小到大排好序了,拿到一张新的牌可不就得和前面已经拿了的牌一个一个对比嘛,小的放前面,大的放后面,对吧? 首先,第一个位置的数(下标为0)不动,去和第二个位置的数(下标为1)比较(即拿3和1比较). 此时发现3&gt;1,所以arr[0]和arr[1]的值交换. 此时数组为[1,3,4,1,6]. 然后用第二个位置的数(下标为1)去和第三个位置的数(下标为2)比较,(即拿3和4比较) 此时发现3 &lt; 4,所以不交换. 此时数组为[1,3,4,1,6]. 然后用第三个位置的数(下标为2)去和第四个位置的数(下标为3)比较,(即拿4和1比较) 此时发现4 &gt; 1,所以4和1交换位置,得到[1,3,1,4,6]. 再将3和1比较,发现3 &gt; 1,两者交换,得到[1,1,3,4,6]. 再将1和1比较,发现1 == 1,所以不交换. …以此类推 当到数组末尾时结束,得到排序好的数组[1,1,3,4,6]. 代码12345678910111213141516171819202122232425262728293031323334353637383940public static void main(String[] args) &#123; int[] array = new int[]&#123;3, 1, 5, 2, 7, 6, 1&#125;; // 排序前 System.out.println(Arrays.toString(array)); insertionSort(array); // 排序后 System.out.println(Arrays.toString(array)); &#125; //插入排序 private static void insertionSort(int[] array) &#123; //判断数组对象是否为空和是否为单个元素数组 if (array == null || array.length &lt; 2) &#123; return; &#125; //控制开始和结束,到数组末尾就停,i表示右边第一个未排序的元素下标 for (int i = 1; i &lt; array.length; i++) &#123; // 让左边已经排好序的和右边未排序的依次比较,同时和已排序的进行比较,j表示左边已排序的最后一个元素下标 for (int j = i - 1; j &gt;= 0; j--) &#123; //大就交换 if (array[j] &gt; array[j + 1]) &#123; swap(array, j); &#125; &#125; &#125; &#125; //交换 private static void swap(int[] array, int j) &#123; int temp = array[j]; array[j] = array[j + 1]; array[j + 1] = temp; &#125;&#125; 分析: 首先数组寻址,交换位置这些时间复杂度都是O(1)这是没有问题的. 和选择排序和冒泡排序不同的点是:前两个时间复杂度一定是O(N^2),因为不管你数组有序或者无序,你都是要按照流程一个一个比较的,跟数据状况没关系的,但是插入排序不一样,插入排序和数据状况有关系,要分情况. 最好情况下的时间复杂度: 当数组本来就有序时,时间复杂度为O(N),因为没有交换,就和遍历一次数组一样. 最差情况下的时间复杂度 当数组是逆序,而我要的是正序时(比如我要的是[1,2,3,4,5],但是你给的是[5,4,3,2,1]),时间复杂度为O(N^2),每一次都要和前面所有的交换,(例如5要交换4次,4要交换3次这样子),这就形成了一个等差数列(联想到冒泡排序怎么形成等差数列的),所以评估其时间复杂度为O(N^2). 一般情况下的时间复杂度: 一般情况我们一律按照最差情况估计,所以我们一般说插入排序的时间复杂度为O(N^2).","categories":[{"name":"算法","slug":"算法","permalink":"https://fanfan999.github.io/categories/算法/"}],"tags":[{"name":"冒泡排序,选择排序,插入排序","slug":"冒泡排序-选择排序-插入排序","permalink":"https://fanfan999.github.io/tags/冒泡排序-选择排序-插入排序/"}]},{"title":"关于时间复杂度和额外空间复杂度","slug":"关于时间复杂度和空间复杂度","date":"2019-04-29T11:27:15.000Z","updated":"2019-05-02T09:28:46.534Z","comments":true,"path":"2019/04/29/关于时间复杂度和空间复杂度/","link":"","permalink":"https://fanfan999.github.io/2019/04/29/关于时间复杂度和空间复杂度/","excerpt":"","text":"写在前面的话: 这里写logN就表示以2为底数,因为2为底数打不出来哈哈哈 时间复杂度 用于评价一个算法流程的好坏. 先看时间复杂度的指标(再看常数项),即(N^2)/100 + 10N + 1我们也看成时间复杂度是O(N^2),其中N就是样本量 . 然后再分析不同数据样本下的实际运行时间. 常数时间的操作: 概念:一个操作如果和数据量没有关系,每次都是固定时间内完成的操作,就叫做常数操作,例如加减乘除,位运算操作,数组寻址(就是根据下标获取数组中的元素,比如a[1])等. 时间复杂度为一个算法流程中,最差情况下常数操作数量的指标.常用O表示(读作big O),具体来说,在常数操作数量的表达式中,不要低阶项,只要高阶项,并且忽略掉高阶项的系数,剩下的部分如果记作f(N),那么时间复杂度为O(f(N)). 几个简单的理解时间复杂度的例子: 一个有序数组A,另一个无序数组B,请打印B中的所有不在A中的数,A数组长度为N,B数组长度为M. 算法流程1: 对于数组B中的每一个数,都在A中通过遍历的方式找一下. 很明显该算法的时间复杂度特别大,遍历一次代价为O(N),一共M个数,所以总的代价为O(M*N). 算法流程2: 对于数组B中的每一个数,都在A中通过二分的方式找一下. 二分搜索,比如针对一个有序(假定是从小到大)的数组,假设我要找2有没有在这个数组里. 我先找到中间位置的数,看比2大还是小. 比2大,因为是从小到大排序的,所以中间右边的数字一定比2大,我们就在左边继续划分一半一半地找,直到没有了或者找到了为止. 比2小,说明中间左边的数字一定比2小,我们就在右边继续划分一半一半地找,直到没有了或者找到了为止. 等于2,就直接返回 在这个过程中,我们数组寻址和两个数比较的过程都是常数操作时间的O(1),每次砍一半,这样下来,常数操作次数为logN(以2为底),即一个数组长度为8,最多砍3次. 由此可见,二分查找的时间复杂度为O(logN),以2为底 因此我们也可以推出,查找一次的时间复杂度为O(logN),一共有M个数,时间复杂度则为(MlogN). 算法流程3: 先把B数组排序,然后用类似外排的方式打印所有在A中出现的数. 思路就是,B排序后,两个数组同时从0位置开始,即A[i]和B[i]互相比较. 若A[i] &gt; B[i],则B[i]肯定不在A数组中,打印B[i],然后B数组下标++. 若A[i] &lt; B[i],B数组下标不动,A数组下标++. 若A[i] == B[i],A数组下标不动,B数组下标++. 针对这个流程 第1步:排序的时间复杂度,可以达到NlogN. 第2步:快排,时间复杂度为O(N + M)(N,M为A和B数组长度). 由此可见,该流程的时间复杂度为NlogN + O(N + M). 三个流程,三种时间复杂的表达…我们应该如何分析其好坏? 给长度为N的数组排序(其中寻址,比较操作都是常数级别的). 第一次从0-(N-1)中找出最小值min放在第0个位置,过N个数. 第二次从1-(N-1)中找出最小值min放在第1个位置,过N-1个数. ……以此类推. 一共需要找的次数为(N + (N-1) + ... + 2 + 1),这是一个等差数列,其和为n(n + 1) / 2(这个就可以理解为常数操作数量的表达式),再乘以一个O(1)(它是单次操作所需要的时间),即(n(n + 1) / 2) O(1). 估算其时间复杂度是这样子的: 不要低阶项,只要高阶项,并且忽略掉高阶项的系数. 由此推出上述排序算法时间复杂度为O(n^2). 额外空间复杂度 额外空间复杂度其实很好想,完成这个功能,我们额外开辟了几个新的空间,那就是几. 比如我一个循环,循环过程中我新开辟了一个长度为10的数组来存储数据,那么额外空间复杂度就是O(10) 再以冒泡排序为例,当两个数需要交换时,我们就会定义一个中间变量temp,这就是我们唯一新开辟空间的地方,这时我们就说冒泡排序的额外空间复杂度为O(1),其实,有限的几个变量(单个变量,不是数组这样子的哈)能跑完流程的话,额外空间复杂度都是O(1),不一定是一个.","categories":[{"name":"算法","slug":"算法","permalink":"https://fanfan999.github.io/categories/算法/"}],"tags":[{"name":"时间复杂度,额外空间复杂度","slug":"时间复杂度-额外空间复杂度","permalink":"https://fanfan999.github.io/tags/时间复杂度-额外空间复杂度/"}]},{"title":"基础加强_注解","slug":"基础加强-注解","date":"2019-04-29T05:12:55.000Z","updated":"2019-04-29T11:16:29.997Z","comments":true,"path":"2019/04/29/基础加强-注解/","link":"","permalink":"https://fanfan999.github.io/2019/04/29/基础加强-注解/","excerpt":"","text":"本篇文章主要讲注解(Annotation)注解的基本知识 概念:和注释一样,是来说明程序的,但是这个是给计算机看的; 注释: 用文字描述程序的一段话,比如//这是一个方法,这个就是给我们程序猿看的; 关于注解的几个注意的点: JDK1.5之后的新特性 用来说明程序的 注解的格式:@注解名称 注解的作用分类: 编写文档(生成doc文档) 生成api帮助文档,也就是(doc文档),只需要文件夹中用cmd打开dos窗口,输入javadoc 类名.java就可以生成了,然后再打开index.html就可以看到我们写的注解了 直接用dos命令可能会报错或者API有乱码,因为我用的是utf-8但是系统不认识的,所以你这时候只需要用notepad++将该类的编码改成ANSI(即本地默认编码)就可以了(先复制,再粘贴,再保存后就是ANSI编码的了) 代码分析(使用反射) 编译检查(如果你重写方法改名了就会报错) JDK中预定义的一些注解: @Override : 用于检测被该注解标注的方法是否是继承自父类(接口)的,不是会报错; 例子: 1234@Overridepublic String toString()&#123; return super.toString(); &#125; @Deprecated[ˈdeprəkeɪtɪd] : 说明被该注解标注的内容已过时 @SupperessWarnings : 压制警告(黄色警告线) 一般情况下我们会写在类上,使得类中的左右黄色警告线都会没有而且参数一般传递的参数都是&quot;all&quot;; 例子: 1234@SupperessWarnings(\"all\")public void show()&#123; System.out.println(\"abc\");&#125; 此时比如show方法未使用这些黄色警告线都没有了 自定义注解: 格式(包括两部分): 元注解 : 用于描述注解的注解(放在注解类上面) @target : 描述注解能够作用的位置 例子 : @Target(value = {ElementType.TYPE, ElementType.METHOD, ElementType.FIELD}), 其中value还可以省略,因为只有他一个属性 ElementType(这是target的属性)取值 : TYPE : 表示只能作用在类上 METHOD : 表示只能作用于方法上 FIELD : 表示只能作用于成员变量上 @Retention : 描述注解被保留的阶段 @Retention(RetentionPolicy.RUNTIME) : 表示当前被描述的注解,会保留到class字节码文件中,并被jvm读取到(可以直接RetentionPolicy.RUNTIME这样子使用是因为RetentionPolicy是一个枚举类) @Documented : 描述注解是否被抽取到api文档中(生成api文档可以在dos窗口下使用如下命令 : javadoc Hello.java) @inherited : 描述注解是否被子类继承,使用后子类会自动继承这个注解 public @interface 注解名称(){} 例如这样子 : public @interface MyAnno{} 本质 : 注解本质就是一个接口,该接口默认继承Annotation接口(自己写一个接口MyAnno,再反编译一下就知道了) 反编译后就像这样子 : public interface MyAnnotation.MyAnno extends java.lang.annotation.Annotation { } 反编译有一个小技巧,你可以通过软件反编译,也可以通过javap HelloWorld.class这样的命令在dos窗口下反编译 注解的属性 : 即接口中定义的抽象成员方法,常量没啥用不用管 要求 属性的返回值类型(只有下列取值) : 基本数据类型 String(注意只有String,没有其它引用类型) 枚举 注解 以上类型的数组类型 例子如下 : 1234567891011121314public @interface MyAnno&#123; public abstract int show1(); public abstract String show2(); //Student为枚举类 public abstract Student show3(); //MyAnno2为注解类 public abstract MyAnno2 show4(); String[] strs();&#125; 定义了属性,在使用时需要给属性赋值,格式为 : @注解名(方法名 = 返回值类型的值)(其中返回值类型为int就是int类型,String就是String类型,当有多个值时,中间用,隔开就可以了) 例如这样 : @MyAnno(show1 = 10, show2 = &quot;fan&quot;) 但是有一个技巧,就是我们在定义属性的时候就可以给一个默认值(在属性名后面＋default＋默认初始化值),这样在使用时候就可以不给值了 例如 : String name() default &quot;fan&quot; 如果只有一个属性需要赋值,并且属性的名称为value,则value可以省略，多个参数时就必须写上属性 就像这样 : @MyAnno(10) 注意数组赋值时候,用{}包裹,如果只有一个元素的话{}可以不写 注解赋值的例子: @MyAnno(show1 = 10, show2 = &quot;fan&quot;, strs = {&quot;fan1&quot;, &quot;fan2&quot;, show3 = Student.P1}) 在程序中使用(解析)注解 即获取注解中定义的属性值,可以替代配置文件,这里用到了反射 获取注解定义的位置的对象(Class, Method, Field对象) 获取指定的注解 getAnnotation(类类型) 调用注解中的抽象方法来获取配置的属性值其实我觉得这个暂时意义不大,就懒得写了哈哈 小结 以后大多数时候,我们会使用注解,而不会自定义注解 注解给谁用? 编译器 解析程序 注解不是程序的一部分,可有可无,也可以理解为注解就是一个标签","categories":[{"name":"javaee","slug":"javaee","permalink":"https://fanfan999.github.io/categories/javaee/"}],"tags":[{"name":"注解","slug":"注解","permalink":"https://fanfan999.github.io/tags/注解/"}]},{"title":"关于Markdown图片无法显示的问题解决方法","slug":"关于Markdown图片无法显示的问题解决方法","date":"2019-04-28T12:50:49.000Z","updated":"2019-04-29T05:02:04.805Z","comments":true,"path":"2019/04/28/关于Markdown图片无法显示的问题解决方法/","link":"","permalink":"https://fanfan999.github.io/2019/04/28/关于Markdown图片无法显示的问题解决方法/","excerpt":"","text":"备注: 在网上找了半天,一堆不靠谱的试了以后,终于被我试出来了哈哈哈,我可真是个小天才 步骤是这样子的 在自己的github上新建一个仓库, 怎么新建仓库大家应该都会吧,我这里就不赘述了,就像下面这样: 点开自己新建的仓库,在右边有个clone or download,复制下来地址,如图所示: 打开hexo所在文件夹,右键鼠标然后点击 Git Bash Here,然后在本机将github中的仓库克隆下来,命令是: git clone 仓库地址(地址就是你复制下来的地址),不懂就看图吧: 克隆成功后在hexo文件夹中会有一个以你的仓库名命名的文件夹,例如我的是MyPostImage,然后将图片放在该文件夹下就行; 注意: 这里有个小技巧:你可以每次要在一篇博客中添加图片时候,新建一个和本篇博客名字相同的文件夹放在MyPostImage下面,这样就比较容易整理; 你要是怕自己新建的文件夹和博客名字不一致,你可以这样子新建一篇博客文章:在bash窗口下输入命令hexo n &quot;博客名字&quot;,这样子系统就会自动在hexo &gt; source &gt; _posts路径下生成一个和本篇博客名相同的文件夹,然后将文件夹复制到MyPostImage下面就可以了. 进入MyPostImage文件夹(注意不是和博客名字相同的那个文件夹,是名字和仓库名相同的的文件夹),右键鼠标然后点击 Git Bash Here,打开Bash窗口然后输入git add .,(注意这里有一个点),然后输入命令git commit -m &quot;文件名&quot;,最后将内容推送上仓库就可以了,命令是:git push origin master; 上传成功后去自己的github仓库看看,你就会发现,产生了一个git commit -m &quot;文件名&quot;中以文件名为名字的文件夹,图片就在该文件夹中,就像这样子: 点击图片,当你看到图片以后,复制该图片的路径.就像这样: 然后打开我的新建的md文件,并且插入图片,代码是:![图片名](图片路径 &quot;图片无法显示或鼠标移上去的时候显示的文字&quot;),例子如下(这个图片是我在网上偷的啊哈哈): 但是我们预览的时候会出现一个问题,就是预览的时候图片还是显示不出来,这个时候我们改路径的一个文件名就可以了,因为github和md文件关联的图片地址是有一定格式的,格式如下: https://github.com/用户名/repository仓库名/raw/分支名master/图片文件夹名称/***.png or***.jpg 看不懂吧,其实就是将blob改成raw就行,万一还看不懂就看图: 在bash下运行博客,你会发现图片这时候就可以看到了,大功告成哈哈! 其实这里面可能还有很多技巧啥的,我暂时还不会,暂时会这个就可以了吧哈哈哈,因为反正图片不是太多,要是有啥不清楚的,随时可以通过博客联系我,在about里面可以找到我哈哈哈,最后附上一张我很喜欢的图片吧,希望各位和它一样每天都开心!","categories":[{"name":"随笔","slug":"随笔","permalink":"https://fanfan999.github.io/categories/随笔/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://fanfan999.github.io/tags/Markdown/"}]},{"title":"Markdown的基本语法<br>","slug":"Markdown语法","date":"2019-04-28T12:23:56.544Z","updated":"2019-04-29T08:01:55.815Z","comments":true,"path":"2019/04/28/Markdown语法/","link":"","permalink":"https://fanfan999.github.io/2019/04/28/Markdown语法/","excerpt":"","text":"写在前面的话: 之前一直手抄做笔记复习,没有想着用博客,后来觉得手写太慢了,所以准备好好利用一下我的博客作为复习仓库,在这里先熟悉下Markdown语法 Markdown标题 使用#表示1-6级标题,一级对应一个#号,二级标题对应两个#号,以此类推; 其中一级标题还可以在文字下方加一行=====,这个等号几个无所谓;二级标题可以在下面加----,几个符号也是无所谓的; 注意事项: Markdown写文章时,一定要在符号后面空格一下再写文章,比如* a这样子,不然符号不会起到作用的; Markdown中可以行与行之间通过空一行来实现换行,也可以通过&lt;br&gt;来实现换行; 将文字放在可以实现高亮(不过这个不是分号,是esc键下面,tab键上面的那个按键)中间来实现高亮强调的效果; Markdown段落格式 字体 *斜体文本*和_斜体文本_都表示斜体; **粗体文本**和__粗体文本__都表示粗体;***粗斜体文本***和____粗斜体文本___都表示粗斜体文本; 分隔线 可以在一行下面用 *** 或者 --- 或者 ___ 来建立一个分隔线; 通过在文本前面添加&lt;u&gt;实现带下划线文本; 脚注 脚注是用来对文本进行补充说明的,你把鼠标移上去会有提示,格式是这样子的[^要注明的文本]; Markdown列表 无序列表 使用星号(),加号(+)或者减号(-)作为列表标记,我这里用的就是无序列表呀哈哈哈,如果要有层次感的话,就敲一个tab键再敲`,+,-`就好了,不过都要记得敲完符号了记得敲个空格哈; 例如这样子: 第1项 第1.1项 *第1.2项 第2项 第2.1项 第2.2项 第3项 第3.1项 第3.2项 有序列表 使用数字并加上.来表示; 就像这样子: 第1项 第1.1项 第2项 第2.1项 列表嵌套 列表嵌套很简单,下一行时,在前面添加四个空格就可以了; 就是这样子的: 第1项: 第1.1项 第2项 第2.2项 Markdown区块 这也是为了分层好看用的,其实和缩进也差不多了,就是用&gt;表示最外层,&gt;&gt;表示第二层,依次类推; 例子是这样的: 第1块 第1.1块 第2块 第2.2块 这个也是可以嵌套列表使用的; 例子如下: 区块中的列表 第1项 第2项 第1项 第2项 但是这里有两个要注意的地方: 就是如果要在列表中放区块,就需要在&gt;前面添加四个空格的缩进; 就像这个样子: 第一项 &gt; 我是fanfan999, 最爱lcl 使用&gt;缩进后,行与行之间必须空行,不然效果不出来; Markdown代码 这才是最重要的部分哈哈哈,不过前面都差不多提到了,那就再回顾一遍吧; 一点点代码可以用给包起来就行,例如System.out.println(&quot;fanfan999&quot;); 想要多行代码成为一块很显眼的地方,也就是高亮啦,我们可以使用在代码前一行和后一行添加三个这个`符号,在符号后面还可以备注什么语言,当然不备注也是可以的; 例子如下:123public static void main(String[] args)&#123; System.out.println(\"fanfan999\");&#125; Markdown超链接 格式是这样子的:[要显示的文字](链接的地址); 例如我的: 我的博客; 当然也可以直接使用地址哈哈哈!不过要把网址用&lt;&gt;包起来 像这样:https://fanfan999.github.io/fanfan999.github.io/; Markdown插入图片 图片格式如下: ! [alt 图片的替代文字] (图片地址 “可选标题”),也就是一个感叹号!+一个方括号[]+一个普通括号(),其中的最后一个”可选标题”效果就是你鼠标放上去会显示的文字,可写可不写, 也可以放本地图片,语法一样的,只是地址改为本地地址就好了 这个图片嘛…emmm,我自己试了显示不出来哈哈哈哈,对不起,是我太菜了,我搞出来了再补充.","categories":[{"name":"随笔","slug":"随笔","permalink":"https://fanfan999.github.io/categories/随笔/"}],"tags":[{"name":"Markdown<br>","slug":"Markdown-br","permalink":"https://fanfan999.github.io/tags/Markdown-br/"}]},{"title":"这是我的第一篇博客了","slug":"从今天起,","date":"2019-04-12T14:47:36.000Z","updated":"2019-04-12T15:39:36.049Z","comments":true,"path":"2019/04/12/从今天起,/","link":"","permalink":"https://fanfan999.github.io/2019/04/12/从今天起,/","excerpt":"","text":"从今天起, 我也是一个有博客的菜鸟了哈哈哈!用博客来记录我的复习,希望秋招能找到一个好工作吧!","categories":[],"tags":[]}]}