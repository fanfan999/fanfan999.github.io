<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Filter和Listener]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F05%2F22%2FFilter%E5%92%8CListener%2F</url>
    <content type="text"><![CDATA[servlet+filter+listener被称为javaweb的三大组件 Filter(重要) Filter: 过滤器 生活中的过滤器: 如生活中的净水器,空气净化器等都是过滤器. web中的过滤器: 当浏览器通过请求访问服务器资源时,过滤器可以将请求拦截下来,来完成一些特殊的功能. 过滤器的作用 一般用于完成通用的操作. 登录验证(类似淘宝要加入购物车必须先登录这样子). 统一编码处理,我们当提交表单的方式为post的时候,我们都要设置request的编码防止乱码. 敏感字符过滤. ……. filter快速入门 步骤 定义一个类,实现接口Filter,和servlet类似的. 复写接口中的方法. 配置拦截路径(即访问什么样的资源过滤器会生效),servlet配置的是访问路径. 第一种配置方式: web.xml. 第二种配置方式: 注解(常用),和servlet一样,写在urlPattern后面,且urlPattern几个字可以省略,一般后面写/*,表示访问所有资源之前都要先执行过滤器,写/demo.jsp则表示只有访问demo.jsp的时候才会执行过滤器. 放行,即让访问的资源中的内容显示出来 chain.doFilter(req, resp);, 其中的chain, req, resp这都是doFilter中的参数. 过滤器快速入门代码. 过滤器快速入门index.jsp页面. 这里有一个点要注意一下,就是如果你配置过滤器为/*的时候,就表示访问所有资源都要先执行过滤器,此时运行服务器,通过上面的代码,访问index.jsp,会发现index.jsp中的内容不会被显示出来,这个就可以理解为这样子: 假设我要回家.路上有土匪,这个土匪就相当于那个过滤器,我能不能过去,就要看土匪能不能放我过去,这就相当于上面的我访问index.jsp前执行了过滤器,我能不能显示index.jsp的内容,要看过滤器让不让我看这样子. 过滤器的细节 web.xml配置(反正我一般不用hhh,知道就行) &lt;filter&gt; &lt;filter-name&gt;demo1&lt;/filter-name&gt; &lt;filter-class&gt;这里填的是src下(不包括src)到资源文件的路径(就是包名.包名...类名)如`filters.IntroductionOfFilter`&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;demo1&lt;/filter-name&gt; &lt;url-pattern&gt;/*(注意这个是拦截路径,不是访问路径)&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 过滤器执行流程 大体来说就是,先通过对应的url访问资源,然后途中经过过滤器,过滤器经过处理后放行,放行后执行url对应资源的内容,结束之后又回到过滤器中,执行放行语句后面的操作. 放行语句前,会收到浏览器传来的请求,如果有操作request的语句,它会先执行操作request的语句. 执行放行语句,回到资源文件中执行相应操作. 资源文件执行结束后,回到过滤器中,执行放行语句下面的操作,即对相应消息的操作. 过滤器生命周期方法(三个) 服务器启动时创建Filter对象,然后由该对象执行init()方法去加载资源,而且只执行一次 —&gt; 每一次浏览器访问服务器经过过滤器时,由Filter对象去执行doFilter()方法,可以执行多次 —&gt;服务器停止时,Filter对象被销毁,如果服务器正常关闭(就是点红色的点,不是直接关闭之前说的tomcat窗口,反正我们在集成开发环境中点击关闭都是正常关闭的),此时执行destroy()去释放资源,只执行一次. 过滤器配置详解 拦截路径配置(有4种) 拦截具体的资源路径: /index.jsp, 表示只有访问index.jsp资源时,过滤器才会被执行. 注意,这里是不存在一个项目中有两个同名的index.jsp的,不管你在什么地方,都会报错的. 拦截具体目录: /user/*, 表示访问/user下的所有资源时,过滤器都会被执行 这里的/user/*不一定非得是一定存在user这个目录,也就是说/user/servlet并不一定表示servlet就放在真正存在的user包下,它只是表示所有前面有/user的url都会被user这个东西限制,也就是会经过过滤器. 如果真的是有这个目录,那么就要把东西放在目录下,同时在idea中要注意这里拦截的是具体目录不是模块包哈,目录和模块包有区别的,目录是自己新建的,模块包是idea生成的,如src,web模块包等,同时这样设置以后,访问的url也要变了,要加上目录了就要. 后缀名拦截的方式: *.jsp, 表示访问所有后缀名为.jsp资源时,过滤器都会被执行,注意前面没有斜杠. 拦截所有资源: /*, 表示访问所有资源时,过滤器都会被执行. 拦截路径设置代码. 拦截方式配置(两种方式): 指的是资源被访问的方式, 也就是说,比如我设置了浏览器直接访问资源的过滤器,当我从服务器内部转发的时候,就不会被拦截,但是重定向这种两次请求的就也会被拦截. 注解配置: 在注解filter注解中设置dispatcherTypes属性(有5种取值) REQUEST: 默认值.表示浏览器直接请求资源url,即直接在地址栏输入url路径访问. FORWEAD: 服务器内部转发访问资源. INCLUDE: 包含访问资源(了解) ERROR: 错误跳转资源(了解) ASYNC: 异步访问资源(了解) 当我既要在直接访问时能被过滤器加强,还要在内部转发时也被过滤器加强怎么办呢? 其实很简单,我们通过看webfilter的源码知道,它的dispatcherTypes属性是一个数组,所以我们直接这样写: dispatcherTypes = {DispatcherType.FORWARD,DispatcherType.REQUEST}. 当这样写的时候: urlPatterns = &quot;/*&quot;, dispatcherTypes = {DispatcherType.FORWARD,DispatcherType.REQUEST}, 表示转发和直接请求访问所有类型资源都会被过滤器加强,但是这样子的话,假如是以请求转发的方式访问index.jsp,过滤器就会被执行两次. web.xml配置: 配置资源路径的时候多设置这样一个标签即可,也有上述五个取值,一样的. 注解配置拦截方式代码. 过滤器链(配置多个过滤器) 执行顺序: 如果有两个过滤器(过滤器1,过滤器2) 过滤器1先执行 过滤器2再执行 资源执行 过滤器2回来执行 过滤器1回来执行 这个怎么测试呢?其实很简单,你就直接写两个过滤器,采用注解配置,其中过滤的url写成/*,然后随便访问一个路径,比如index.jsp的路径,然后你就会发现它两个都执行了(在注解配置中只要两个的filterName不一样,就会都执行,两个名字一样就只会执行前一个). 12345678910111213141516171819 @WebFilter(filterName = &quot;FilterDemo4&quot;, urlPatterns = &quot;/*&quot;) public class FilterDemo4 implements Filter &#123; public void destroy() &#123; &#125; public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException &#123; System.out.println(&quot;FilterDemo4执行了&quot;); chain.doFilter(req, resp); System.out.println(&quot;FilterDemo4回来了&quot;); &#125; public void init(FilterConfig config) throws ServletException &#123; &#125;&#125; 过滤器的先后顺序问题(两种): 注解配置的过滤器: 根据类名,按照字符串比较规则去比较,值小的先执行. 例如: AFilter和BFilter,它会先第一个字符比较,然后第二个字符比较…一次类推,在这里,第一个字符A&lt;B,就比较出来了,所以先执行AFilter. 又比如: Filter6和Filter17,它依次比较,比较到6 &gt; 1,所以Filter17会先执行. web.xml配置: 谁定义在上面谁先执行,就是谁写在前面就先执行谁,知道就好了. Filter案例 案例1_登录验证 需求 访问之前的用户增删查改的案例的资源。验证其是否登录,即权限控制. 如果登录了，则直接放行。 如果没有登录，则跳转到登录页面，提示”您尚未登录，请先登录”. 结合登录验证完整代码.Listener Listener: 监听器]]></content>
      <categories>
        <category>javaee</category>
      </categories>
      <tags>
        <tag>Filter和Listener</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试题之java基础知识]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F05%2F20%2F%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8Bjava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[Java基础知识 面向对象的特征表现在哪些方面? 封装: 最常见的就是把属性私有化封装在一个类里面,提供公共的方法去访问. 继承: 子类继承父类,从而继承父类的方法和属性. 但是有一点要注意: 那就是子类不能继承并使用父类的私有属性和方法,但是如果子类中公有的方法用到了父类的私有属性,那么子类调用该方法是不会报错的. 抽象: 比如一个抽象类,抽象出一个共同的属性,放在一个类中,使得开发过程更易理解. 多态: 多态包括操作符的多态和类的多态. 类的多态的三个必要条件: 父类引用指向子类对象. 有继承. 有重写. 操作符多态: 1 + 2的值就是3,这就是简单的算术运算. &quot;1&quot; + 2的值却是12,这是字符串相加. String是基本数据类型吗? 不是!!!String是类类型,它是一个类 基本数据类型有八种 整型(4种): byte(1个字节,占8位), short(2个字节), int(4个字节) ,long(8个字节). 字符型(1种): char(2个字节). 浮点型(2种): float(41个字节), double(8个字节). 布尔型(1种): boolean. 转换顺序: byte,short,char —&gt; int]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试题之java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSP,EL和JST]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F05%2F17%2FJSP-EL%E5%92%8CJST%2F</url>
    <content type="text"><![CDATA[JSPJSP基础语法jsp中既可以写java代码,也可以写html等静态代码,其本质就是一个servlet 指令 作用: 用于配置jsp页面, 以及导入一些资源文件. 格式: &lt;%@ 指令名称 属性名1=属性值1 属性名1=属性值1 …%&gt; 分类: page: 配置jsp页面. contentType: 等同于response.setContentType()这个方法. 可以用于设置响应体的mime类型和字符集. 设置当前jsp页面的编码(只能是高级的ide才能生效,如果使用记事本这样的低级开发工具,那就需要使用pageEncoding()来设置). import: 用来导java包,和java中导包一样. errorPage: 当前页面发生异常后,会自动跳转到指定的错误页面, 例如: &lt;%@page errorPage=&quot;index.jsp&quot; %&gt;,注意这个errorPage不能是当前页面,必须是其它的jsp页面. isErrorPage: 标示当前页面是否是错误页面,默认为false,但是,标示当前页面的isErrorPage为true之后,就可以使用内置对象exception了. isErrorPage示例代码 include: 页面包含的,导入页面的资源文件,比如我这个页面值写头部,其它页面要这个头部的时候直接包含进去就可以了. &lt;%@include file=”top.jsp”%&gt; taglib: 导入资源,一般用于导入标签库,相当于导包. &lt;%@taglib prefix=”a” uri=”http://java.sun.com/jsp/jstl/core&quot;%&gt; prefix: 前缀,自定义的名字这个标签的名字. uri: 标签库的url. 注释 html注释: : 只能注释html代码片段,注释的东西你再浏览器中查看源码还是可以看到. jsp特有的注释 &lt;%– –%&gt;: 可以注释所有(推荐使用,注释的东西就不会发送到浏览器,相当于删除了) 内置对象 在jsp页面中不需要创建可以直接使用的对象,一共有9个. pageContext(jsp中的域对象),真实类型为PageContext,其作用范围为: 当前页面,可以在当前页面共享数据,还可以获取其它八个内置对象(通过get方法). 12345&lt;% request.setAttribute(&quot;msg&quot;, &quot;hello&quot;);%&gt;&lt;%= request.getAttribute(&quot;msg&quot;)%&gt; request(jsp中的域对象),真实类型为HttpServletRequest,,其作用范围为: 一次请求访问的多个资源(通过转发实现). session(jsp中的域对象),真实类型为HttpSession,其作用范围为: 一次会话的多个请求间. application(jsp中的域对象),真实类型为ServletContext,其作用范围为: 所有用户间共享数据,服务器开启被创建,服务器关闭被销毁. response,真实类型为HttpServletResponse,其作用为: 作为一个响应对象. page,代表当前对象,等于this,真实类型为Object,其作用为: 表示当前页面(servlet)的对象 this. out,真实类型为JspWriter,其作用为: 输出对象,将数据输出到页面上. config,真实类型为ServletConfig,其作用为: 作为servlet的配置对象. exception(要声明该页面为isErrorPage=true才能使用),真实类型为Throwable,,其作用为: 作为一个异常对象. MVC开发模式(知道什么代码往哪儿写,很重要) jsp的演变历史 早期只有servlet,没有jsp,只能使用response输出标签数据,非常麻烦. 后来就有了jsp,简化了servlet的开发,但是如果过度使用jsp,在jsp中既写大量代码,又写一堆html标签,后期很难维护,别人也看不懂. 再后来,Java的web开发就借鉴了mvc的开发模式,使得程序的设计更加合理. MVC详解 M: Model, 模型.JavaBean 完成具体的业务操作,如: 查询数据库(对数据库的操作都放在Dao包下),封装对象. V: View, 视图. JSP 仅展示数据,就不写java代码了尽量. C: Controller, 控制器. Servlet 获取用户输入. 调用模型. 将数据(包括用户输入的和模型返回的)交给视图进行展示. 优点 耦合性低,所以方便维护,有利于分工协作. 重用性高. 缺点: 使项目架构变得复杂,对程序猿的要求更高,要有一个很完整的构思. 如图: . EL表达式(简化JSP中java开发代码) 概念: Expression Language 表达式语言. 作用: 替换和简化jsp页面中java代码的编写,注意它只能获取域中的数据,所以所有要使用el表达式的都需要先存到域对象中. 语法: ${表达式}. 注意: jsp默认支持EL表达式. 如果要忽略EL表达式,即将EL表达式当作普通字符串输出,有两种方法: 设置jsp中的page指令中的isELIgnored属性为true,即 &lt;%@page isELIgnored=&quot;true&quot; %&gt;,表示忽略当前jsp页面中所有的EL表达式,这样整个页面的EL表达式都会被当作字符串处理. 在EL表示式前加一个反斜杠\就可以了,例如 \${3 &gt; 4},表示忽略当前这个EL表达式. 作用: 运算 运算符 算术运算法: + - * /(div) %(mod),注意除法后默认是double类型. 比较运算符: &gt; &lt; &gt;= &lt;= ==. 逻辑运算符: &amp;&amp;(and) ||(or) !(not). 空运算符: empty,用于判断字符串,集合,数组对象是否为null并且长度是否为0. 例如: ${empty list},判断list对应的字符串,集合,数组对象是否为空或者长度为0,满足一个就返回true. ${not empty list},判断字符串,集合,数组对象是否不为null并且长度&gt;0,满足则返回true. 案例代码: 运算符示例代码. 获取值(通过属性获取值,越界时候输出都是空字符串,不会报错) 注意这里的属性就是get和set方法去掉get和set,剩下的部分再将首字母小写,即getAge()–&gt;age属性. EL表达式只能从域对象中获取值. 语法: ${域名称.键名称}: 从指定域中获取指定键的值. 域(4个): pageScope —&gt; pageContext. requestScope —&gt; rquest. sessionScope —&gt; session. applicationScope —&gt; application(即java中的servletContext). 举例: 在request中存储了name=饭饭,通过${requestScope.name}就可以得到张三. ${键名}: 表示依次从最小的域pageContext开始查找是否有该键对应的值,知道找到为止. 获取对象, List集合, Map集合的值 获取对象: ${域名称.键名.属性名}. 本质上是用对象去调用对应的get方法. List集合: ${域名称.键名称[索引]}. 比如说当索引为0,表示获取该集合中的第一个元素. 没有索引就输就所有值. 下标越界就输出空字符串,不会报错. Map集合: ${域名.键名.key名}或者${域名.键名[key名]}. 获取对象中的数据案例代码. 隐式对象: 可以直接拿来用,类似于jsp的内置对象,el表达式中有11个隐式对象. 这里注意一下pageContext就可以了: 可以获取jsp其它八个内置对象. 可以动态获取虚拟目录: ${pageContext.request.contextPath},可以用在jsp页面的form表单中,例如: action=”${pageContext.request.contextPath}/loginServlet”. JSTL标签(简化JSP中java开发代码) 概念: Java Server Pages Tag Library 即JSP标准标签库 是由Apache阿帕奇组织提供的开源的免费的jsp标签库 &lt;标签&gt;. 用于简化和替换jsp页面上的java代码. 使用步骤: 导入jstl相关的jar包. 引入标签库: taglib指令 &lt;%@ taglib %&gt; 使用标签. 这里在运行的时候我遇到了一个错The absolute uri: [http://java.sun.com/jsp/jstl/core] cannot be resolved in either web.xml or the jar files deployed with this application,这个错就是项目在部署的时候jstl的jar包在tomcat下的WEB-INF的lib中没得,将jar包复制到目录下就行了 常用的jstl标签 if,相当于java中的if,但是没有else. 属性 test, 必须属性,接收boolean表达式, 如果表达式为true,则显示if标签体内容 如果表达式为false,则不显示if标签体内容 如果表达式什么都不是也不会显示if标签体内容 一般情况下,test属性值会结合el表达式的empty运算符,比较运算符,逻辑运算符等一起使用. 注意: c:if标签没有else情况,想要else情况,就要重写一遍c:if标签. choose,相当于java中的switch. choose标签写一个星期几小案例 在域中存储一个数字. 使用choose标签取出数字 相当于switch的声明. 使用when标签做数字的判断,相当于case, &lt;c:when test=&quot;${number == 1}&quot;&gt;. otherwise标签做其它情况的声明,相当于default, &lt;c:otherwise&gt;. foreach,相当于java中的for循环. 属性: items: 容器对象 var: 容器中的临时变量 varStatus: 循环状态对象 index: 容器中元素的索引,从0开始 count: 循环次数,从1开始 jstl入门案例代码. 练习: 需求: 在request域中有一个存有user对象的list集合,需要使用jstl+el将list集合数据展示到jsp页面的表格中. 练习代码.三层架构(针对服务器而言): 软件设计架构 界面层(表示层): 即用户看到的界面,用户可以通过界面上的组件和服务器进行交互例如将数据封装提交. 业务逻辑层: 处理业务逻辑的. 数据访问层: 操作数据存储文件,如数据库,txt文件等. 针对web服务器而言,上述三层架构又叫web层, service层, dao(data access object)层. 其关系如图: . 案例: 用户信息列表展示1. 需求: 用户信息的查询操作 2. **[用户信息展示_查询代码]()**. 综合案例练习1. 简单功能 1. 列表查询(就是上面的,我是直接复制过来的). 2. 登录. 3. 列表添加. 4. 列表删除. 5. 列表修改. 2. 复杂功能 1. 删除选中的多条信息. 2. 数据分页查询. 3. 复杂条件查询. 3. [案例完整代码](https://github.com/fanfan999/WebCodes/tree/master/user_crud_complete).]]></content>
      <categories>
        <category>javaee</category>
      </categories>
      <tags>
        <tag>JSP,EL和JST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[桶排序]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F05%2F15%2F%E6%A1%B6%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[桶排序,计数排序,基数排序都不是基于比较的排序,也就是说他们与样本的实际数据情况有很大关系,实际中不经常使用,其时间复杂度都为O(N),额外空间复杂度都为O(N),而且都是稳定的排序 桶排序 桶排序就是一个概念,不是具体的一种排序方法,其中的基数排序和计数排序才是桶排序的具体实现. 举例: 现在有一个数组arr,里面存放着从0-60的共计61个元素,我们可以拿一个同样长度为61的新数组countArr,用来记录arr数组中每个数字出现的次数,最后遍历数组countArr就可以知道每个数出现了几次,就从0开始输出几次就好了,比如说1出现了3次,就输出111就可以了.计数排序 计数排序就是有多少个数对应放多少个桶,然后统计对应数出现的个数,最后遍历输出,不过这个很不实用,要是数据量太大了,就贼慢,所以一般桶的数量不会很多,就是这么个意思,理解理解就好了.基数排序(后面再说) 补充问题1. 案例(很重要): 给定一个无序数组,求如果排序之后,相邻两数的最大差值,要求时间复杂度为**O(N)**,且要求**不能用非基于比较**的排序. * 举例: 数组array: [3,1,6,2,7] 排序后: [1,2,3,6,7] 返回最大差值: 3 则本题解为 : 3 * 解法: 借用桶概念,但是没用桶排序 ![案例图解思路](). * 代码: **[案例代码](https://github.com/fanfan999/AlgorithmsCodes/blob/master/SortingCodes/Max_Gap.java).** 2. 在这里要注意一个问题: int i = 0; int j = 0; i = i++; 此时的i是为0的. i = i + 1; j = ++j; 此时i和j都是等于1的,一定要想清楚啊!!! 3. 用数组实现固定大小的栈,越界就报错: 实现添加功能`push`,取出栈顶元素但是不删除功能`peek`,取出栈顶元素并删除`pop`这三个功能 * **[数组实现固定大小的栈代码](https://github.com/fanfan999/AlgorithmsCodes/blob/master/SortingCodes/MakeArrayAsStack.java).** 4. 用数组实现固定大小的队列,越界就报错: 实现添加功能`push`,取出队列首元素但是不删除功能`peek`,取出队列首元素并删除`poll`这三个功能 * **[数组实现固定大小的队列代码](https://github.com/fanfan999/AlgorithmsCodes/blob/master/SortingCodes/MakeArrayAsQueue.java).**]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>桶排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cookie和Session]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F05%2F15%2FCookie%E5%92%8CSession%2F</url>
    <content type="text"><![CDATA[会话这些会话里的东西都是针对http协议而言的,而且,对于一个类,如果想被外界访问到,那这个类必须是servlet,因为只有servlet能被外界访问 会话: 一次会话中包括多次请求和响应,比如说两个人之间交谈,肯定不只有一句话,然后以其中一个人不说话了离开了为结束. 什么是一次会话呢: 浏览器第一次给服务器资源发送请求,会话建立,直到有一方断开请求连接为止. 会话的功能: 在一次会话的范围内的多次请求之间来实现共享数据. java中共享数据的两种方式: 客户端会话技术: cookie 服务器端会话技术: sessionCookie 概念: 它是客户端会话技术,它将数据保存在客户端. cookie快速入门 使用步骤: 服务器端创建cookie对象,其中cookie是一个类,绑定数据. 通过javax.servlet.http包下的Cookie实体类中的构造方法: public Cookie(String name, String value). 服务器端发送cookie对象. 通过javax.servlet.http包下的HttpServletResponse接口中的方法: void addCookie(Cookie cookie). 服务器端获取cookie,拿到数据. 通过javax.servlet.http包下的HttpServletRequest接口中的方法: Cookie[] getCookies(). cookie发送数据代码. cookie接收数据代码. 注意,当这个servlet在同一个浏览器运行时,response能够正常获取数据,但是如果不在同一个浏览器运行,就不会获取到数据. cookie实现原理 基于响应头set-cookie和请求头cookie来实现,这个可以在浏览器运行servlet的时候通过F12查看网络中响应头和请求头的变化知道. 如图: . 我们要知道不论是发送cookie还是接收,都是以http协议的响应和请求形式来实现交互的. 一个小技巧: 每次我们在idea中创建servlet时每次都要自己去写urlPattern还要在get方法里面调用post方法,这个就有点麻烦,这个过程是可以省略的,我们可以在idea中设置servlet的模板来解决这个问题. 如图: . idea中out目录中存放的是部署到tomcat中的文件,javase项目存放的就是编译后的文件,反正就是所有编译后的东西都在里面. cookie的细节内容 一次可不可以发送多个cookie? 可以 如何做到: 可以创建多个cookie对象,使用response调用多次addCookie()方法即可. 如果,多个servlet发送的cookie的键是相同的,虽然发送会都发送,但是接收的时候只会接收最后一个发送的, 假如两个甚至多个servlet中如果键都是”msg”,最后得到的值只有最后发送的一个msg的值. 默认情况下,在浏览器没有关闭前,运行同一个src文件夹下面的某个servlet之后,然后运行其它servlet,我们都会发现前面运行过的servlet中cookie对象中的的键值对也会带过去,而且是在请求头中带过去,哪怕你重启了服务器,只要没有关闭浏览器,下次运行前面的值都还在. 在浏览器中,每个cookie对象只会有一个备份,怎么理解呢,就是说你不管调用多少次某个servlet,在请求头中都只会有一个该servlet中的键值对信息,不会因为你刷新了多次就有多个,这也就侧面验证了假如多个servlet有相同键的cookie,只会保留最后一个的结论. cookie在浏览器中保存多长时间呢? 默认情况下: 当浏览器关闭后,cookie数据被销毁,说明cookie是存在于浏览器的内存中,也就是说重新打开浏览器就需要重新请求重新响应cookie数据. 设置cookie的生命周期让cookie实现持久化存储 使用cookie对象中的方法setMaxAge(int seconds)其中参数有三种取值: 当参数为正数时: 表示将cookie数据写到硬盘数据中,也就是实现了持久化存储,其中这个参数的大小就表示了cookies对象的存活时间,例如参数为30,表示30秒以后cookie文件就会被自动删除,在30秒内关闭浏览器重新打开再次获取该cookie对象依旧存在. 当参数为负数时: 表示使用默认值. 当参数为0时: 表示删除cookie信息. cookie持久化存储示例案例. 能不能存中文呢? 在tomcat8之前,cookie中不能直接存储中文数据,在tomcat8之后,cookie支持中文数据存储,但是还是不支持特殊字符. 在cookie中不要使用符号,会报错的. 那么,如果要在tomcat7及之前存储中文数据或者现在在cookie中带特殊符号,如空格,逗号等,就需要将它们进行转码—一般采用URL编码. 怎么实现URL编码呢?下面的记住上一次访问时间案例中有,通过URLEncoder类中的静态方法encode(String s, String enc). cookie存储中文示例代码. cookie获取的范围是多大呢,即共享问题. 假设在一个tomcat服务器中部署了多个web项目,那么在这些web项目中的cookie能不能共享? 默认情况下是cookie是不能共享的 但是可以通过方法: setPath(String path)来设置cookie获取的范围,默认该方法的参数设置为当前的虚拟目录. 即不调用该方法等同于cookie.setPath(&quot;/虚拟目录&quot;),表示只有在该虚拟目录下的资源,才能获取该cookie下的信息. 当我们将方法写成这样的时候: cookie.setPath(&quot;/&quot;),这表示在服务器根目录下的所有文件都可以访问该cookie下的信息,其中/表示服务器根路径,即localhost/,后面跟什么都行,例如localhost:8080/cookie/cookieServlet1和localhost:8080/cookie1/cookieServlet1都可以访问上面的cookie对象中的信息. 不同的tomcat服务器间cookie共享问题(有印象就行) 通过cookie的方法: setDomain(String path), 如果设置其一级域名相同(如news.baidu.com和tieba.baidu.com中的.baidu.com为他们的一级域名,所以他们的cookie数据可以共享),那么多个服务器之间cookie信息就可以共享了. cookie的特点和作用 特点 cookie存储数据在客户端浏览器,没有存储在服务器那么安全. 浏览器对于单个cookie的大小由限制(4KB左右,据浏览器而定),以及对同一个域名下的总cookie数量也有限制. 作用 cookie一般用于存储少量的不太敏感,不太重要的数据. 在不登录的情况下(登录之后我们的信息都是存储在数据库中)完成服务器对客户端的身份识别,例如我们对百度这个网页设置了不在首页显示天气,当我关闭浏览器下次再打开百度页面的时候,是不会显示天气的,这就是因为我们在设置了不显示天气以后,百度服务器就把这个设置用cookie对象响应给了浏览器并保存到硬盘中,下次我们再打开的时候,就是带着cookie数据打开的,此时该页面会自动读取我所带着的cookie中的数据并进行相应的设置. cookie案例(记住上一次访问时间) 需求: 访问一个servlet,如果是第一次访问,则提示: 您好,欢迎您首次访问. 如果不是第一次访问,则提示: 欢迎回来,您上次的访问时间为: xxxxxxxxx. 分析: 可以采用cookie来完成. 在服务器中的servlet判断是否有一个名为time的cookie 有,说明不是第一次访问 提示: 欢迎回来,您上次的访问时间为: 2019/05/15 16:30:55. 写回cookie: time=2019/05/15 16:31:00. 没有,说明是第一次访问 没有就去响应数据: 您好,欢迎您首次访问. 写回cookie:time=2019/05/15 16:30:55. 记住上一次访问时间代码实现. 一点小问题 我由于自己不小心在设置response编码格式的时候,把response.setContentType(&quot;text/html;charset=Unicode&quot;);写成了response.setContentType(&quot;content-type:text/html;charset=Unicode&quot;);,这样会导致什么问题呢?会导致直接把你要输出的内容下载下来,切记切记!. JSP入门 概念: Java Server Pages 即java服务器端页面,可以理解为一个特殊的页面,其中既可以直接定义html标签,又可以定义java代码. 用于简化书写!!!!! 原理 jsp本质上就是一个servlet,浏览器通过页面访问服务器的时候,服务器会将jsp转换为java文件,然后编译成.class字节码文件,最后通过字节码文件做出响应. jsp脚本:jsp定义java代码的方式 &lt;% java代码 %&gt;: 定义的java代码放在jsp文件转换为java文件后中的service方法中.该脚本中可以写所有在servlet的service方法中语句. &lt;%! java代码%&gt;: 定义的java代码,在jsp转换为java类后的成员位置,可以是成员变量,也可以是成员方法,这种用的不多. &lt;%= java代码%&gt;: 这就相当于一个输出语句,输出语句中可以定义什么,该脚本中就可以定义什么,如果成员位置和局部位置都有同一个变量,会输出成员变量的值. jsp内置对象: 指在jsp页面中不需要获取和创建就可以直接使用的对象,比如request对象,一共有9个内置对象,包括request,response,out(字符输出流对象,将数据输出到页面上和response.getWriter()类似)等,具体的后面再写. response.getWriter()和out.write()的区别: out对象定义在哪个位置就在哪个位置输出,而response.getWriter()对象不论定义在哪里,都会先于out对象输出,因为tomcat在给客户端做出响应前,会先找response缓冲区数据,再找out缓冲区数据. 我们用的时候尽量都要其中一个就可以了. jsp改造记住上一次访问时间代码. Session(接口) 概念: 服务器会话技术,在一次会话(表示session的范围)的多次请求间共享数据,将数据保存在服务器端的对象中—HttpSession,session也是域对象. 什么是一次会话呢,就比如我现在有两个servlet,通过session共享数据,当我把浏览器关闭后,这次会话就结束了,再打开浏览器就是一个新的会话,如果此时访问获取数据的servlet就会报错,就说明session的作用范围是一次会话. 快速入门 获取session对象: HttpSession session = request.getSession(). 使用session对象: 即HttpSession对象 Object getAttribute(String name). void setAttribute(String name,Object value). void removeAttribute(String name). 域对象都有这几个方法.. session快速入门发送数据代码. session快速入门接收数据代码. 原理: session的实现是依赖于cookie的 当我们第一次请求,服务器创建了session对象后,只有本次会话没有结束,后面一直都不会再创建新的session对象了,也就是说,你没有关闭浏览器之前,虽然多次运行发送请求的servlet网址,响应头也不会再有带session的id的键值对了. 原理图: . session的细节 当客户端关闭,服务器不关闭后,两次获取的session是否是同一个? 默认情况下,不是同一个. 那么我希望客户端关闭重新打开后后,session也能相同,而且可以直接获取session的数据,应该怎么做呢? 在获取session的servlet中创建一个cookie,键为JSESSIONID,值为session的id值,通过response的响应头set-cookie将其发送给浏览器,同时让cookie实现持久化存储.Cookie cookie = new Cookie(“JSESSIONID”, session.getId());cookie.setMaxAge(60*60);response.addCookie(cookie); 客户端不关闭,服务器关闭后,两次获取的session是同一个吗? 服务器关闭了,session对象就被销毁了,因为内存被释放了,所以说不是同一个. 因为对象不是同一个,所以说,原来的session对象中的数据我们是访问不到的,这就产生了数据丢失,这肯定是不希望看到的,所以这里需要提到两个点. session的钝化: 即在服务器正常关闭之前,将session对象序列化到硬盘上. session的活化: 即在服务器启动后,就session文件转化为内存中的session对象. 上面的两个功能tomcat已经为我们实现了,找到上述项目编译后的保存位置,放在tomcat保存目录下的webapps目录下,然后通过tomcat的lib目录启动tomcat,可以正常访问servlet,然后通过tomcat的lib目录正常关闭tomcat,我们会发现在tomcat的work目录会多一个session.ser的文件,里面就保存着session的id,重新正常启动tomcat之后,那个文件就会自动被删除,我们再次读取session的值的时候,它会自动把session的id通过请求头传递给服务器,所以我们可以正常读取session中的值. idea可以实现钝化,但是不可以实现活化的操作,重新启动服务器它会直接删除work目录然后新建一个,所以读取不到原session的数据. session的失效时间,即session什么时候被销毁 服务器关闭,session被销毁. session对象调用invalidate()方法自己销毁自己. session默认失效时间为30分钟,可以在apache-tomcat-9.0.19\conf\web.xml中查看到. session的特点: session用于存储一次会话的多次请求的数据,存储在服务器端. session可以存储任意类型,任意大小的数据. session与cookie的区别 session存储数据在服务器端,而cookie在客户端. session没有数据大小限制,而cookie有. session数据安全,cookie相对不安全. session可以存储任意类型的数据,而cookie只能存储string类型的,通过session.setAttribute()和新建cookie对象时可以知道. 案例:验证码 需求: 访问一个带有验证码的登录页面login.jsp. 用户输入用户名,密码以及验证码. 如果用户名和密码输入有误,跳转登录页面,提示: 用户名或密码错误. 如果验证码输入有误,跳转登录页面,提示: 验证码错误. 如果全部输入正确,则跳转到主页success.jsp,显示:用户名,欢迎您! 验证码案例代码.]]></content>
      <categories>
        <category>javaee</category>
      </categories>
      <tags>
        <tag>Cookie和Session</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法的稳定性及其汇总]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F05%2F14%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%8F%8A%E5%85%B6%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[排序算法的稳定性 什么是稳定性: 稳定性不是指在不同样本量的情况下,排序算法的时间复杂度的变化,而是指的是,在排序完成后,数组中相同元素的相对顺序不变,本来在前面的还是在前面. 能做到稳定性的排序算法 冒泡排序: 能实现成稳定的. 冒泡排序代码. 选择排序: 不能实现成稳定的. 选择排序代码. 插入排序: 可以实现成稳定的. 插入排序代码. 快速排序: 不能实现成稳定的. 快速排序代码. 归并排序: 可以实现成稳定的. 归并排序代码. 堆排序: 不能实现成稳定的,例如[5,5,5,6,6]. 堆排序代码. 稳定性的意义 如图: . 在工程中排序算法的综合应用 当数组元素为基本类型例如int,char等的时候,用快排,因为快排不需要区分原始顺序,1和1不需要管哪个在前哪个在后,因为基本类型相等的数无差异. 当数组元素为自定义对象例如Student,按照对象的某个字段来排序,用归并排序,自定义对象,就算某个字段相同,但是对于对象也可能是有差异的,所以用归并排序. 当数组长度很短(&lt;60)的时候,不管什么类型,用插入排序,因为常数项很低,在样本量低的时候就跑起来很快,比如在一个很大数组的归并的过程中,当分治的数组长度小于60的时候,可以直接用插入排序给后面的数组排序. 有关排序问题的补充 有一个问题,是奇数放在数组的左边,偶数放在数组的右边而且相对顺序不变,然后让你做到额外空间复杂度为O(1),时间复杂度为O(N),这个问题,我们是实现不了的,快排一般人是实现不了稳定的,面试问到了就怼一怼面试官把,这个面试官不是个好人哈哈哈.]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序算法的稳定性及其汇总</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP响应协议和Response]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F05%2F12%2FHTTP%E5%93%8D%E5%BA%94%E5%8D%8F%E8%AE%AE%E5%92%8Cresponse%2F</url>
    <content type="text"><![CDATA[HTTP响应协议: 响应消息 请求消息: 客户端发送给服务器端的数据. 数据格式: 请求行: 请求方式 url信息 请求协议/版本号. 请求头 请求空行 请求体: 针对post请求方式的,get请求方式没有请求体. 响应消息: 服务器端发送给客户端的数据. 数据格式 响应空行 响应头 响应行 响应体: 真实传输的数据,也就是我们传输的html这些文本文件,图片,音频等,这些浏览器都会解析出来. 响应字符串的格式 123456789101112131415161718192021HTTP/1.1 200 OKBdpagetype: 1Bdqid: 0xeaa47fdd0001895fCache-Control: privateConnection: Keep-AliveContent-Encoding: gzipContent-Type: text/html;charset=utf-8Cxy_all: baidu+42cf0987fef07e22ea09fde2f722a2b8Date: Sun, 12 May 2019 00:31:06 GMTExpires: Sun, 12 May 2019 00:31:06 GMTServer: BWS/1.1Set-Cookie: delPer=0; path=/; domain=.baidu.comSet-Cookie: BDSVRTM=13; path=/Set-Cookie: BD_HOME=0; path=/Set-Cookie: H_PS_PSSID=28883_1449_28981_21108_28518_28775_28721_28964_28830_28585_22160; path=/; domain=.baidu.comStrict-Transport-Security: max-age=172800Vary: Accept-EncodingX-Ua-Compatible: IE=Edge,chrome=1Transfer-Encoding: chunked空行写响应体,即页面展示的html内容. 响应行 组成: 请求协议/版本号 http响应状态码 状态码描述,如: HTTP/1.1 200 OK. 响应状态码(都是三位数字): 服务器告诉客户端浏览器本次请求和响应的状态,其大概分类有五种. 1xx: 可以理解为客户端给服务器发送消息,服务器只接收到了一半就没有数据了,然后服务器就在那里等着,等待一段时间后,就向客户端发送1xx的状态码,问客户端你到底还有没有东西这样子, 这个出现不多. 2xx: 表示本次请求和响应成功.代表状态码:200. 3xx: 表示重定向,就是说客户端浏览器访问到了服务器,说我要干这个事,这个servlet说,我干不了,但是我知道servlet2可以干,它就给浏览器返回一个响应说我干不了,同时给浏览器了一个小纸条,让它去找servlet2. 例如: 302(重定向),和request通过forward方法请求装发类似,都是敲一次回车,访问两个地方,不过这个是客户端去访问,而不是和forward方法一样服务器内部跳转. 例如: 304缓存,这么理解吧,就是客户端向服务器请求图片这些二进制数据,只能用字节流,每次请求都要从服务器下载就会很慢,它就想了个办法,当客户端第一次请求时候,就把这张图片缓存到浏览器客户端本地,下次客户端访问同一图片(图片未更改)时,服务器就返回304状态码,让客户端去自己本地找就好了. 4xx: 客户端错误 代表状态码: 404,表示浏览器所请求的url路径在服务器中没有对应的资源,一般都是由于浏览器url写错了或者servlet中资源路径错了的原因. 405,表示请求方式没有对应的doxxx方法对应响应,例如,我们在浏览器直接输入url地址时都是通过get方法访问的,但是我们不小心在servlet中把doget()方法删除了,就会出现这个状态码. 5xx: 服务器端错误,代表服务器内部出现异常了,代表状态码500,例如,我在dopost()方法中写了一个语句int i = 5/0,这个会抛出下标不能为0异常,此时我们在浏览器通过url访问该servlet路径,就会报错500. 响应头: 格式: 头名称: 值,和请求头一样,也是键值对. 常见的响应头 Content-Type: 服务器告诉客户端本次响应体数据格式以及编码格式,然后浏览器改变接收编码格式等保证接收正常不出现乱码,例如: Content-Type: text/html(表示文本格式);charset=utf-8. Content-disposition: 服务器告诉客户端以什么格式打开我的响应体数据. 默认值: in-line,表示在当前页面内打开. attachment;filename=xxx: 以附件形式打开响应体,比如说我们点一个超链接,它不会直接跳转到另一个页面,它会直接下载一个文件. Response 功能: 设置响应消息 设置响应行. 格式: 例如: HTTP/1.1 200 OK. 设置状态码: setStatus(int sc). 设置响应头. 方法: setHeader(String name ,String value). 设置响应体. 使用步骤: 获取输出流 字符输出流: ServletOutputStream getOutputStream(). 字节输出流: PrintWriter getWriter(). 使用输出流,将数据输出到客户端浏览器中 案例(代码): 重定向: 也是资源转发的方式. 完成重定向代码. 服务器输出字符数据到浏览器代码. 服务器输出字符数据到浏览器代码. 几个注意的点: 重定向的特点 转发特点 转发后浏览器地址栏路径不变. 转发只能访问当前服务器下的资源,就是同一个src下的资源. 转发是一次请求,两次跳转,不过是只按一次回车就可以了,可以通过request对象来共享数据. 重定向特点 重定向后地址栏发生变化,request的forword()方法跳转到另一个servlet,浏览器中url路径是不会变的,是跳转前的一个servlet路径;而response的重定向,浏览器中的url路径会直接变成最终的servlet路径.. 重定向可以访问到其它地方(服务器)的资源,就是在idea中不是一个项目中的资源,但是这个项目要部署到tomcat中哈,不然不知道虚拟路径的,以idea为例 首先两个项目都要加载到服务器. 然后在servlet中调用sendRediect(string url)方法跳转到目标servlet中就可以了,但是这里注意url必须是**/虚拟路径/资源路径**.. 当然也可以重定向到其它网站中去,例如: response.sendRedirect(&quot;https://www.baidu.com&quot;);,运行后就会直接跳转到百度页面去了,而request请求转发也是不可以的. 重定向是两次请求,访问两个页面,不过也是只敲一次回车,这个可以在浏览器中通过快捷键F12,然后在网络中查看到变化,这里我就不多赘述了哈,同时这里就不能用request对象来共享数据了. 路径写法 路径的分类 相对路径(不推荐使用): 通过相对路径不可以确定唯一资源,如: ./index.html,表示当前目录下,有一个index.html页面,你可以认为它不以/开头,以.开头. 规则: 要使用相对路径,就必须先找到当前资源和目标资源之间的相对位置关系. ./xx,代表当前目录. ../xx,代表后退一级目录. 绝对路径: 通过绝对路径可以确定唯一资源,如: http://localhost:8080/response/ResponseDemo1, 其也可以简化写成/response/ResponseDemo1,我们 可以认为以/开头的路径是绝对路径. 规则: 判断定义的路径是给谁用的, 通过这个请求将来从哪儿发出,从服务器发出就是给服务器使用的,从浏览器页面发出就是给客户端浏览器用的. 给客户端浏览器使用: 需要加虚拟目录,我们建议对虚拟目录动态获取. 给服务器使用: 不需要加虚拟目录. 基本上哈,就是除了@WebServlet(urlPatterns=&quot;/xx&quot;)中的url和request的请求转发中的路径为资源路径以外,其它所有地方填的url路径都是/虚拟路径/资源路径这个格式,例如重定向的时候(这个是从浏览器发出去的要注意啊),form表单中等. 还有一个要注意的点,就是重定向的到其它项目的时候,那个url也要带虚拟路径,这个其实就理解为是从浏览器发出的数据就完事了. 例子: 相对绝对路径举例. 注意 由于虚拟目录可能随时都需要改变,所以虚拟目录不能一次写死,要动态获取,这里就需要用到request对象中的String getContextPath()方法,当然这个只能用在类方法里面哈,html里面用不了的. 举例: 12String contextPath = request.getContextPath();response.sendRedirect(contextPath+&quot;/responseDemo2&quot;); 所以说,你要是还不知道虚拟目录是啥,你就打印一些context再去tomcat-&gt;编辑结构下面找一下就晓得了. 重定向方式: 告诉浏览器要重定向,通过setStatus()设置状态码302实现;然后告诉浏览器重定向servlet的路径,通过setHeader()方法设置响应头location:告诉浏览器重定向servlet的资源路径实现 这也是最常用的方法重点掌握: 通过sendRedirect(String url)实现,其中url表示重定向资源路径,格式和form表单中action的路径一致,都是/虚拟路径/资源路径,这两个东西不清楚就去看Request博客下request案例第5点的注意事项. 服务器输出字符数据到浏览器 步骤: 获取字符输出流. 输出数据. 产生乱码 乱码原因: 编码和解码使用的码表,即字符集不一致 浏览器使用的字符集可以通过IE浏览器点击右键查看编码知道,我电脑是Unicode编码. 而服务端的编码表由于是response调方法产生的,不是new出来的(new出来的那就和系统保持一致),而response对象又是tomcat产生的,tomcat又不是中国人写的,所以用的字符集不是Unicode,一般来说是ISO-8859-1的拉丁编码. 乱码解决办法: 在获取流之前,设置流的编码,通过一条语句设置: response.setContentType(&quot;text/html;charset=utf-8&quot;);,通过这句话可以告诉浏览器我的响应信息是文本类型的同时字符集是utf-8类型的. 服务器输出字节数据到浏览器 步骤: 获取字节输出流. 输出数据.注意: 这里为了防止出现乱码,在用response对象设置编码前,把request的编码设置为相同,同时设置字节流输出时byte数组的编码 案例: 简单的验证码 本质是一张图片 验证码的目的: 防止恶意表单注册,就是比如说没有验证码,我可以写个程序,生成不重复的你表单需要填的东西然后无限注册,你数据库迟早崩溃. 这个前端的js我就不会了,然后那个点击验证码换图片我不晓得咋整,暂时也不想去想那个东西. 前端代码: 验证码案例前端代码. 其余部分代码如下: 验证码案例代码.ServletContext(接口) 概念: 代表整个web应用,即整个web工程,可以和程序容器(服务器)例如tomcat进行通信. 功能: 获取MIME类型: MIME类型: 在互联网通信过程中定义的一种文件数据类型. 格式: 大类型/小类型, 例如: text/html,表示纯文本/html类型. 方法: String getMimeType(String file); 获取MIME类型案例代码. 域对象: 域对象主要是用来共享数据的,如request对象通过调用getAttribute()来共享数据. 域对象都有的几个方法: void setAttribute(String name, Object value)给name赋值; Object getAttribute(String name)通过名称获取值; void removeAttribute(String name); servletContext范围: 能共享所有用户所有请求的数据,就是只要你是在这个服务器运行的,在哪里运行都可以获取到,而且只要存储数据的类运行一次,它就会一直存在知道类被销毁. 共享数据示例代码_设置数据代码. 共享数据示例代码_获取数据代码. 获取文件的真实路径(服务器路径). 方法: String getRealPath(String path); 获取文件的服务器路径代码. 获取ServletContext对象 通过request对象获取: request.getServletContext(). 通过HttpServlet类获取: 这是该类的父类GenericServlet中的一个方法,由于我们的servlet都是继承子httpServlet,所以通过httpservlet获取也行,反正子类具有父类属性,即: this.getServletContext(). 文件下载案例用谷歌浏览器会直接下载,没有提示框,建议用ie 需求: 页面显示超链接 点击超链接后弹出下载提示框 完成图片文件下载 分析: 超链接指向的资源(比如图片)如果能够被浏览器解析,则该资源会在浏览器中展示,如果不能解析(比如视频),才会弹出下载提示框,这是不满足需求的.我们的需求应该是任何时候都要弹出提示框,这就需要response的响应头Content-disposition了. 使用响应头来设置资源的打开方式为附件形式: Content-disposition: attachment;filename=xxx. 步骤: 定义页面,编辑器超链接属性,让其指向servlet,但是这里就需要想到,我们有多个文件,每次弹出的提示框是不一样的,但是指向的都是同一个servlet,这时我们就需要在超链接中用到响应头Content-disposition中的filename=xxx来设置参数了!!! 定义servlet 获取文件的名称. 使用字节输入流加载文件进内存. 指定response的响应头Content-disposition. 将数据写出到response的输出流即可. 案例代码. 问题: 中文文件名问题(注意这个是不能用response.setContentType解决的),比如我的图片名字是哆啦A梦.jpg,在谷歌浏览器里面,它依旧会下载,但是下载名是空白或者下划线,那当然下载下来的东西自然也是看不了的;在ie里面直接会报错400. 解决思路: 获取客户端使用的浏览器版本信息. 根据不同的版本信息响应不同的数据,即设置filaname的编码方式不同,这里需要用到一个工具类. 今天用git推送资源的时候报了个错: unable to access &#39;https://github.com/fanfan999/WebCodes.git/&#39;: SSL certificate problem: self signed certificate,百度了一下,解决方案是: 输入这行命令 git config --global http.sslVerify false就可以了.]]></content>
      <categories>
        <category>javaee</category>
      </categories>
      <tags>
        <tag>reponse</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[堆排序]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F05%2F10%2F%E5%A0%86%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[堆排序(重要)前言: 时间复杂度为O(N*logN),额外空间复杂度为O(1). 二叉树: 二叉树就是一棵特殊的树,即每一个节点只有两个子节点. 满二叉树: 首先它是一个二叉树，如果这个二叉树的每一个层的结点数都达到最大值(或者理解为除了最下面一层没有任何子节点以外,其它所有层都是满满当当的二叉树)，则这个二叉树就是满二叉树。也就是说，如果一个二叉树的层数为K(K从1开始)，且结点总数是(2^k) -1 ，则它就是满二叉树,从形状上看,满二叉树就是一个完整的三角形. 叶结点: 当一个节点没有左节点和右节点的时候,这个节点就叫叶子节点. 完全二叉树: 若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。还有一种理解就是,如果除了最后一层和倒数第二层不满,其它层都是满的,并且最后这两层的节点都是从左到右依次补齐的,这个这个….大家画个例子就容易理解了,我也说不清楚了,大家百度一下哈哈哈. 二叉树其实是可以和数组对应起来的,我们可以通过数组在脑子里脑补出来它对应的完全二叉树结构,如图所示.. 堆(就是完全二叉树) 大根堆: 在这棵完全二叉树中,整棵树的最大值就是这棵树的根节点(也可以理解为它的头,反正就是最上面那一个节点),这个规则对于它的左右子树也同样成立,如[6,5,4,3,4],根据我上面画的自己脑补一下子哈. 小根堆: 同理,任何一颗子树(包括整个树)的最小值都是根节点,如[1,2,3,4,5]. 建立一个大根堆的时间复杂度是O(N),因为比如来说第一个数和根节点,也就是自己比较,时间复杂度为log1,第四个数,需要和自己的父节点和父节点的父节点比较,也就是要比较两次,即log(4),所以N个数的时间复杂度为: log(1) + log(2) +……+log(N) = O(N). 堆排序过程(以[3,5,4,5,6]为例) 让数组变成大根堆,即[6,5,4,5,3]. 把大根堆的最后一个位置和堆顶位置做交换,同时让堆的大小减一,此时,大根堆的根节点,也就是本数组中的最大值6就固定在数组最后一个数不动了. 让数组从0到array.length - 2(也就是大根堆的长度,本来是减1,但是因为刚才6放下来又减1了)重新建立大根堆,就变成了[5,5,4,3,6]. 然后又把大根堆第一个位置5的数和最后一个位置的数3,注意是3,不是6交换,再重复步骤3……循环往复. 当最后大根堆中只有一个元素就停止,此时数组就有序了,即[3,4,5,5,6]. 堆排序代码.]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>堆排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Request]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F05%2F10%2FRequest%2F</url>
    <content type="text"><![CDATA[Request Request和Response对象的原理 request和response这两个对象是由tomcat服务器创建的,我们不创建它们,我们只使用他们. request对象是来获取请求消息的,response对象是用来设置响应消息的. 原理图: . request对象的继承体系结构 ServletRequest(接口) HttpServletRequest(接口): 继承自ServletRequest. org.apache.catalina.connector.RequestFacade@1b59119e: tomcat实现了HttpServletRequest接口,编写了这个RequestFacade类,通过这个类创建request对象. request对象: 获取请求消息数据 获取请求行数据 请求行格式: GET /requestDemo(虚拟目录)/requestDemo1?name=fan HTTP/1.1 方法: 获取请求方式(GET): String getMethod(). 这个方法就是在service中判断判断是什么请求方法,然后由service去掉用对应的方法,所以我们不怎么用到. (重要)动态获取虚拟目录(/requestDemo): String getContextPath(). 获取资源路径,也可以称为servlet路径(/requestDemo1): String getServletPath(). 获取get方式的请求参数(name=fan): String getQueryString(). (重要)获取请求的uri,即虚拟目录+资源目录(/requestDemo(虚拟目录)/requestDemo1): String getRequestURI(). StringBuffer getRequestURL(): 返回整个url路径,比如http://localhost:8080/requestDemo/requestDemo1. url: 统一资源定位符. uri: 统一资源标识符,其代表的范围大于url,可以理解为url是中华人民共和国,而uri是共和国. 获取协议和版本(HTTP/1.1): String getProtocol(). 获取客户机的ip地址: String getRemoteAddr(). 演示代码. 获取请求头数据 方法 (重要)String getHeader(String name): 通过请求头的名称来获取请求头的值,其中name不区分大小写. Enumeration getHeaderNames(): 获取所有请求头的名称. 演示代码. 获取请求体数据 请求体只有POST请求方式才有请求体,在请求体中封装了POST请求的请求参数. 步骤: 获取流对象(字节流,字符流). BufferedReader getReader(): 获取字符输入流,只能操作字符数据. ServletInputStream getInputStream():获取字节输入流，可以操作所有类型的数据,这个在文件上传再说. 再从流对象中拿数据. 演示代码, 这个代码中文读出来是乱码,怎么搞都是乱码,果断放弃,后来才知道,这里需要将request的编码设置为Unicode,因为浏览器的编码表是Unicode的. 其它功能 获取请求参数通用方式(GET, POST都可以用来获取请求参数) String getParameter(String name): 根据参数名称来获取参数值,例如你有这样一串参数: user=饭饭&amp;password=123,我传入参数为user就可以得到饭饭这个值. String[] getParameterValues(String name): 根据参数名称获取参数值的数组,例如: hobby=abc&amp;def&amp;hij,我们通过这个方法就可以获取多个值,多用于复选框. Enumeration getParameterNames(): 获取所有请求的参数名称. Map&lt;String, String[]&gt; getParameterMap(): 获取所有参数的键值对集合. 中文乱码问题 通过实验发现有一个问题,就是如果表单的提交方式是post,传中文就会乱码;但是如果表单提交方式是get,传中文就不会出现乱码,为什么呢? get方式: tomcat8 就已经将get方式乱码问题解决了. post方式: 在获取参数前设置request的编码格式,多写一行代码就可以了: request.setCharacterEncoding(&quot;UTF-8&quot;);,括号中的参数和html文件中的编码格式一样就可以了,一般都是utf-8. 获取请求参数通用方式示例代码. 请求转发: 可以理解为一种在服务器内部的一种资源跳转方式,形象一点就是在同一个tomcat中,多个serevlet类之间互相跳转的方式. 步骤: 通过request对象调用RequestDispatcher getRequestDispatcher(String path)方法,获取请求转发器对象. 使用RequestDispatcher对象调用void forward(ServletRequest request, ServletResponse response)方法进行转发. 请求转发示例代码. 特点: 浏览器地址栏路径没有发生改变,就算跳转到了另一个servlet,但是地址栏中还是原来的servlet地址. 只能转发到当前服务器的内部资源中,就是说只能转发到一个tomcat服务器下的的东西,也就是同一个src文件夹下面的不同类可以相互随便转发,不在一个包没得事. 这样子的转发只发出一次请求,通过浏览器的f12然后查看网络,当我们输入链接后,发现浏览器只有一次请求. 共享数据 域对象: 一个有作用范围的对象,可以在范围内共享数据. request域: 代表一次请求的范围,一般用于一次请求转发到多个资源中去共享数据. 方法(都是用request对象调用的) void setAttribute(String name , Object obj): 存储数据,说白了就是给name赋值,而且什么值都可以,int,String都行. Object getAttribute(String name): 通过键获取值. void removeAttribute(String name): 通过键移除键值对. 示例代码1. 示例代码2. 获取servletContext对象 方法: ServletContext getServletContext(). 案例代码: System.out.println(request.getServletContext());,在浏览器输入网址:http://localhost:8080/requestDemo8后得到一个对象的地址. request案例: 用户登录 需求: 编写login.html登录页面,有username和password两个输入框. 使用druid数据库连接池技术,操作mysql. 使用jdbcTemplate技术封装jdbc. 登录成功跳转到SuccessServlet,同时显示: 登录成功! 用户名, 欢迎您!字样. 登录失败跳转到FailServlet,同时显示: 登录失败! 用户名或 密码错误!字样. 开发步骤: 创建项目,创建html页面,导入druid配置文件以及一系列jar包. 创建数据库环境,在数据库中建表,插入一点数据等. 创建一个domain包,创建一个实体类User 这里有一个叫法,我们把实体类也叫做javabean,就是一般都只有get和set方法,提供属性这些的. 创建一个dao包,创建类UserDao,在类中提供login方法. 创建servlet包,同时创建loginServlet类. 注意: login.html中form表单的action的路径的写法: 虚拟目录(就是我之前说的点击tomcat-&gt;编辑结构-&gt;Deployment-&gt;Application context中的路径,如果只是一个斜杠就表示虚拟目录不用写) + servlet的资源路径. 创建SuccessServlet和FailServlet类. 建立一个BeanUtils工具类,简化数据的封装(我这里会有问题,就是用这些工具类永远获取不到用户名,我也不晓得为啥). 登录案例代码. JavaBean: 标准的Java类(一般放在domain包里面) 要求 类必须被public修饰. 必须提供空参的构造器. 成员变量必须使用private修饰. 提供公共的getter和setter方法. 功能: 封装数据的 成员变量: 如private int age中的age就是成员变量. 属性: getter()和setter()方法截取后的产物,例如: getAge()方法中的Age就是属性,一般和成员变量名字相同. 方法: setProperty(Object bean, String name, Object value): bean表示一个javabean对象,例如user; name表示一个属性名,例如getAge中的age,这个必须写成小写,虽然方法名中是大写; value表示前一个参数属性名的属性值. getProperty(Object bean, String name): 含义和上面一样. populate(Object obj, Map map):这个比较重要,将map集合中的键值对信息封装到对应的javabean对象中.]]></content>
      <tags>
        <tag>Request</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速排序]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F05%2F08%2F%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[快速排序(重要,用的很多)一个引入例子 荷兰国旗问题 荷兰国旗问题就是指,给定一个目标数target和目标数组array,设计一个方法,使得该数组中大于target的数都放在左边,小于target的数都放在右边,等于target的数都放在中间. 步骤: 设计一个左边界,使其初始位置在下标0的左边一位. 设计一个右边界,使其初始位置在最后一个元素下标的的右边一位即array.length. 给定一个计数变量cur,记录当前数组中第几个数在被操作比较. 如果array[cur] &gt; target,则左边界的下一位数和当前位置的数交换,同时左边界移动到下标为1的位置,即左边界++右移一位,以及当前位置下移一位. 如果array[cur] &lt; target,则右边界的前一位数和当前位置的数交换,同时右边界下标为array.length - 1的位置,即右边界--左移一位,注意,此时当前位置不移动,因为交换过来的数没有进行判断. 如果array[cur] == target,不坐任何操作,当前位置++. 这个代码其实很简单,可能我说不是很好理解,我直接贴代码: 荷兰国旗问题代码. 其时间复杂度为o(N),额外空间复杂度为O(1). 根据荷兰国旗问题的快速排序 快速排序怎么排? 给定一个数组[1,2,3,4,5,4,3],然后把数组的最后一个数1作为比较的数. 和最后一个数1相比,跟荷兰国旗一样,小的放左边,大的放右边,等于的放中间. 然后再去对小于区和大于区这样做 ……如此循环下来,数组就有序了. 快速排序代码. 这种快排别经典快排要快一些,经典快排一次只排一个数,而这种一次可以把相等的都放好,反正我学了这种我就把经典快排忘了哈哈哈. 它的时间复杂度: 当已经有序的来排序的时候,例如[1,2,3,4,5,6],来排序的时候,每次都用最后一个去比较,每次都只能排序一个,这样子的左右部分规模差别很大的时候,时间复杂度为O(N^2). 最好的情况是,每次左边界和右边界的数都差不多相等,然后就是一个递归的过程,时间复杂度就和归并一样了,为O(N*logN). 这就是经典快排的缺点,和数据的状况有一定关系. 随机快排 随机快排就是指在给定排序的数组中随机选择一个数去作为本次的参照数,虽然这样子还是有可能出现左右部分的规模差别很大,不过这个就是概率问题了,所以这样的快排时间复杂度就只能用平均时间复杂度,也就是我们的期望值来表示. 这个时间复杂度就记住就可以了,反正我不会证明,数学不好,随机快排期望时间复杂度为: O(N*logN),额外空间复杂度为O(log(N))(这个就可以理解为每次断点打在中间,因为要记录相等点的位置,所以浪费了空间,最差额外空间是O(N),因为就相当于每个点都要记下来). 随机快排相较于上面的快排就只多了一行代码,这行代码使得我们随机找出来一个数作为最后一个数,也就是参照数哈哈哈,我在代码里标注出来了,代码: 随机快排代码.]]></content>
      <categories>
        <category>快速排序</category>
      </categories>
      <tags>
        <tag>快速排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet和HTTP请求协议]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F05%2F08%2FServlet%E5%92%8CHTTP%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[Servlet 什么是servlet? 即server applet, 运行在服务器端的小程序 一个小技巧,java里面的规则都可以理解为接口. servlet就是一个接口,定义了java类被浏览器访问到(可以被tomcat识别)的规则,这也就是为什么servlet不用main方法也可以执行的原因,它是由tomcat执行的. servlet是用在动态项目里的,我们都知道动态项目,每个人去访问得到的结果可能是不一样的,那么怎么使得结果不一样呢? 就是通过java代码来实现的,而这些java代码,满足servlet定义的规则,不需要主方法,被tomcat这个服务器软件执行,例如: 张三发出请求,服务器响应张三欢迎你,李四发出请求则响应李四欢迎你这样子. 可以通过javaee的api找servlet看一看,直接百度就有,javaee的api7. 将来我们自定义一个类,实现servlet接口,重写其方法,那么这个类就被称为servlet,也可以被tomcat识别并执行. servlet快速入门 创建一个javaee项目. 定义一个类,实现servlet接口(要导入servlet包,idea会提示你的). public class ServletDemo1 implements Servlet. 重写接口中的抽象方法. 在web.xml中的标签下配置servlet. servletDemo1 servlets.ServletDemo1 &lt;!--对servlet做一个映射,表示servletDemo1对应的类是servlets.ServletDemo1--&gt; &lt;servlet-name&gt;servletDemo1&lt;/servlet-name&gt; &lt;!--表示这个类可以被哪个路径访问到, 所以/demo1表示一个资源路径--&gt; &lt;url-pattern&gt;/demo1&lt;/url-pattern&gt; 完成之后,访问localhost:8080/demo1就会在控制台输出写在service方法中的hello,servlet,因为我们之前设置tomcat的时候,把虚拟路径是省略了的,所有直接访问url名称,然后通过url去找到servlet类就可以了. servlet快速入门案例代码. servlet执行原理 当服务器接收到客户端浏览器的请求后,服务器会解析请求的url路径,获取访问的的servlet的资源路径,如通过”http://localhost:8080/day3_tomcat/demo1&quot;这个url路径,我们可以知道`demo1`这个东西在`day3_tomcat`目录下. 查找对应的web.xml文件,看是否有与demo1这个资源路径对应的&lt;url-pattern&gt;标签. 如果有,则再在&lt;/servlet-mapping&gt;中通过&lt;servlet-name&gt;找到对应的&lt;servlet-class&gt;标签下的内容,找到对应的类. tomcat通过反射会将字节码文件加载进内存(Class.forName()),然后创建其对象(通过newInstance()). 调用其方法. servlet中的方法(5个) public void init(): 初始化servlet,在创建servlet的时候执行,只会执行一次. servlet什么时候被创建呢? 默认情况下,第一次被访问时,servlet被创建. 我们可以在xml文件中配置指定servlet的创建时机. 在xml中的&lt;servlet&gt;标签下,加入一行语句: &lt;load-on-startup&gt;&lt;/load-on-startup&gt;,当该标签内容为0或正整数时,表示servlet在创建时就被初始化;而当该标签内内容为负数时,表示servlet在第一次被调用时初始化,同时该内容默认为-1. init()方法只执行一次,说明servlet在内存中只存在一个对象,也就是说,servlet是单例的. 当多个用户同时访问时,可能存在线程安全问题. 解决方案: 尽量不要在servlet中定义成员变量,就没有共享的变量了,而且,即使定义了成员变量,也不要对其进行修改操作,就不会出问题. 修改初始化时机示例代码. public ServletConfig getServletConfig(): 获取ServletConfig对象,该对象就是servlet的配置对象,了解一下就行. public void service(): 提供服务的方法,servlet被调用就会被执行,可以执行多次. public String getServletInfo(): 获取servlet的一些信息,如版本,作者等,了解就行. public void destroy(): 销毁servlet,在服务器正常关闭,servlet被杀死的时候执行,也只执行一次. destroy()方法执行时机在servlet销毁前,可以把这个方法理解为临终遗言哈哈哈. 生命周期 被创建 提供服务 被销毁 servlet3.0 好处: 支持注解配置,也就是说不需要注解文件配置. 步骤: 创建javaee项目,选择servlet的版本为3.0以上(就是idea创建java enterpeise模块的时候选择web application之后下面的version在3.0以上就可以了,在jdk6以后就支持了),此时就可以不用创建web.xml文件了. 定义一个类,实现servlet接口,作为servlet使用. 重写servlet接口中的抽象方法. 在类上(就是继承servlet接口的类!!)使用注解(annotation)@WebServlet进行配置. @WebServlet(“urlPatterns = “/servlet资源路径即“”). 再次回想虚拟目录,虚拟目录就是我们项目文件夹的访问方式,也就是localhost:8080/day1_servlet/demo中的day1_servlet,我们之前给他省略了. servlet3.0示例代码. idea与tomcat相关配置 idea会为每一个tomcat部署的项目单独建立一个配置文件. 启动tomcat在控制台会有这样一个语句Using CATALINA_BASE: &quot;C:\Users\asus\.IntelliJIdea2018.3\system\tomcat\_Web_Codes&quot;. 工作空间项目和tomcat部署的web项目存放的目录不在一起,后者放在idea中直接打开文件位置的out目录下面,我这里在D盘,前者就是直接打开在文件夹中位置的目录(通过上述路径下配置文件中的root.xml也可以看到). tomcat真正访问的是tomcat部署的web项目,该项目对应着工作空间项目的web目录下的所有东西,其实就是idea直接能看到的东西. WEB-INF目录下的资源不能直接被浏览器访问,即如果不小心将html文件写到了该目录下,输入对应的url是访问不到的. servlet接口的实现体系结构 我们直接让类继承servlet接口的时候,接口中的所有方法我们都必须重写,但是很多时候其它方法我们用不到,我们只需要一个service()方法就可以了,这样子就显得代码很冗余,所以servlet做了一些改进. 它其中的两个实现类 GenericServlet: 抽象类 HttpServlet: 抽象类 因为上述两个是抽象类,所以我们写servlet的时候可以不用去实现servlet,可以直接继承上述servlet的实现类. GenericServlet类(不怎么用) 它将servlet接口中的其它方法做了默认空实现,只将service()方法作为抽象方法,子类必须实现,其它方法子类可以手动选择重写. 所以将来定义servlet类时,可以继承自该类,同时只需要实现service()方法. HttpServlet类(推荐),可以不用管是get还是post方式获取数据,service()方法中自动判断,然后调用对应的doGet或者doPost方法. 该类可以理解为是对http协议的一种封装,简化操作. 步骤: 定义类继承HttpServlet类. 重写doGet或者doPost方法. 浏览器访问servlet是get(浏览器地址栏会显示你输入的信息)方法,表单可以设置为post(不显示输入信息)方法. servlet的相关配置 : servlet访问路径. 路径定义规则: /xxx. /xxx/xxx/……,多层路径,访问时必须把多层路径都写上,当然这也有一个特殊写法: /xxx/*,这表示第二层你随便写什么都行,甚至只写/xxx/都可以,/*表示通配符,不过这个优先级很低,要等其它的都找完了才来找它. *.do,前面不能加/,就直接写urlPatterns = &quot;*.do&quot;),这表示用例如demo4.do就可以访问到demo4这个资源了. 注意: 我们查看WebServlet的源码可以知道,使用注解定义url-pattern时,url-pattern在源码中是一个数组,说明是可以有很多个的,即可以让多个访问路径访问一个servlet. 书写方法: @WebServlet(urlPatterns = {&quot;/访问路径1&quot;, &quot;/访问路径2,......&quot;}). 这里当访问路径只有一个的时候{}才能省略,多个的时候不可以省略.HTTP请求协议HTTP 概念: Hyper Text Transfer Protocol 超文本传输协议 传输协议: 定义类了客户端和服务端通信时发送数据的格式,有了这个协议,两边才可以读懂传输信息的内容. 特点 基于TCP/IP的高级协议,所以http也是一种安全的协议. http默认端口号: 80,当我们把tomcat的端口号设置为80的时候,此时的访问网址中的端口写不写都一样,例如: http://localhost:80 == http://localhost. 基于请求响应模型,响应和请求是一一对应的,即一次请求对应一次响应. http协议是一种无状态的协议,即每次请求之间相互协议,请求与请求之间没有关系,不能相互交互数据. 历史版本(现在有2.0版本) 1.0: 每一次请求响应都会新建一个连接,请求响应完成就断开本次连接. 1.1: 不会每一次请求响应都新建一个连接,它会复用同一个连接来完成多次请求响应,本次请求响应完成后在那里等一会,还有东西来就继续传,没有了再断开. 请求消息数据格式(四部分) 请求行 请求方式 请求url 请求协议/协议版本 对于login.html文件其请求行是这样的 GET /login.html HTTP/1.1 请求方式: HTTP协议有7种请求方式,常用的有两种. GET: 其请求参数在请求行中,即在url网址后面(重要). 请求的url长度是有限制的. 不太安全. POST: 其请求参数在请求体中,不放在网址中(重要). 请求的url长度是没有限制的. 相对安全. 请求头: 浏览器告诉服务器一些信息. 格式为: 请求头名称: 请求头值,多个值中间用,隔开,类似于键值对的形式. 常见的请求头 Host: 找到访问的主机:应用程序. User-Agent: 浏览器告诉服务器,我访问你是用的浏览器版本信息,可以在服务器端获取该头的信息来解决浏览器的兼容性问题. Accept: 告诉服务器我可以接受什么样的格式的信息响应. Accept-Language: 告诉服务器我支持的语言环境. Referer: 告诉服务器,我(当前请求)从哪里来,例如:http://localhost:8080/hello.html. 作用: 防止盗取链接,举一个例子: 比如我们在腾讯视频看电影,都是点击电影名字超链接比如速度与激情,然后就会跳转到电影播放页面,这个过程腾讯是需要给这部电影版权费的,但是有些盗版网站,他没钱买版权,但是又想蹭热度,所以他就也写了一个名字超链接如速度与激情1080P,然后把这个超链接的地址指向腾讯的播放页面,这就叫盗链,为了防止别人盗链,就用到了refer这个请求头,设置了该请求头之后,我就会判断一下这个超链接是否是从腾讯首页跳转过来的,是就正常播放,不是就不播放. 统计工作,还是上面的例子,虽然盗链不可取了,那么我就只能去买版权,买了之后我要挣回本甚至赚钱呀,我就需要把我的网站推广,我就给很多推广公司给钱,比如给百度给了100W,搜狐给了100W,然后我通过设置referer这个请求头计数每个月从百度过来的流量是多少,从搜狐过来的流量是多少,就可以知道以后在哪里多投资了. Host: localhost:8080User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:66.0) Gecko/20100101 Firefox/66.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,/;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateConnection: keep-aliveUpgrade-Insecure-Requests: 1If-Modified-Since: Thu, 09 May 2019 02:41:59 GMTIf-None-Match: W/“247-1557369719386”Cache-Control: max-age=0 请求空行: 就是一个空行,用作分隔请求头和请求头和请求体等. 请求体(正文): 传输的内容(参数),比如username= fan,用于封装POST请求的请求参数,GET请求没有请求体.]]></content>
      <categories>
        <category>Servlet</category>
      </categories>
      <tags>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F05%2F08%2FTomcat%2F</url>
    <content type="text"><![CDATA[Tomcatweb相关概念回顾 软件架构 C/S: 客户端/服务器端. B/S: 浏览器/服务器端(javaee重点,下面都是针对B/S模式的),通过url域名访问,浏览器不用向客户端那样维护. 浏览器发出请求给服务器接收处理. 服务器端对浏览器的请求做出响应. 资源分类(对于服务器来说) 静态资源: 如html,css,js等,所有用户访问得到的结果都是一样的. 浏览器请求访问静态资源时,静态资源直接交给浏览器,而浏览器中有针对静态资源的解析引擎,所以浏览器可以直接解析静态资源展示效果. 动态资源: 每一个用户访问相同资源后得到的结果可能不一样.比如:servlet,jsp,php等. 浏览器请求访问动态资源时,动态资源首先要转换为静态资源再返回给浏览器解析从而展示效果. 网络通信三要素 IP: 找到服务器电脑,这是电子设备(这里就是计算机)在网络中的唯一标示. 端口: 应用程序在计算机中的唯一标示,0~65536,自己写代码的时候一般我们都写10000以上. 传输协议: 数据传输规则. TCP: 安全协议,三次握手保证安全连接,速度稍慢. UDP: 不安全的协议,不建立连接,速度快.web服务器软件: Tomcat 什么是服务器呢? 服务器就是指安装了服务器软件的计算机,例如装了MySql我的电脑就可以被叫做MySql服务器. 服务器软件的作用: 接收用户请求,处理请求,做出响应. web服务器软件: 接收用户请求,处理请求,做出响应. 在web服务器软件中,我们可以部署web项目,让用户通过浏览器来访问这些项目. 也可以被称为web容器. 常见的java相关的web服务器软件 WebLogic: oracle公司的, 大型的javaee服务器,支持所有的Javaee规范,收费的. 什么是javaee呢? javaee是指java在企业级开发中使用的技术规范的综合,一共规定了13项大的规范. WebSphere: IBM公司的,大型的javaee服务器,支持所有的Javaee规范,收费的. JBOSS: JBOSS公司的,大型的javaee服务器,支持所有的Javaee规范,收费的. Tomcat: Apache(阿帕奇)基金组织的,中小型的javaee服务器,仅仅支持少量的javaee规范,开源的. Tomcat: web服务器软件 下载: tomcat下载地址 ,去下载自己电脑对应的版本就可以了. 安装: 解压压缩包就算安装好了哈哈. 安装目录最好不要带中文和空格. 卸载: 删除tomcat的安装目录就可以了. 启动: win: bin目录–&gt;start.bat,linux: bin目录–&gt;start.sh. 注意: 当你点击启动后窗口一闪而过,就是你没有配置环境变量,要配置四个环境变量,反正我是这样子了才可以的. 新建环境变量CATALINA_BASE并配置为: E:\Java\apache-tomcat-6.0.29. 新建环境变量CATALINA_HOME并配置为: E:\Java\apache-tomcat-6.0.29. 新建环境变量TOMCAT_HOME并配置为: E:\Java\apache-tomcat-6.0.29. 在环境变量Path中，新增加“%TALINA_HOME%\bin\ “. tomcat启动报错,就是启动成功后再一次启动黑窗口一闪而过的样子,通过查看日志文件可以知道,原因是因为端口号被占用了. 解决方案1: 停止占用该端口号的应用程序进程.可以在dos窗口下输入netstat -ano通过找到本地地址后四位为8080的进程,记住其PID,然后在进程中停掉它就可以了. 解决方案2: 修改自身的端口号,在config目录下找到配置文件server.xml中修改port就可以了. 一般我们修改tomcat的端口号为80,因为80是http协议的默认端口号,这样我们访问就不需要输入端口号了. 完成这四步以后,再点击start.bat就可以成功启动tomcat了,有可能有乱码问题,这个无关紧要. 然后打开浏览器,输入http://localhost:8080,就可以访问到tomcat的官网去了哈哈,当然要通过别人电脑访问的话,localhost就要换成你电脑的ip地址了. 关闭: 正常关闭: 理解为电脑关机. 双击bin目录下的shutdown.bat. 在启动的黑窗口按下ctrl+c. 强制关闭: 把黑窗口关掉,可以理解为电脑突然断电了哈哈哈. 配置: 部署项目的方式: 直接将项目放到webapps目录下即可,就可以通过例如: http://localhost:8080/hello/hello.html访问了 其中hello表示一个名为hello的文件夹. /hello:表示项目访问路径,也就是虚拟目录,一般名称与目录名相同,访问的时候,就是通过虚拟目录名称找到文件所在文件夹的. /hello.html: 表示文件名称. 简化部署: 将项目打包成一个.war压缩包,再将.war包放到webapps下面,他就会自动解压缩,删除的时候也只需要删除.war包就可以了,解压的文件他会自动删除. 配置config目录下的server.xml文件中的&lt;Host&gt;标签体,在其中添加一些语句: &lt;Context docBase = &quot;文件路径(文件所在文件夹的路径)&quot; path = &quot;/servlet资源路径,即url路径,一般写成和文件名称相同,也就是项目名称,也就是最终通过这个path访问的东西&quot; /&gt;. (推荐)在apache-tomcat-9.0.19\conf\Catalina\localhost目录下新建一个任意名称的xml文件,然后在文件中添加一句&lt;Context docBase = &quot;文件路径(文件所在文件夹的路径)&quot;/&gt;. 注意: 此时的虚拟目录就是xml文件的名称,这是一种热部署方式,当我们不想运行这个文件了,但是又不想停掉服务器,我们就可以给这个xml文件加上后缀_bak,我们就访问不了了. 静态项目和动态项目 静态项目: 只能放静态资源 动态项目: 可以放静态资源和动态资源 目录结构(以java动态项目的目录结构为例): —项目的根目录(例如tomcat中webapps下面的root目录) —WEB-INF目录(只有动态项目才有这个目录) —web.xml: web项目的核心配置文件 —classes目录: 放置字节码文件的目录 —lib目录: 放置依赖的jar包. tomcat解压后各个目录分别是干啥的呢? bin目录: 可执行文件. conf目录: 配置文件. lib目录: 依赖的jar包. logs目录: 日志文件. temp目录: 临时文件. webapps目录: 存放web项目的. work目录: 存放运行时的数据. 将tomcat集成到idea中,并且创建javaee项目,部署项目. emm,这个东西不大好写,百度也有好多,我就我就不写了哈. 然后有个技巧就是,热部署,就是你修改了html文件这些会自动跟新,在On update action里面,这些百度也有,我就是提醒一下那个就叫热部署罢了,然后一般选第一个选项update resources就可以了,不要选第二个,因为java代码带动可能会很多,改一下重新部署一次有点浪费资源,这个就手动重新部署吧哈哈,不过电脑比较好选也没事. 还有一个要注意的点就是:我们eclipse直接输入localhost:8080就可以访问index.jsp页面,但是idea默认情况下localhost:8080/......,这个斜杠后面就是我们上面说的虚拟目录,怎么让他消失呢?你点tomcat会有一个下拉栏,点击编辑结构,然后把Deployment下面的Applicationic context改为/就可以了. 今天有点懒,就懒得贴图了,不懂就给我发消息吧,我帮你搞也行.]]></content>
      <categories>
        <category>Tomcat</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[xml基础]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F05%2F07%2Fxml%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[xml基础xml 概念: Extensible Markup Language 可扩展标记语言. 可扩展: xml标签都是自定义的,例如,. 功能 存储数据: 可用作配置文件. 可用于在网络中传输. xml与html的区别: 他俩的亲爹都是w3c(万维网联盟),XML 是 W3C 的推荐标准.xml晚于html产生,因为html由于浏览器的恶性竞争(浏览器解析能力不同)导致html语法不那么严格也可以达到相同的效果. xml始终争不过html,所以它改为与properties(只能存键值对)竞争,例如name = zhang, gender = nan 和 name = li, gender = nv 在这里我凭什么不可以认为zhang的性别是nv呢?而xml可以通过标签包裹用户信息,例如&lt;user id = &#39;1&#39;&gt;&lt;name&gt;zhang&lt;/name&gt; &lt;gender&gt;nan&lt;/gender&gt;&lt;/user&gt;,这样子可读性更高,而且容易理解. 区别1: xml的标签都是自定义的,html标签都是预定义的. 区别2: xml的语法严格,html的语法松散,很难写错. xml是存储数据的,html是展示数据的(将数据内容展示到页面上). 语法 基本语法: xml文档的后缀名: .xml. 第一行必须是文档声明,即&lt;?xml version = &#39;1.0&#39; ?&gt;,顶行写,必须在第一行,不过我在谷歌浏览器,不写文档声明也没有报错,但是还是写上最好. 一个xml文档有且只有一个根标签,如例子中的&lt;users&gt;. 属性值必须使用引号引起来,单双引号都可以. 标签必须为一对,即有开始就必须有结束,如&lt;abc&gt;&lt;/abc&gt;,或者为自闭合标签,如&lt;abc/&gt;. xml标签区分大小写,如&lt;abc&gt;&lt;/ABC&gt;会报错. 快速入门:将下列例子存放在xml文本文件中再直接用浏览器打开,没报错就说明写对了 . 1234567891011&lt;?xml version = &apos;1.0&apos; ?&gt; &lt;users&gt; &lt;user id = &apos;1&apos;&gt; &lt;name&gt;fan1&lt;/name&gt; &lt;age&gt;2&lt;/age&gt; &lt;/user&gt; &lt;user id = &apos;2&apos;&gt; &lt;name&gt;fan2&lt;/name&gt; &lt;age&gt;2&lt;/age&gt; &lt;/user&gt; &lt;/users&gt; 组成部分: 文档声明 格式: &lt;?xml 属性列表 ?&gt; 注意:在&lt;?xml 属性列表 ?&gt;中,?和&lt;&gt;和xml三者之间不能有空格,有空格就会报错. 属性列表: version: 版本号,只写1.0,写1.1会出问题,它不向下兼容,没有1.2版本,而且,这个version是必须写的,不写会报错. encoding: 编码方式,告知解析引擎当前文档使用的字符集,默认是UTF-8,不写也可以,一般就写UTF-8就行,写其他的可能会出错. standalone(了解): 是否独立. 有两个值yes和no. yes表示不依赖其他文件. no表示依赖其他文件. 不过这个我们一般不管他. 指令(了解) 可以结合css使用,现在不用,现在xml只用来存储数据. 标签 标签名称是自定义的. 命名规则超链接: xml命名规则. 属性 id属性值唯一. 文本内容 CDATA区: 在该区域的数据会被原样展示,因为有的符号需要转义xml才能识别,有了这个就不需要转义了. 格式: &lt;![CDATA[语句]]&gt; 约束 谁编写xml?—用户写,即软件的使用者(就是程序猿啦) 谁解析xml?—被使用的软件(半成品软件,理解为框架),但是这里有一个问题,就是我的这个框架怎么知道程序猿写的标签是要干嘛的呢?所以这里就需要一个约束来规定一下,什么标签是用来干嘛的,这就是该软件提供的说明文档,也叫约束文档,用于说明xml文档的书写规则. 约束概念: 规定xml文档的书写规则. 作为框架的使用者(程序猿): 能够在xml中引入约束文档. 能够简单的读懂约束文档. 分类: DTD: 简单的约束技术,不过缺陷蛮多. 引入dtd文档到xml文档中 内部dtd: 将约束的规则定义到xml文档中(了解). 外部dtd: 将约束的规则定义在外部的文件中. 本地引入: &lt;!DOCTYPE 根标签 SYSTEM &quot;dtd文件的位置&quot;&gt;. 网络引入: &lt;!DOCTYPE 根标签 PUBLIC &quot;dtd文件的名字&quot; &quot;dtd文件的位置(url位置)&quot;&gt;. 缺陷: dtd中的约束为sex必须字符串,我希望的是只有男和女,但是如果xml文档中写了个不知道也是不会报错可以正常运行的,这个就不合规范比较随意,不是我们想要的. DTD工具和例子. Schema: 较复杂的约束技术,可以限制内容. Schema工具和例子. 解析: 操作xml文档,将文档中的数据读取到内存中. 操作xml文档: 解析(读取):将文档中的数据读取到内存中. 写入: 将内存中的数据保存到文档中,持久化的存储. 解析xml的方式: DOM:将标记语言文档一次性加载进内存,在内存中形成一颗DOM树结构 优点: 操作方便,可以对文档进行CRUD的所有操作. 缺点: 由于是一次加载所有的进内存,所以比较占内存. SAX:逐行读取,而且是读到下一行,上一行就释放了,所以在内存中一直都只有一行代码,同时这个是基于事件驱动的. 优点: 不占内存. 只能读取,不能增删改. xml常见解析器: JAXP(sun公司提供的):支持DOM和SAX两种思想,性能很低,不用. DOM4J:一款非常优秀的解析器,基于DOM思想. Jsoup:本来是用来解析html的,是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。 Jsoup工具. PULL:安卓操作系统内置的解析器,是SAX方式的. Jsoup解析器 快速入门: 使用步骤: 导入jar包如: jsoup-1.11.2.jar. 获取Document对象. 获取对应的标签(Element对象). 获取数据 代码: Jsoup快速入门代码. 123456789101112131415161718//获取student.xml的路径 String str = JsoupDemo.class.getClassLoader().getResource(&quot;student.xml&quot;).getPath(); //解析xml文档,加载文档进内存,获取dom树,即document对象 try &#123; Document document = Jsoup.parse(new File(str), &quot;utf-8&quot;); //获取元素对象,即element(标签)对象,Elements就是一个list列表,会存放所有name Elements elements = document.getElementsByTag(&quot;name&quot;); System.out.println(elements.size()); //获取第一个name的element对象 Element element = elements.get(0); //获取数据 String name = element.text( ); System.out.println(name); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; 对象的使用: Jsoup: 工具类, 可以解析html和xml文档,返回Document对象. 注意其中的parse()方法,用于解析html和xml文档,返回Document对象. (重点)`public static Document parse​(File in,String charsetName)`:解析html或xml文件的. public static Document parse​(String html): 解析xml或html字符串. `public static Document parse​(URL url,int timeoutMillis)`: 通过网络路径获取指定的html或xml的文档对象. Jsoup对象案例代码. Document(继承自Element): 文档对象,代表内存总的dom树. 主要用于获取Element对象(Element是Elements的父类) public Elements getElementsByTag​(String tagName): 根据标签名称获取元素对象的集合. public Elements getElementsByAttribute​(String key): 根据属性名称来获取元素对象集合. `public Elements getElementsByAttributeValue​(String key,String value)`: 根据对应的属性名和值来获取元素对象集合. public Element getElementById​(String id): 根据id值获取唯一的Element对象. document对象演示案例代码. Elements: 元素Element对象的集合,可以当作ArrayList来使用. Element: 元素对象,可以获取元素名称,属性等. 获取子元素对象 public Elements getElementsByTag​(String tagName): 根据标签名称获取元素对象的集合. public Elements getElementsByAttribute​(String key): 根据属性名称来获取元素对象集合. `public Elements getElementsByAttributeValue​(String key,String value)`: 根据对应的属性名和值来获取元素对象集合. public Element getElementById​(String id): 根据id值获取唯一的Element对象. 获取属性值 public String attr(String attributeKey): 根据属性名称(不区分大小写)获取属性值. 获取文本内容 public String text​(): 获取所有子标签的纯文本内容. public String html​(): 获取标签体的所有文本内容,包括子标签的字符串内容. Element对象案例代码. 节点对象: 上述几个对象的爹,是Document和Element的父类. 快捷查询方式: selector: 选择器,在Element类中 使用的方法: public Elements select​(String cssQuery). 语法: 参考Selector类中定义的语法. 选择器查询示例代码. XPath: XPath即为XML路径语言（XML Path Language），它是一种用来确定XML文档中某部分位置的语言,在其中xml是被用来当作节点树对待的. 使用Jsoup的XPath需要额外导入一个jar包,我放在Jsoup工具里了. 语法学习: XPath语法学习. XPath案例代码.]]></content>
      <categories>
        <category>xml</category>
      </categories>
      <tags>
        <tag>xml基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDBC-day02]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F05%2F06%2FJDBC-day02%2F</url>
    <content type="text"><![CDATA[JDBC-day02JDBC控制事务(重要): 事务: 其实是一个包含多个步骤的业务操作,如果这个业务操作被事务管理,则这多个步骤要么同时成功,要么同时失败. 事务操作: 开启事务 提交事务 回滚事务 使用Connection对象来管理事务 方法: 开启事务: setAutoCommit(boolean autoCommit): 调用该方法设置参数为false,则表示开启事务. 在执行sql前开启事务 提交事务: commit(). 当所有sql执行完成后提交事务 回滚事务: rollback(). 在catch中回滚事务,保证任何地方出现问题后都可以回滚,而且catch中抛出的异常要是Exception,保证可以捕捉所有异常. 案例-JDBC管理事务的实现: 代码: JDBC事务管理代码JDBCDemo3 数据库连接池(重要): 我们之前写的代码都是运行一次申请一次资源,资源一用完就释放,就相当于你招聘了一个服务员来给顾客服务,顾客吃完走了你就把这个服务员开除了,下次有顾客来吃饭你就再招聘一个,吃完又把这个服务员开除了,循环往复… 显然这样是不合理的,正常的情况应该是,多招聘几个服务员,当这个服务员服务完这个顾客以后,应该等着给下一位顾客服务,这个就和数据库连接池的定义是类似的. 概念: 其实就是一个容器(集合),存放数据库连接. 当系统初始化结束后,容器就被创建,容器中会申请多个数据库连接对象,当用户来访问数据库时,从容器中获取连接对象,用户访问结束后,就将数据库连接对象还给容器. 好处: 节约资源,使得资源循环利用. 用户访问高效,因为可以节省掉申请资源这些时间. 实现: 使用标准接口: javax.sql包下的DataSource接口. 方法: 获取连接: Connection getConnection(). 归还连接: Connection.close(),如果连接对象Connection是从连接池中获取的,那么调用Connection.close()方法,则不会再关闭连接了,而是去归还连接. 一般我们不去实现它,由数据库厂商实现,例如: C3P0: 数据库连接池技术(较老). Druid(德鲁伊): 数据库连接池技术(较新),由阿里巴巴提供的,用的更多. C3P0: 数据库连接池技术 使用步骤: 导入jar包(两个,还有一个是依赖包),如c3p0-0.9.5.2.jar和mchange-commons-java-0.2.12.jar,注意不要忘记导入数据库的驱动jar包,因为这个说到底还是对数据库的操作. 定义配置文件: 名称: c3p0.properties或者 c3p0-config.xml等,在c3p0 - JDBC3 Connection and Statement Pooling中能看到. 路径: 直接将文件放在src目录下即可,它会自动加载,我们一般用c3p0-config.xml这种文件. 创建核心对象: 数据库连接池对象: ComboPooledDataSource对象. 获取连接: getConnection(). 例子代码我放github了: c3p0工具jar包. c3p0测试代码. Druid(德鲁伊): 数据库连接池技术 使用步骤: 导入jar包druid-1.0.9.jar,同时也不要忘了导入数据库驱动包. 定义并加载配置文件: 是Properties形式的文件,如: druid.properties. 可以叫任意名称,可以放在任意目录下,同时也不会自动加载了(我们都放在src文件夹下面,因为放在其他地方怎么搞都加载失败). 加载配置文件,ProPerties. 获取数据库连接池对象: 通过一个工厂类来获取: DruidDataSourceFactory. 获取连接: getConnection(). 代码,超链接如下 : druid工具jar包. druid测试代码. 定义druid工具类: 定义一个类: JDBCUtils 提供静态代码块加载配置文件,初始化连接池对象. 提供方法: 获取连接方`: 通过数据库连接池获取连接. 释放资源. 获取连接池的方法. 代码超链接如下: druid工具类. druid工具类测试代码. Spring JDBC: JDBC Template(重要): Spring框架提供的对JDBC的简单封装,提供了JDBC Template 对象来简化JDBC的开发. 步骤: 导入jar包,还要导入数据库连接池的包和数据库驱动包. JDBC Template的jar包. 创建JDBC Template对象,但是这个对象创建的时候要依赖于数据源DataSource JdbcTemplate template = new JdbcTemplate(dataSource). 调用JDBC Template的方法来完成CRUD的操作. update()方法: 执行DML语句(增删改). queryForMap()方法: 查询结果将结果集封装为Map集合. 注意: 这个方法查询的结果集长度只能是一,也就是说只能查询一条数据,查询多条会报错,它会将字段名作为key,字段值作为value. queryForList()方法: 查询结果将结果集封装为List集合. 注意: 该方法是将每一条记录封装为一个Map对象,再将Map对象添加到List对象中. query()方法: 查询结果将结果集封装为JavaBean对象. query的参数: RowMapper 一般我们使用BeanPropertyRowMapper实现类,可以完成数据到JavaBean的自动封装,使用的时候,要这样用:new BeanPropertyRowMapper&lt;泛型&gt;(泛型类的字节码文件对象即类型.class). queryForObject()方法: 查询结果将结果集封装对象. 一般用于聚合函数的查询,如练习7,用法是这样的: Long count = template.queryForObject(sql, long.class);. 例子: JDBCTemplate快速入门. 练习: 针对cart数据库中的product表(只有name和product两个字段). 需求 将平板1的价格price修改为1000元. 添加一条记录. 删除刚才添加的记录. 查询id为1的记录,将其封装为Map集合. 查询所有的记录,将其封装为List集合. 查询所有的记录,将其封装为product对象的List集合. 查询总记录数. 代码: 练习代码合集.]]></content>
      <categories>
        <category>JDBC</category>
      </categories>
      <tags>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDBC-day01]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F05%2F05%2FJDBC-day01%2F</url>
    <content type="text"><![CDATA[JDBC-day01JDBC基本概念 概念: Java DataBase Connectivity 即Java数据库连接, 用java语言操作数据库. JDBC本质: 我们期望使用统一的一套java代码可以操作所有的数据库,为此,sun公司就定义了医药操作所有关系型数据库的规则(也就是接口),而其每个数据库对这个接口的实现类由该数据库公司自己实现.所以, 我们可以说JDBC的本质就是:官方(sun公司)定义的一套操作所有关系型数据库的规则,即接口.同时各个数据库厂商自己去实现这个接口,提供数据库驱动的jar包.从而我们可以使用这套接口(JDBC)编程,真正执行的代码是驱动jar包中的实现类 JDBC快速入门 步骤: 导入对应数据库的驱动jar包,要用mysql就导入mysql的. 复制jar包,到项目下(可以新建一个目录libs,jar包都放在该目录下). 将libs目录–&gt;右键–&gt;添加为库. 注册驱动,让程序知道是用哪个数据库. Class.forName(&quot;com.mysql.jdbc.Driver&quot;);. 获取数据库连接对象Connection. Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/cart&quot;, &quot;root&quot;, &quot;root&quot;);. 定义sql语句. String sql = &quot;update product set name = &#39;话说&#39; where id = 1&quot;;. 获取执行sql语句的对象 Statement. Statement state = conn.createStatement();. 执行sql语句,接收返回的结果. int count = state.executeUpdate(sql);. 处理结果. 释放资源. 对JDBC中各个接口和类详解 详解各个对象 DriverManager(类): 驱动管理对象. 功能 注册驱动,告诉我们的程序该使用哪个数据库的jar包. 使用的方法: public static void registerDriver​(Driver driver) throws SQLException. 写代码使用该方法:Class.forName(&quot;com.mysql.jdbc.Driver&quot;),通过查看Driver的源码,我们发现,在Driver类中存在静态代码块 static { try { DriverManager.registerDriver(new Driver()); } catch (SQLException var1) { throw new RuntimeException(&quot;Can&apos;t register driver!&quot;); } } * 注意:在导入mysql5的jar包以后,我们注册驱动的语句可以不用写,因为在jar包下的`META-INF`文件夹中的`services`中帮我们写了,不过我们还是建议写上,我们不知道驱动咋写的时候也可以去`META-INF`文件夹中的`services`中复制. 2. 获取数据库连接. * 使用的方法: `public static Connection getConnection​(String url, String user, String password)`. * 参数: * url:指定连接的路径 * 语法: jdbc:mysql://ip地址(或者域名,用于找到计算机):端口号(用于找到mysql软件)/数据库名称 * 例子:jdbc:mysql://localhost:3306/cart * 细节:如果连接的是本机的mysql服务器,并且mysql的默认端口是3306,则url中的`ip和端口`可以省略,所以url可以简写为:***jdbc:mysql:///数据库名称*** * user:用户名 * password:密码 * Connection(接口): 数据库连接对象 * 功能: 1. 获取执行sql语句的对象 * 方法1: `Statement createStatement()`. * 方法2: `PreparedStatement prepareStatement​(String sql)`. 2. 管理事务: * 开启事务: `void setAutoCommit​(boolean autoCommit)`,调用该方法设置参数为`false`则开启事务. * 提交事务: `void commit()`. * 回滚事务: `void rollback()`. * Statement(接口,重要): 执行静态sql语句对象 * 方法1(了解): `boolean execute​(String sql)`,返回true表示执行的是DQL语句,返回false表示执行的是DML语句. * 方法2: `int executeUpdate​(String sql)`,执行`DML语句(数据操作语言,增删改,insert,update,delete)`,`DDL语句(数据定义语言,创建/删除表和库,create,alter,drop)`. * 返回值: 表示影响的行数(针对DML语句,而对DDL永远返回0,因为它不返回任何内容). * 返回值作用: 可以通过影响的行数来判断DML语句是否执行成功,返回值&gt;0则执行成功,反之则执行失败. * 方法3: `ResultSet executeQuery（String sql）`,执行DQL语句(数据查询语言查询语句,select). * 练习,针对product表: 1. 添加一条记录:`String sql = &quot;insert into product(id,name,price) value(null , &apos;平板2&apos; , 500)&quot;,其中`product(id,name,price)`中的括号里的参数表示增加哪一个字段内容,不写就表示增加所有字段`. * 注意:这里`value`可以写成`values`,在插入一条数据时,用`values`较快,插入多行数据时,用`value`较快. 2. 删除一条记录: `String sql = &quot;delete from product where id = 2&quot;;`. 3. 修改一条记录: `String sql = &quot;update product set name = &apos;平板&apos; where id = 1&quot;;`. 4. 创建一张表: `String sql = &quot;create table student (id int, name varchar(20))&quot;;`. 5. 删除一张表: `String sql = &quot;drop table student&quot;;`. * ResultSet(接口): 结果集对象,封装查询结果. * next(): 游标向下移动一行(默认光标指向位置是表头,此时是没有数据的,向下移动一行后就有数据了),同时可以通过该方法判断是否到达最后一行末尾(即是否有数据),如果有数据,则返回true,反之则返回false. * getXxx(参数): 获取数据. * Xxx代表`数据类型`,因为它是一次获取一行当中某一列的值,不是一次获取一整行的,例如: int getInt(). * 参数有两种情况: 1. int类型: 代表列的编号,从`1`开始,不是从0开始,如:getInt(1). 2. String类型: 代表列的名称,如:getString(&quot;id&quot;). * 注意: * ResultSet的使用步骤: 1. 游标向下移动一行. 2. 判断是否有数据. 3. 获取数据. 1234567while (rs.next()) &#123; int id = rs.getInt(1); String name = rs.getString("name"); double price = rs.getDouble("price"); String data = "id = " + id + "name = " + name + "price = " + price; System.out.println(data); &#125; * 练习: * 定义一个方法,查询`db_student`数据库中`studentinfo`中的数据,并将其封装为对象,然后打印. * 思路:表其实和类的定义很类似,定义字段名,字段类型等,而表中每一行数据和一个对象类似,有表中每个字段的内容,所以我们可以把表映射成一个类,把查询的每一行数据封装成该类对象,然后用集合将所有对象都装载在一起返回. 1. 定义一个`Studentinfo`类,封装数据库中表的各个字段. 2. 定义方法 public List&lt;Studentinfo&gt; finaAll(),实现对数据库中所有数据的查询并将数据添加到list集合中. 3. 调用方法. * PreparedStatement(statement的子接口): 执行动态sql语句 1. **SQL注入问题**: 在拼接sql语句时,有一些sql的特殊关键字参与字符串的拼接,会造成一些安全性问题 * 例如: `select * from usertable where username = &apos;abc&apos; and password = &apos;a&apos; or &apos;a&apos; = &apos;a&apos;`,前面的账号密码是错的,但是这个sql语句是恒成立的,因为后面有个`or &apos;a&apos; = &apos;a&apos;`,这就会把数据库中所有数据都查出来,同时导致程序出问题. 2. 解决sql注入问题: 使用PreparedStatement对象来解决. 3. 预编译sql语句:参数使用`?`作为占位符,在执行的时候,给`?`赋值就行了,这个虽然步骤麻烦一点,但是安全一些. 4. 使用步骤: 1. 导入对应数据库的驱动jar包,要用mysql就导入mysql的.即复制jar包,到项目下(可以新建一个目录libs,jar包都放在该目录下). 2. 将libs目录--&gt;右键--&gt;添加为库. 3. 注册驱动,让程序知道是用哪个数据库. * `Class.forName(&quot;com.mysql.jdbc.Driver&quot;);`. 4. 获取数据库连接对象Connection. * `Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/cart&quot;, &quot;root&quot;, &quot;root&quot;);`. 5. 定义sql语句. * **注意**: sql的参数使用`?`作为占位符.如`String sql = &quot;update product set name = ? where id = ?&quot;;`. 6. 获取执行sql语句的对象 PreparedStatement: 方法为`PreparedStatement prepareStatement​(String sql)`. * `PreparedStatement ps = conn.prepareStatement(sql);`. 7. 给`?`赋值 * 用到PreparedStatement中的setXxx(参数1, 参数2)方法. * 其中,**参数1**表示?的位置编号,从1开始,**参数2**表示?的值. 7. 执行sql语句,接收返回的结果,在这里就不需要传递sql语句了,因为在步骤6中已经传递过了. 8. 处理结果. 9. 释放资源. 5. 改造登录例子代码:***[PrepareStatement改进登录代码](https://github.com/fanfan999/WebCodes/blob/master/JdbcDemo/fan/LoginUser_PrepareStatement.java)*** 6. 注意:我们以后使用PrepareStatement来完成增删查改的所有操作 1. 可以防止SQL注入. 2. 效率比Statement高. 抽取JDBC工具类: JDBCUtils类 目的: 简化书写 分析: 抽取注册驱动. 抽取一个方法,获取连接对象. 需求: 不想传递参数(url,user,password等),因为太麻烦,但是 又想保证工具类的通用性,即不同url,user等也可以运行. 解决办法: 使用配置文件: jdbc.properties url = user = password = 抽取释放资源. 代码:JDBC工具类及测试代码 练习: 需求: 通过键盘录入用户名和密码判断用户是否登录成功,给出提示. 步骤 创建数据库表,包括用户名和密码两个字段. 创建一个类LoginUser.java测试. 代码:用户登录测试类 需要注意的点: JAVA中两个基1的点: 在查询语句ResultSet中,参数是从1开始的. 在预编译接口PreparedStatement对象中,参数也是从1开始的. 当然,id这些基1的就不用说了,那是肯定的 上面提到的对象中,只有DriverManager是类,其它的都是接口.]]></content>
      <categories>
        <category>JDBC</category>
      </categories>
      <tags>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL学习笔记_day01]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F05%2F05%2FMySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-day01%2F</url>
    <content type="text"><![CDATA[MySQL笔记_day01数据库的基本概念 数据库的全称: DataBase 简称 : DB 什么是数据库？ 用于存储和管理数据的仓库. 数据库的特点,和存储在文件中有什么不一样呢? 持久化存储数据的,从这点来说,说白了数据库就是一个文件系统. 方便存储和管理数据. 使用统一的方式操作数据库 — SQL.MySQL数据库软件(Oracle公司的) 安装 反正我选择的是默认安装哈哈. 安装成功后,右键我的电脑,然后点击管理,点击服务和应用程序,点击服务,当看到mysql字样的时候说明安装成功了(也可以在dos窗口下输入services.nsc就可以直接跳转到服务界面了). 卸载 找到安装目录,找到my.ini文件,复制出来里面的datadir后面的路径 卸载mysql后,我们就要去通过刚才复制的路径去卸载其数据文件,就可以了. 配置 MySQL服务(service) 停止MySQL服务,在在dos窗口下输入net stop mysql SQL]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[归并排序]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F05%2F03%2F%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[归并排序 写在前面的话: 归并排序的时间复杂度为O(N*logN),额外空间复杂度为O(N). 什么是归并排序呢? 一点点专业叫法: 迭代就理解为递归,分治就理解为一分为二的过程. 举例:以[2,5,7,1,6,4]为例 首先将其一分为二,划分成两个部分,分别为[2,5,7]和[1,6,4]. 然后分别对左右两部分进行排序,得到[2,5,7]和[1,4,6]. 申请一个辅助数组,长度和原来的数组相同. 左右两个部分分别从左到右进行比较,谁小就放到辅助数组中去,例如此例中,执行顺序是这样的 先2和1比较,2大,就把1放在辅助空间中,然后左边数组下标不动,右边下标＋1. 再2和4比较,4大,就把2放进辅助空间,然后左边数组下标＋1,右边数组下标不变. ……以此类推,当一个到了末尾之后,比较停止,剩下的直接全部放到辅助数组中. 最后得到有序数组[1,2,4,5,6,7],再将其复制回原数组即可.分析其时间复杂度 这是一个递归的过程,我们可以用master公式(): T(N) = a * T(N / b) + O(N^d)来套一下. 假设数组样本量为N,划分成了两部分,所以两边的样本量是(N/2),有因为有两部分,所以为2*T(N/2). 额外空间复杂度为O(N),因为要申请一个长度为N的辅助数组. 用master公式套,可得T(N) = 2 * T(N / 2) + O(N),即a=2,b=2,d=1. 由此可知,(log(b,a)) =&gt; 1,而d == 1,所以可得归并排序的时间复杂度为`O(N^d logN) == O(Nlog(N))`. 对于额外空间复杂度,就把它当作只生成了一个最大的数组(就是初始化数组的长度),不考虑中间的就好了,所以是O(N).代码: 行数有点多,我就直接放github上了,需要的话就自己看下: 归并排序 举例: 小和问题(以[1,3,4,2,5]为例) 什么是小和问题: 就是在一个数组中,每一个数左边比当前数小的数累加起来,叫做这个数组的小和,求一个数组的小和的和. 分析: 1左边比1小的数: 没得. 3左边比3小的数: 1. 4左边比4小的数: 1,3. 2左边比2小的数: 1. 5左边比5小的数: 1,3,4,2. 所以总的小和为:1+1+3+1+1+3+4+2 = 16. 解决办法 每个数都遍历一下左边,小的数就相加,其时间复杂度为O(N^2),我们对数器就可以这么写. 用归并思想,产生小和就在合并过程中产生,但是其中有一个要注意的点: 在合并的时候,假如左边为[1,3,4],右边为[2,5]. 先1和2进行比较,发现2 &gt; 1,而此时,2右边包含2本身一共有两个元素,所以此时需要将1×2,然后在将右边的1放到辅助数组中. 再将3和2比较,发现3 &gt; 2,此时不产生小和,直接将2放入辅助数组. ……以此类推. 其实就是,合并的时候左边比右边大,就产生小和,左边比右边小就不产生小和,同时要注意右边的数比左边大的时候,要看右边较大的这个数的右边还有几个数,此时左边较小的数就要乘以几. 时间复杂度和归并排序一致,为O(N*log(N)). 代码超链接: 小和问题代码. 逆序对问题(以[1,3,4,2,5]为例) 逆序对就是指在一个数组中,左边的数比右边的数大,则这两个数构成一个逆序对,请打印所有的逆序对. 思路与小和问题相同,我就不多赘述了哈,就是在归并重组的时候找出逆序对,放在一个list中返回就可以了. 直接来代码吧哈哈.逆序对问题代码. 偶然发现的一个牛客剑指offer上的题目,就是一个归并的题目. 题目地址: 逆序对问题, 我的代码上面也有哈哈哈,大家可以参考,就是一个归并,不过多了一个取模操作而已.]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>归并排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于递归和递归时间复杂度的估算]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F05%2F02%2F%E5%85%B3%E4%BA%8E%E9%80%92%E5%BD%92%E5%92%8C%E9%80%92%E5%BD%92%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E4%BC%B0%E7%AE%97%2F</url>
    <content type="text"><![CDATA[递归两个小例子: 举例1: 在一个数组中找到最大值 我先找左边最大值和右边最大值(以下标中间为界),两者相比较,较大的就是全局最大值 我直接贴代码了哈: 12345678910111213141516//结束条件 if (L &gt;= R) &#123; return array[L]; &#125; //找到中间位置,划分为左右两边 int mid = (L + R) / 2; //左边最大值 int maxLeft = getMax(array, 0, mid); //右边最大值 int maxRight = getMax(array, mid + 1, R); //返回左右两边最大值 return Math.max(maxLeft, maxRight); 怎么理解呢? 我画了个图: 举例2:冒泡排序的递归实现: 因为冒泡排序的原理就是每一圈都让数组中的前后两个元素比较,大的放后面,小的放前面,,所以我们这里采用递归就要分为两步: 说明,这里的start第一圈就是下标0,end在第一圈就是数组长度 每一圈递归,其实就是遍历数组,让其两两比较,代码如下: 12345678if (start &lt; end - 1) &#123; if (array[start] &gt; array[start + 1]) &#123; swap(start, start + 1, array); &#125; bubbleSort(array, start + 1, end); &#125; else &#123; return; &#125; 让数组不断变成一个更小的数组(因为每一圈结束最后一个都是最大的),可以理解为递归圈数,代码如下: 1bubbleSort(array, start, end - 1); 完整代码我放github了,要的话自己可以看看:冒泡排序的递归版 这个就拿来当作理解就可以了,正式用的时候还是循环,不要用递归!不要用递归!不要用递归! 注意: 任何递归行为都可以变成非递归. 递归实际上就是在不停的压栈弹栈,很浪费空间. 循环基本都可以变递归,不过不建议使用递归,递归容易出问题,还不好理解,占用空间还多,除了代码简练一点. 递归时间复杂度怎么分析: 看这样一个用于估计递归时间复杂度一个通式(叫做master公式): T(N) = a * T(N / b) + O(N^d). 这个式子是用做第一次划分的过程的时候的,后面的划分不用管. 其中,T(N)表示样本量为N的情况下的时间复杂度,你就理解为T就是Time的缩写;a表示子过程的次数;N / b表示子过程的样本量;O(N^d)(这是N的d次方哈)表示除了调用子过程以后所需要的时间复杂度,下面我们以求最大值为例进行分析. 由于我们把整个数组划分为了左右两个部分,两边的样本量都是(N/2),所以说左边的时间复杂度就是T(N/2),而又有左右两个部分,所以一共要两个T(N/2)的时间复杂度,即2*T(N/2). 除了调用子过程意外,我们只需要对数组中元素两两比较,这个是常数级别的操作,所以最后一项O(N^d)为O(1). 从这里我们可以看出,上述求最大值的时间复杂度为T(N) = 2T(N/2) + O(1),就相当于a=2,b=2,d=0**. master的公式是有适用范围的:那就是划分子过程的时候,划分的子过程的规模必须是一样(或者差不多,多一个两个有限个的都无所谓)的,才可以用master公式. 对满足这个公式的算法有几个快捷使用公式: log(b,a) &gt; d –&gt; 复杂度为O(N^log(b,a)). log(b,a) == d –&gt; 复杂度为O(N^d * logN),(logN表示以10为底). log(b,a) &lt; d –&gt; 复杂度为O(N^d). 注意: 这里的log(b,a)都是表示以b为底,a为指数,读作以b为底的a的对数. 以1为底的任何数的对数都是0. 1的对数永远是0. 以求最大值为例进行分析: 最大值的时间复杂度为T(N) = 2*T(N/2) + O(1),就相当于a=2,b=2,d=0,所以log(b,a) == log(2,2),其值为1,是大于d=0的,所以其具体复杂度为O(N^log(b,a)) =&gt; O(N^1) == O(N).]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法中很好用的工具-对数器]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F05%2F02%2F%E5%AF%B9%E6%95%B0%E5%99%A8%2F</url>
    <content type="text"><![CDATA[对数器 当你碰到一个题,写好代码以后,你想验证是否正确,那么我们应该怎么办呢? 可以自己多举几个例子,但是自己举例子考虑得可能不够周全. 去找OJ(Online Judge在线评测),但是可能我们不知道这个题在哪个平台上有. 自己写一个对数器进行验证,说白了对数器的作用就是给定一组样本,在你的算法和对数器上跑,跑出来结果永远一样的话,那就说明算法是正确的. 对数器是什么: 说到底,对数器就是一个对应于你的算法所写的绝对正确的(或者直接调用的绝对正确的方法)方法,这个方法和你写的算法可以达到相同效果的方法,例如,你自己写的冒泡排序和java中系统给的Arrays.sort()方法.这个Arrays.sort()方法就可以作为对数器标准使用,而且,这个绝对正确的方法不需要在乎复杂度,只需要保证绝对正确就行. 对数器的使用步骤: 有一个你想要测的方法a; 实现一个绝对正确但是复杂度不好的方法b; 实现一个随机样本产生器; 实现比对的方法; 把方法a和方法b比对很对此来验证方法a是否正确; 如果有一个样本使得比对出错,打印样本,分析是哪个方法出错; 当样本数量很多时比对测试依旧正确,我们就可以确定方法a是正确的. 例子: 以冒泡排序为例 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134//自己写的冒泡排序算法 private static void bubbleSort(int[] array) &#123; //首先判断array对象是否为空 //然后判断array是否是单个元素数组 if (array == null || array.length &lt; 2) &#123; //是就直接退出 return; &#125; //控制次数(第一个~最后一个--第一个~倒数第二个--以此类推) //array.length - 1才是最后一个元素的下标,因为下标是从0开始的 for (int end = array.length - 1; end &gt; 0; end--) &#123; //j只能指向倒数第二个元素,防止越界 for (int j = 0; j &lt; end; j++) &#123; //前一个比后一个元素值大,交换位置 if (array[j] &gt; array[j + 1]) &#123; swap(j, j + 1, array); &#125; &#125; &#125; &#125; //交换位置 private static void swap(int i, int j, int[] array) &#123; int temp = array[i]; array[i] = array[j]; array[j] = temp; &#125; //for test //一个绝对正确的排序算法 public static void rightMethod(int[] array) &#123; //调用Arrays的sort()方法进行排序,这是绝对正确的 Arrays.sort(array); &#125; //for test /** * @param length 表示数组的长度 * @param maxValue 表示数组中元素的最大值 * @return 返回一个长度随机, 元素随机的数组 */ public static int[] createRandomArray(int length, int maxValue) &#123; //生成[0,length]范围的随机数使得randomArray的长度随机,因为Math.random()是不能到达右边界的,所以需要加1使它取到length这个数 int[] randomArray = new int[(int) (Math.random() * (length + 1))]; // 给随机数组赋值 for (int i = 0; i &lt; randomArray.length; i++) &#123; //因为Math.random()方法是不会产生负数的,为了更好的模拟真实情况,我们采用两个随机数相减,就有可能产生负数了 randomArray[i] = (int) ((Math.random() * (maxValue + 1)) - (Math.random() * (maxValue + 1))); &#125; return randomArray; &#125; //for test /** * 用于对比两个算法跑出来结果是否相同 * * @param array1 表示自己写的算法跑出来的结果 * @param array2 表示对数器中的算法跑出来的结果 * @return 返回true表示两者完全相同, false就打印错误样本 */ public static boolean comparator(int[] array1, int[] array2) &#123; int len = array1.length; //如果两个数组长度不相同一定不相同 if (array1.length != array2.length) &#123; return false; &#125; //一个为空一个不为空,一定不相同 if ((array1 == null &amp;&amp; array2 != null) || (array2 == null &amp;&amp; array1 != null)) &#123; return false; &#125; //遍历数组,进行比较 for (int i = 0; i &lt; len; i++) &#123; if (array1[i] != array2[i]) &#123; System.out.println(&quot;出错了!,此时自定义算法的数据为 : &quot; + Arrays.toString(array1) + &quot;, 对数器样本数据为 : &quot; + Arrays.toString(array2)); System.out.println(array1[i]); System.out.println(array2[i]); return false; &#125; &#125; return true; &#125; // for test /** * * @param array 表示要复制的样本 */ private static int[] copyArray(int[] array) &#123; int[] copyArray = new int[array.length]; for (int i = 0; i &lt; array.length; i++) &#123; copyArray[i] = array[i]; &#125; return copyArray; &#125; // for test public static void main(String[] args) &#123; int[] a = new int[0]; int[] b = null; System.out.println(a.length); System.out.println(b.length); boolean flag = true; //产生样本 for (int i = 0; i &lt; 10000; i++) &#123; int[] array = createRandomArray(10, 1000); //复制样本 int[] array2 = copyArray(array); //通过两种算法排序 bubbleSort(array); rightMethod(array2); //判断两个数组此时是否相同 flag = comparator(array,array2); //一旦有不相同,就退出循环 if (flag != true) &#123; break; &#125; &#125; System.out.println(flag == true ? &quot;恭喜你,你的算法是正确的!&quot; : &quot;继续努力!&quot;); &#125; 注意事项: 对于Math.random()和Random类不懂的话,我在网上找了一篇很详细的文章,大家可以看看,我就不自己写了,超链接 : 关于生成随机数的两个方法. 区别一下int[] a = new int[0];和int[] b = null;这两条语句,后者不是长度为0,它不赋值去调用任何东西都是报错. 代码我放我github仓库了,有需自取 : BubbleSort.java]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>对数器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[冒泡排序,选择排序,插入排序]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F04%2F29%2F%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%2C%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[冒泡排序 理解:在水里小泡泡往上面浮,大泡泡往水下沉,所以冒泡排序其实就是前一个和后一个比较,小的放前面,大的放后面. 原理:以int[] arr = {2,3,4,1,9,7,5}为例. 第一圈: 先数组中第一个元素(下标为0)和数组中第二个元素(下标为1)比较大小. arr[0] &gt; arr[1],两者交换. arr[0] &lt;= arr[1],两者不交换 然后比较数组第一个元素(下标为1)和数组第二个元素(下标为2)的大小. arr[1] &gt; arr[2],两者交换. arr[1] &lt;= arr[2],两者不交换 ……以此类推 第一圈结束后,数组中最后一个元素为当前数组最大值. 第二圈(不管第N-1个数): 先数组中第一个元素(下标为0)和数组中第二个元素(下标为1)比较大小. arr[0] &gt; arr[1],两者交换. arr[0] &lt;= arr[1],两者不交换 然后比较数组第一个元素(下标为1)和数组第二个元素(下标为2)的大小. arr[1] &gt; arr[2],两者交换. arr[1] &lt;= arr[2],两者不交换 ……以此类推 第二圈结束后,数组中倒数第二个为当前数组第二个最大值. ……以此类推,共执行N次 代码1234567891011121314151617181920212223242526272829303132333435363738394041public class BubbleSort &#123; public static void main(String[] args) &#123; int[] array = new int[]&#123;2,1,6,9,13,3,4,2&#125;; System.out.println(array.length); //排序前 System.out.println(Arrays.toString(array)); bubbleSort(array); //排序后 System.out.println(Arrays.toString(array)); &#125; private static void bubbleSort(int[] array) &#123; //首先判断array对象是否为空 //然后判断array是否是单个元素数组 if (array == null || array.length &lt; 2) &#123; //是就直接退出 return; &#125; //控制次数(第一个~最后一个--第一个~倒数第二个--以此类推) //array.length - 1才是最后一个元素的下标,因为下标是从0开始的 for (int end = array.length - 1; end &gt; 0; end--) &#123; //j只能指向倒数第二个元素,防止越界 for (int j = 0; j &lt; end; j++) &#123; //前一个比后一个元素值大,交换位置 if (array[j] &gt; array[j + 1]) &#123; swap(j, j + 1, array); &#125; &#125; &#125; &#125; //交换位置 private static void swap(int i, int j, int[] array) &#123; int temp = array[i]; array[i] = array[j]; array[j] = temp; &#125;&#125; 分析: 数组中两两交换和数组寻址都是常数时间O(1)的. 第一个for一共执行N次,第二个for一共执行N-1次,所以一共要执行N^2 + N次. 不要高阶项系数,不要低阶项,所以我们就可以评估冒泡排序的时间复杂度为O(N^2). 其空间复杂度为O(1),因为只用了一个变量没有开辟多余空间. 选择排序 理解:和冒泡排序相反,选择排序是第一个元素依次和后面的每一个元素相比,比后面的小就交换,所以结束第一圈后最小的数就放在了最前面…以此类推,就可以将数组从小到大排序好. 代码1234567891011121314151617181920212223242526272829303132333435363738public class SelectionSort &#123; public static void main(String[] args) &#123; int[] array = new int[]&#123;7, 6, 8, 9, 1, 2, 7, 6, 4&#125;; //排序前 System.out.println(Arrays.toString(array)); selectionSort(array); //排序后 System.out.println(Arrays.toString(array)); &#125; //选择排序代码 private static void selectionSort(int[] array) &#123; //首先判断数组对象是否为空以及是否为单个元素数组 if (array == null || array.length &lt; 2)&#123; return; &#125; //控制循环次数 for (int start = 0; start &lt; array.length; start++) &#123; //注意这里的i只能取到倒数第二个数,防止i+1越界 for (int i = star t; i &lt; array.length - 1; i++) &#123; //如果前一个比后面的大,就交换 if (array[start] &gt; array[i + 1]) &#123; swap(start,i + 1, array); &#125; &#125; &#125; &#125; private static void swap(int start, int i, int[] array) &#123; int temp = array[i]; array[i] = array[start]; array[start] = temp; &#125;&#125; 分析: 数组中两两交换和数组寻址都是常数时间O(1)的. 第一个for一共执行N次,第二个for一共执行N-1次,所以一共要执行N^2 + N次. 不要高阶项系数,不要低阶项,所以我们就可以评估选择排序的时间复杂度为O(N^2). 其空间复杂度为O(1),因为只用了一个变量没有开辟多余空间. 插入排序(重点) 理解:以int[] arr = {3,1,4,1,6}为例,可以理解为斗地主嘛,你手上的牌都从小到大排好序了,拿到一张新的牌可不就得和前面已经拿了的牌一个一个对比嘛,小的放前面,大的放后面,对吧? 首先,第一个位置的数(下标为0)不动,去和第二个位置的数(下标为1)比较(即拿3和1比较). 此时发现3&gt;1,所以arr[0]和arr[1]的值交换. 此时数组为[1,3,4,1,6]. 然后用第二个位置的数(下标为1)去和第三个位置的数(下标为2)比较,(即拿3和4比较) 此时发现3 &lt; 4,所以不交换. 此时数组为[1,3,4,1,6]. 然后用第三个位置的数(下标为2)去和第四个位置的数(下标为3)比较,(即拿4和1比较) 此时发现4 &gt; 1,所以4和1交换位置,得到[1,3,1,4,6]. 再将3和1比较,发现3 &gt; 1,两者交换,得到[1,1,3,4,6]. 再将1和1比较,发现1 == 1,所以不交换. …以此类推 当到数组末尾时结束,得到排序好的数组[1,1,3,4,6]. 代码12345678910111213141516171819202122232425262728293031323334353637383940public static void main(String[] args) &#123; int[] array = new int[]&#123;3, 1, 5, 2, 7, 6, 1&#125;; // 排序前 System.out.println(Arrays.toString(array)); insertionSort(array); // 排序后 System.out.println(Arrays.toString(array)); &#125; //插入排序 private static void insertionSort(int[] array) &#123; //判断数组对象是否为空和是否为单个元素数组 if (array == null || array.length &lt; 2) &#123; return; &#125; //控制开始和结束,到数组末尾就停,i表示右边第一个未排序的元素下标 for (int i = 1; i &lt; array.length; i++) &#123; // 让左边已经排好序的和右边未排序的依次比较,同时和已排序的进行比较,j表示左边已排序的最后一个元素下标 for (int j = i - 1; j &gt;= 0; j--) &#123; //大就交换 if (array[j] &gt; array[j + 1]) &#123; swap(array, j); &#125; &#125; &#125; &#125; //交换 private static void swap(int[] array, int j) &#123; int temp = array[j]; array[j] = array[j + 1]; array[j + 1] = temp; &#125;&#125; 分析: 首先数组寻址,交换位置这些时间复杂度都是O(1)这是没有问题的. 和选择排序和冒泡排序不同的点是:前两个时间复杂度一定是O(N^2),因为不管你数组有序或者无序,你都是要按照流程一个一个比较的,跟数据状况没关系的,但是插入排序不一样,插入排序和数据状况有关系,要分情况. 最好情况下的时间复杂度: 当数组本来就有序时,时间复杂度为O(N),因为没有交换,就和遍历一次数组一样. 最差情况下的时间复杂度 当数组是逆序,而我要的是正序时(比如我要的是[1,2,3,4,5],但是你给的是[5,4,3,2,1]),时间复杂度为O(N^2),每一次都要和前面所有的交换,(例如5要交换4次,4要交换3次这样子),这就形成了一个等差数列(联想到冒泡排序怎么形成等差数列的),所以评估其时间复杂度为O(N^2). 一般情况下的时间复杂度: 一般情况我们一律按照最差情况估计,所以我们一般说插入排序的时间复杂度为O(N^2).]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>冒泡排序,选择排序,插入排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于时间复杂度和额外空间复杂度]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F04%2F29%2F%E5%85%B3%E4%BA%8E%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[写在前面的话: 这里写logN就表示以2为底数,因为2为底数打不出来哈哈哈 时间复杂度 用于评价一个算法流程的好坏. 先看时间复杂度的指标(再看常数项),即(N^2)/100 + 10N + 1我们也看成时间复杂度是O(N^2),其中N就是样本量 . 然后再分析不同数据样本下的实际运行时间. 常数时间的操作: 概念:一个操作如果和数据量没有关系,每次都是固定时间内完成的操作,就叫做常数操作,例如加减乘除,位运算操作,数组寻址(就是根据下标获取数组中的元素,比如a[1])等. 时间复杂度为一个算法流程中,最差情况下常数操作数量的指标.常用O表示(读作big O),具体来说,在常数操作数量的表达式中,不要低阶项,只要高阶项,并且忽略掉高阶项的系数,剩下的部分如果记作f(N),那么时间复杂度为O(f(N)). 几个简单的理解时间复杂度的例子: 一个有序数组A,另一个无序数组B,请打印B中的所有不在A中的数,A数组长度为N,B数组长度为M. 算法流程1: 对于数组B中的每一个数,都在A中通过遍历的方式找一下. 很明显该算法的时间复杂度特别大,遍历一次代价为O(N),一共M个数,所以总的代价为O(M*N). 算法流程2: 对于数组B中的每一个数,都在A中通过二分的方式找一下. 二分搜索,比如针对一个有序(假定是从小到大)的数组,假设我要找2有没有在这个数组里. 我先找到中间位置的数,看比2大还是小. 比2大,因为是从小到大排序的,所以中间右边的数字一定比2大,我们就在左边继续划分一半一半地找,直到没有了或者找到了为止. 比2小,说明中间左边的数字一定比2小,我们就在右边继续划分一半一半地找,直到没有了或者找到了为止. 等于2,就直接返回 在这个过程中,我们数组寻址和两个数比较的过程都是常数操作时间的O(1),每次砍一半,这样下来,常数操作次数为logN(以2为底),即一个数组长度为8,最多砍3次. 由此可见,二分查找的时间复杂度为O(logN),以2为底 因此我们也可以推出,查找一次的时间复杂度为O(logN),一共有M个数,时间复杂度则为(MlogN). 算法流程3: 先把B数组排序,然后用类似外排的方式打印所有在A中出现的数. 思路就是,B排序后,两个数组同时从0位置开始,即A[i]和B[i]互相比较. 若A[i] &gt; B[i],则B[i]肯定不在A数组中,打印B[i],然后B数组下标++. 若A[i] &lt; B[i],B数组下标不动,A数组下标++. 若A[i] == B[i],A数组下标不动,B数组下标++. 针对这个流程 第1步:排序的时间复杂度,可以达到NlogN. 第2步:快排,时间复杂度为O(N + M)(N,M为A和B数组长度). 由此可见,该流程的时间复杂度为NlogN + O(N + M). 三个流程,三种时间复杂的表达…我们应该如何分析其好坏? 给长度为N的数组排序(其中寻址,比较操作都是常数级别的). 第一次从0-(N-1)中找出最小值min放在第0个位置,过N个数. 第二次从1-(N-1)中找出最小值min放在第1个位置,过N-1个数. ……以此类推. 一共需要找的次数为(N + (N-1) + ... + 2 + 1),这是一个等差数列,其和为n(n + 1) / 2(这个就可以理解为常数操作数量的表达式),再乘以一个O(1)(它是单次操作所需要的时间),即(n(n + 1) / 2) O(1). 估算其时间复杂度是这样子的: 不要低阶项,只要高阶项,并且忽略掉高阶项的系数. 由此推出上述排序算法时间复杂度为O(n^2). 额外空间复杂度 额外空间复杂度其实很好想,完成这个功能,我们额外开辟了几个新的空间,那就是几. 比如我一个循环,循环过程中我新开辟了一个长度为10的数组来存储数据,那么额外空间复杂度就是O(10) 再以冒泡排序为例,当两个数需要交换时,我们就会定义一个中间变量temp,这就是我们唯一新开辟空间的地方,这时我们就说冒泡排序的额外空间复杂度为O(1),其实,有限的几个变量(单个变量,不是数组这样子的哈)能跑完流程的话,额外空间复杂度都是O(1),不一定是一个.]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>时间复杂度,额外空间复杂度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基础加强_注解]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F04%2F29%2F%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%BC%BA-%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[本篇文章主要讲注解(Annotation)注解的基本知识 概念:和注释一样,是来说明程序的,但是这个是给计算机看的; 注释: 用文字描述程序的一段话,比如//这是一个方法,这个就是给我们程序猿看的; 关于注解的几个注意的点: JDK1.5之后的新特性 用来说明程序的 注解的格式:@注解名称 注解的作用分类: 编写文档(生成doc文档) 生成api帮助文档,也就是(doc文档),只需要文件夹中用cmd打开dos窗口,输入javadoc 类名.java就可以生成了,然后再打开index.html就可以看到我们写的注解了 直接用dos命令可能会报错或者API有乱码,因为我用的是utf-8但是系统不认识的,所以你这时候只需要用notepad++将该类的编码改成ANSI(即本地默认编码)就可以了(先复制,再粘贴,再保存后就是ANSI编码的了) 代码分析(使用反射) 编译检查(如果你重写方法改名了就会报错) JDK中预定义的一些注解: @Override : 用于检测被该注解标注的方法是否是继承自父类(接口)的,不是会报错; 例子: 1234@Overridepublic String toString()&#123; return super.toString(); &#125; @Deprecated[ˈdeprəkeɪtɪd] : 说明被该注解标注的内容已过时 @SupperessWarnings : 压制警告(黄色警告线) 一般情况下我们会写在类上,使得类中的左右黄色警告线都会没有而且参数一般传递的参数都是&quot;all&quot;; 例子: 1234@SupperessWarnings("all")public void show()&#123; System.out.println("abc");&#125; 此时比如show方法未使用这些黄色警告线都没有了 自定义注解: 格式(包括两部分): 元注解 : 用于描述注解的注解(放在注解类上面) @target : 描述注解能够作用的位置 例子 : @Target(value = {ElementType.TYPE, ElementType.METHOD, ElementType.FIELD}), 其中value还可以省略,因为只有他一个属性 ElementType(这是target的属性)取值 : TYPE : 表示只能作用在类上 METHOD : 表示只能作用于方法上 FIELD : 表示只能作用于成员变量上 @Retention : 描述注解被保留的阶段 @Retention(RetentionPolicy.RUNTIME) : 表示当前被描述的注解,会保留到class字节码文件中,并被jvm读取到(可以直接RetentionPolicy.RUNTIME这样子使用是因为RetentionPolicy是一个枚举类) @Documented : 描述注解是否被抽取到api文档中(生成api文档可以在dos窗口下使用如下命令 : javadoc Hello.java) @inherited : 描述注解是否被子类继承,使用后子类会自动继承这个注解 public @interface 注解名称(){} 例如这样子 : public @interface MyAnno{} 本质 : 注解本质就是一个接口,该接口默认继承Annotation接口(自己写一个接口MyAnno,再反编译一下就知道了) 反编译后就像这样子 : public interface MyAnnotation.MyAnno extends java.lang.annotation.Annotation { } 反编译有一个小技巧,你可以通过软件反编译,也可以通过javap HelloWorld.class这样的命令在dos窗口下反编译 注解的属性 : 即接口中定义的抽象成员方法,常量没啥用不用管 要求 属性的返回值类型(只有下列取值) : 基本数据类型 String(注意只有String,没有其它引用类型) 枚举 注解 以上类型的数组类型 例子如下 : 1234567891011121314public @interface MyAnno&#123; public abstract int show1(); public abstract String show2(); //Student为枚举类 public abstract Student show3(); //MyAnno2为注解类 public abstract MyAnno2 show4(); String[] strs();&#125; 定义了属性,在使用时需要给属性赋值,格式为 : @注解名(方法名 = 返回值类型的值)(其中返回值类型为int就是int类型,String就是String类型,当有多个值时,中间用,隔开就可以了) 例如这样 : @MyAnno(show1 = 10, show2 = &quot;fan&quot;) 但是有一个技巧,就是我们在定义属性的时候就可以给一个默认值(在属性名后面＋default＋默认初始化值),这样在使用时候就可以不给值了 例如 : String name() default &quot;fan&quot; 如果只有一个属性需要赋值,并且属性的名称为value,则value可以省略，多个参数时就必须写上属性 就像这样 : @MyAnno(10) 注意数组赋值时候,用{}包裹,如果只有一个元素的话{}可以不写 注解赋值的例子: @MyAnno(show1 = 10, show2 = &quot;fan&quot;, strs = {&quot;fan1&quot;, &quot;fan2&quot;, show3 = Student.P1}) 在程序中使用(解析)注解 即获取注解中定义的属性值,可以替代配置文件,这里用到了反射 获取注解定义的位置的对象(Class, Method, Field对象) 获取指定的注解 getAnnotation(类类型) 调用注解中的抽象方法来获取配置的属性值其实我觉得这个暂时意义不大,就懒得写了哈哈 小结 以后大多数时候,我们会使用注解,而不会自定义注解 注解给谁用? 编译器 解析程序 注解不是程序的一部分,可有可无,也可以理解为注解就是一个标签]]></content>
      <categories>
        <category>javaee</category>
      </categories>
      <tags>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Markdown图片无法显示的问题解决方法]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F04%2F28%2F%E5%85%B3%E4%BA%8EMarkdown%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E7%9A%84%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[备注: 在网上找了半天,一堆不靠谱的试了以后,终于被我试出来了哈哈哈,我可真是个小天才 步骤是这样子的 在自己的github上新建一个仓库, 怎么新建仓库大家应该都会吧,我这里就不赘述了,就像下面这样: 点开自己新建的仓库,在右边有个clone or download,复制下来地址,如图所示: 打开hexo所在文件夹,右键鼠标然后点击 Git Bash Here,然后在本机将github中的仓库克隆下来,命令是: git clone 仓库地址(地址就是你复制下来的地址),不懂就看图吧: 克隆成功后在hexo文件夹中会有一个以你的仓库名命名的文件夹,例如我的是MyPostImage,然后将图片放在该文件夹下就行; 注意: 这里有个小技巧:你可以每次要在一篇博客中添加图片时候,新建一个和本篇博客名字相同的文件夹放在MyPostImage下面,这样就比较容易整理; 你要是怕自己新建的文件夹和博客名字不一致,你可以这样子新建一篇博客文章:在bash窗口下输入命令hexo n &quot;博客名字&quot;,这样子系统就会自动在hexo &gt; source &gt; _posts路径下生成一个和本篇博客名相同的文件夹,然后将文件夹复制到MyPostImage下面就可以了. 进入MyPostImage文件夹(注意不是和博客名字相同的那个文件夹,是名字和仓库名相同的的文件夹),右键鼠标然后点击 Git Bash Here,打开Bash窗口然后输入git add .,(注意这里有一个点),然后输入命令git commit -m &quot;文件名&quot;,最后将内容推送上仓库就可以了,命令是:git push origin master; 上传成功后去自己的github仓库看看,你就会发现,产生了一个git commit -m &quot;文件名&quot;中以文件名为名字的文件夹,图片就在该文件夹中,就像这样子: 点击图片,当你看到图片以后,复制该图片的路径.就像这样: 然后打开我的新建的md文件,并且插入图片,代码是:![图片名](图片路径 &quot;图片无法显示或鼠标移上去的时候显示的文字&quot;),例子如下(这个图片是我在网上偷的啊哈哈): 但是我们预览的时候会出现一个问题,就是预览的时候图片还是显示不出来,这个时候我们改路径的一个文件名就可以了,因为github和md文件关联的图片地址是有一定格式的,格式如下: https://github.com/用户名/repository仓库名/raw/分支名master/图片文件夹名称/***.png or***.jpg 看不懂吧,其实就是将blob改成raw就行,万一还看不懂就看图: 在bash下运行博客,你会发现图片这时候就可以看到了,大功告成哈哈! 其实这里面可能还有很多技巧啥的,我暂时还不会,暂时会这个就可以了吧哈哈哈,因为反正图片不是太多,要是有啥不清楚的,随时可以通过博客联系我,在about里面可以找到我哈哈哈,最后附上一张我很喜欢的图片吧,希望各位和它一样每天都开心!]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown的基本语法]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F04%2F28%2FMarkdown%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[写在前面的话: 之前一直手抄做笔记复习,没有想着用博客,后来觉得手写太慢了,所以准备好好利用一下我的博客作为复习仓库,在这里先熟悉下Markdown语法 Markdown标题 使用#表示1-6级标题,一级对应一个#号,二级标题对应两个#号,以此类推; 其中一级标题还可以在文字下方加一行=====,这个等号几个无所谓;二级标题可以在下面加----,几个符号也是无所谓的; 注意事项: Markdown写文章时,一定要在符号后面空格一下再写文章,比如* a这样子,不然符号不会起到作用的; Markdown中可以行与行之间通过空一行来实现换行,也可以通过&lt;br&gt;来实现换行; 将文字放在可以实现高亮(不过这个不是分号,是esc键下面,tab键上面的那个按键)中间来实现高亮强调的效果; Markdown段落格式 字体 *斜体文本*和_斜体文本_都表示斜体; **粗体文本**和__粗体文本__都表示粗体;***粗斜体文本***和____粗斜体文本___都表示粗斜体文本; 分隔线 可以在一行下面用 *** 或者 --- 或者 ___ 来建立一个分隔线; 通过在文本前面添加&lt;u&gt;实现带下划线文本; 脚注 脚注是用来对文本进行补充说明的,你把鼠标移上去会有提示,格式是这样子的[^要注明的文本]; Markdown列表 无序列表 使用星号(),加号(+)或者减号(-)作为列表标记,我这里用的就是无序列表呀哈哈哈,如果要有层次感的话,就敲一个tab键再敲`,+,-`就好了,不过都要记得敲完符号了记得敲个空格哈; 例如这样子: 第1项 第1.1项 *第1.2项 第2项 第2.1项 第2.2项 第3项 第3.1项 第3.2项 有序列表 使用数字并加上.来表示; 就像这样子: 第1项 第1.1项 第2项 第2.1项 列表嵌套 列表嵌套很简单,下一行时,在前面添加四个空格就可以了; 就是这样子的: 第1项: 第1.1项 第2项 第2.2项 Markdown区块 这也是为了分层好看用的,其实和缩进也差不多了,就是用&gt;表示最外层,&gt;&gt;表示第二层,依次类推; 例子是这样的: 第1块 第1.1块 第2块 第2.2块 这个也是可以嵌套列表使用的; 例子如下: 区块中的列表 第1项 第2项 第1项 第2项 但是这里有两个要注意的地方: 就是如果要在列表中放区块,就需要在&gt;前面添加四个空格的缩进; 就像这个样子: 第一项 &gt; 我是fanfan999, 最爱lcl 使用&gt;缩进后,行与行之间必须空行,不然效果不出来; Markdown代码 这才是最重要的部分哈哈哈,不过前面都差不多提到了,那就再回顾一遍吧; 一点点代码可以用给包起来就行,例如System.out.println(&quot;fanfan999&quot;); 想要多行代码成为一块很显眼的地方,也就是高亮啦,我们可以使用在代码前一行和后一行添加三个这个`符号,在符号后面还可以备注什么语言,当然不备注也是可以的; 例子如下:123public static void main(String[] args)&#123; System.out.println("fanfan999");&#125; Markdown超链接 格式是这样子的:[要显示的文字](链接的地址); 例如我的: 我的博客; 当然也可以直接使用地址哈哈哈!不过要把网址用&lt;&gt;包起来 像这样:https://fanfan999.github.io/fanfan999.github.io/; Markdown插入图片 图片格式如下: ! [alt 图片的替代文字] (图片地址 “可选标题”),也就是一个感叹号!+一个方括号[]+一个普通括号(),其中的最后一个”可选标题”效果就是你鼠标放上去会显示的文字,可写可不写, 也可以放本地图片,语法一样的,只是地址改为本地地址就好了 这个图片嘛…emmm,我自己试了显示不出来哈哈哈哈,对不起,是我太菜了,我搞出来了再补充.]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Markdown&lt;br&gt;</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[这是我的第一篇博客了]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F04%2F12%2F%E4%BB%8E%E4%BB%8A%E5%A4%A9%E8%B5%B7%2C%2F</url>
    <content type="text"><![CDATA[从今天起, 我也是一个有博客的菜鸟了哈哈哈!用博客来记录我的复习,希望秋招能找到一个好工作吧!]]></content>
  </entry>
</search>
