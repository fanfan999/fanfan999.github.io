<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[springmvc_1]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F08%2F08%2Fspringmvc-1%2F</url>
    <content type="text"></content>
      <categories>
        <category>springmvc</category>
      </categories>
      <tags>
        <tag>springmvc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring_2]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F08%2F08%2Fspring_2%2F</url>
    <content type="text"><![CDATA[Spring Bean的作用域1. singleton: Spring的默认作用域,容器里拥有唯一的Bean实例,适合无状态的Bean.2. prototype: 针对每个getBean请求, 容器都会创建一个Bean对象,适合有状态的Bean.3. request: 会为每个Http请求创建一个Bean实例,该作用域只针对web容器有效.4. session: 会为每个session创建一个Bean实例,该作用域只针对web容器有效.5. globalSession: 会为每个全局HttpSession创建一个Bean实例,该作用域仅对Portlet这个web容器有效.Spring Bean的生命周期,这个我没怎么整明白,大家瞄一眼就好了 创建过程: 销毁过程: Spring AOP概念 软件有一个基本原则,那就是关注点分离, 即将不同的问题交给不同的部分去解决,每个部分只专注于自己的问题. 面向切面编程AOP,正好是一种体现了这种原则的技术,我们的代码主要就是用于实现某种特定的业务逻辑,但是同时我们还需要实现一些通用化功能比如事务管理,日志记录等与业务功能组合在一起. 为了将业务功能的关注点和通用化功能的关注点分离开来,就出现了AOP技术,其中通用化功能代码的实现对应的就是所谓的切面(Aspect). 业务功能代码和切面代码分开之后,架构将变得高内聚,低耦合. 代码分开的同时,我们还需要保证功能的完整性, 所以说切面最终需要被合并到业务中(即Weave 织入过程). AOP的三种织入方式 编译时织入: 即在代码编译时就把切面代码融合到业务代码中生成完整功能的java字节码文件,这样的实现需要特殊的java编译器,比如AspectJ. 类加载时织入: 即在业务逻辑的字节码加载的时候,将切面的字节码融入进去,这同样需要特殊的java编译器,比如AspectJ和AspectWerkz. 运行时织入: 即在运行时通过动态代理的方式调用切面代码增强业务功能,Spring就是采用的这种方式,虽然采用动态代理会有额外的开销,但是不需要特殊的编译器. AOP的几个名词Advice的种类AOP的实现: JdkProxy和Cglib 具体使用哪种方式生成由AopProxyFactory根据AdvisedSupport对象的配置来决定. 默认的策略: 如果目标类是接口,则使用jdk动态代理来实现,否则使用后者. jdk动态代理通过反射来接收被代理的类,同时该类必须实现InvocationHandler接口,其核心为:InvocationHandler接口和Proxy类,关于如何使用动态代理见 动态代理 这篇博客. Cglib(Code generation library,理解为代码生成类库): 它可以在运行时动态生成某个类的子类,通过修改字节码文件实现,注意它是以继承的方式动态的生成目标类的代理,如果某个类标记为final,那么无法使用Cglib做代理. JDKProxy 通过java内部反射机制来实现的,在生成类的过程中比较高效. Cglib 借助ASM实现,ASM是一种能够操纵字节码的框架,在生成类之后的执行过程中比较高效. 代理模式 代理模式的组成:接口 + 真实实现类 + 代理类其中真实实现类和代理类都是要实现前面的接口的.Spring AOP需要做的就是生成一个代理类来替换掉真实实现类以对外提供服务. Spring中的代理模式的实现 真实实现类的逻辑包含在了getBean方法里. getBean方法返回的实际上是Proxy的实例. Proxy实例是Spring采用JDK Proxy或CGLIB动态生成的.]]></content>
      <tags>
        <tag>spring_2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring_1]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F08%2F07%2Fspring_1%2F</url>
    <content type="text"><![CDATA[这篇博客写得稀烂,大家谨慎观看 你了解Spring IOC吗? IOC(Inversion Of Control): 控制反转 它是Sprig Core最核心的部分,是Spring家族的基本. IOC是指由spring来负责控制对象的生命周期和对象间的关系. IOC不能算是一种技术,应该当做一种思想. 要了解IOC,我们需要先了解一下依赖注入(Dependency Injection) DI(依赖注入) 含义: 把底层类作为参数传递给上层类,实现上层对下层的控制. 举例: 非DI思想设计行李箱由图可知,行李箱依赖于箱体,箱体依赖于底盘,底盘依赖于轮子,当一切都完工之后,突然产品经理说轮子要改大一码,那就崩了,底盘,箱体,行李箱是按照轮子来做的,轮子一改,全得改,凉凉!!! 用代码来演示上述过程中的依赖关系这就是典型的上层建筑依赖下层建筑 倘若我们想使得轮胎的尺寸可以动态改变的话,就要下面改成这样,红色的就是改动的地方,全都改了,崩了. 采用依赖注入的思想设计行李箱我们先大概整出来箱子啥样,多大尺寸.然后再去造箱体放进箱子里.然后再去造底盘放进箱子里.最后再去造轮子放进箱子里.此时要改轮子就好说了嘛这就是典型的下层建筑依赖上层建筑 IOC, DI, DL的关系 IOC可以通过DI/DL(依赖查找,已废弃)实现. 依赖注入的方式 Setter Interface Constructor Annotation 依赖倒置原则,IOC,DI,IOC容器之间的关系IOC容器的优势 避免了在各处使用new来创建类,并且可以做到统一维护,这些都交给容器解决. 创建实例的时候不需要了解其中的细节,比如上面的造行李箱的例子,我们不需要知道怎么造的,经历了哪些东西,它会直接返回给我们行李箱实例供我们使用. IOC容器的工作流程图如下:spring启动时会去读取容器中的bean配置信息,并在容器中生成一份相应的配置注册表,然后根据这张注册表去实例化bean,同时装配好bean之间的依赖关系为上层提供准备就绪的运行环境.spring提供了一个配置文件描述bean以及bean之间的配置关系,利用反射功能实例化bean并建立bean之间的关系. Spring IOC支持的功能 依赖注入 依赖检查 自动装配 支持集合 指定初始化方法和销毁方法 支持回调方法 Spring里的核心接口或者类 1. BeanDefinition接口 该接口主要是用来描述Bean的定义的,spring容器在启动的时候会将xml或者注解里bean的定义解析成spring内部的BeanDefinition对象的形式. 2. BeanDefinitionRegistry接口 - 该接口提供向IOC容器注册BeanDefinition对象的方法.3. BeanFactory接口 该接口提供了IOC的配置机制. 包含了bean的各种定义,便于实例化bean 还能在实例化bean之后建立bean之间的依赖关系. 该接口还能对bean的生命周期进行控制. 其体系结构如图: 4. ApplicationContext接口 该接口是BeanFactory的子接口之一. BeanFactory是Spring框架的基础设施,面向Spring,ApplicationContext面向使用Spring框架的开发者,如果将spring容器比作一辆汽车,BeanFactory则是发动机,而ApplicationContext则是一辆完整的汽车. 该接口继承了BeanFactory接口: 所以它可以管理,装配Bean. 该接口继承了ReasourcePatternResolver接口: 所以它可以加载资源文件. 该接口继承了MessageSource接口: 所以它可以实现国际化等功能. 该接口继承了ApplicationEventPublisher接口: 所以它可以注册监听器,实现监听机制.]]></content>
      <tags>
        <tag>spring_1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础_3]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F08%2F06%2Fjava%E5%9F%BA%E7%A1%80_3%2F</url>
    <content type="text"><![CDATA[J.U.C知识点梳理 java.util.concurrent包: 提供了并发编程的解决方案, J.U.C包里有两大核心: CAS(compare and swap)是java.util.concurrent.atomic包的基础. AQS(AbstractQueuedSynchronizer)是java.util.concurrent.locks包以及一些常用类比如ReentrantLock等类的基础. J.U.C包的分类: 线程执行器executor,即一个任务执行和调度的框架, 锁locks(ReentrantLock和synchronized一样,都是排它锁) 原子变量类atomic,指一个操作是不会中断的,具有原子操作. 并发工具类tools 并发集合collections 并发工具类: 主要包括以下四个同步器,用于协助线程的同步: 闭锁CountDownLatch: 让主线程等待一组事件发生后继续执行.其中,事件指的是CountDownLatch对象里的countDown()方法.当其他线程调用完countDown()方法后还是会继续执行的,即countDown()方法调用后不代表该子线程已经执行完毕,而是告诉主线程,你可以继续执行,我这边已经开始了,不会拖你后腿. 栅栏CyclicBarrier: 阻塞当前线程,等待其他线程等待其他线程,且会阻塞自己当前线程,所有线程必须同时到达栅栏位置后才能继续执行.所有线程到达栅栏处,可以出发执行另一个预先设置的线程. 信号量Semaphore: 控制某个资源可被同时访问的线程个数,Semaphore对象通过acquire()方法获取许可,使用结束后通过release()方法释放许可. 交换器Exchanger: 两个线程到达同步点后,相互交换数据,注意它只能用于两个线程之间. BlockingQueue接口: 它提供了可阻塞的入队和出队操作.如果队列满了,入队操作将被阻塞直到有空间可用.如果队列空了,出队操作将会被阻塞直到有队列中有线程可用. BlockingQueue中的方法:从上到下依次为: add(): 表示向队尾插入元素,插入成功返回true, 插入失败报IllegalStateException异常. offer(): 表示想队尾插入元素,插入成功返回true,插入失败返回false. put(): 表示向队尾插入元素,如果队列中没有足够空间就阻塞该线程,直到插入成功为止. offer(): 表示向队尾插入元素,如果没有足够空间,那就等待timeout时间,超时返回false,成功插入返回true. take(): 表示移除队首元素并返回,如果没有就阻塞线程直到有有线程被移除为止. poll(): 表示移除队首元素并返回,如果没有就阻塞线程,同时等待timeout时间,如果时间到之前队列中有线程,那就直接移除并返回,否则返回null. remainingCapacity(): 表示返回队列中剩余的容量. remove(Object o): 移除队列中的指定元素. contains(Object o): 判断是否队列中含有该元素,有就返回true. drainTo(): 移除所有队列中的元素到指定集合中,返回移除的元素个数. drainTo(Collection&lt;? super E&gt; c, int maxElements): 表示最多移除maxElements个元素到指定集合中. BlockingQueue的作用:主要用于生产者-消费者模式,在多线程场景时生产者线程在队列尾部添加元素,而消费者线程则在队列头部消费元素,通过这种方式能够达到将任务的生产和消费进行隔离的目的. BlockingQueue的实现类(都是线程安全的哈): ArrayBlockingQueue: 有边界的意思是它的容量是有限的,我们必须在其初始化的时候指定其容量大小并且不能改变,以先进先出的方式存储对象. LinkedBlockingQueue: 它的阻塞队列大小的配置是可选的,如果我们初始化时指定大小那它就是有边界的,反之就是没有边界的(默认大小为Integer.MAX_VALUE),以先进先出的方式存储对象. PriorityBlockingQueue: 它是带优先级的,不是先进先出的,按照优先级被移除,同时它也是无界的,但是如果为空,那么取元素的操作就会被阻塞. DelayQueue: 支持延时获取元素的无界队列,队列中的元素必须实现delay接口,在创建元素的时候可以指定多久才能从队列中获取元素. SynchronousQueue: 该队列只存储一个元素,当插入了一个元素后就会被阻塞直到元素被另一个线程消费掉. LinkedBlockingQueue: 它是2和5的合体,它是无锁操作. LinkedBlockingDeque: 就是一个双端队列啦,与线程的窃取工作相关联.]]></content>
      <tags>
        <tag>java基础_3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础_2]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F08%2F06%2Fjava%E5%9F%BA%E7%A1%80_2%2F</url>
    <content type="text"><![CDATA[集合之List和Set集合之MapHashMap hashmap是非线程安全的,所以效率比较高. Java8之前,hashmap底层是通过数组+链表实现的,如图所示:hashmap没有赋值之前,数组长度默认为16,在该数组中每个位置存储的都是链表的头结点.通过hash(key.hashCode()) % len这个函数来获得要添加的元素在数组中的存放位置. 这样子就会有一个问题,有可能大多数元素经过哈希之后都跑到了同一个位置,这就导致链表很长,查询时间从O(1) -&gt;O(n). 所以,Java8及以后,hashmap底层都是通过数组+链表+红黑树实现的.通过一个常量TREEIFY_THRESHOLD(默认为8) 来决定要不要将链表转换为红黑树.这也就意味着最坏情况下的性能可以从O(n)转换为O(logn) 通过hashmap的源码我们可以知道,其底层的数组是一个名为table的数组,在java8之前,数组的类型为entry,而在java8之后,数组的类型变成了Node`,因为引进了树嘛,哈哈不论是链表还是树,他们都是节点类型的: 数组中的每一个位置就是一个buket(可以理解为一个桶),通过哈希值决定元素应该放在哪个桶,哈希值相同的键值对以链表的形式存储. 当链表的大小超过TREEIFY_THRESHOLD时,链表就会变成红黑树,如下图: 当红黑树中的节点被删除到只有6个的时候,红黑树又会转变为链表 其中Node类的组成如图: 包括哈希值,key值,value值,以及指向下一个节点的next指针. HashMap的构造函数 无参构造调用构造函数的时候并没有做什么初始化的工作,只给了容量大小这些东西,所以我们猜他应该在首次使用之后才会初始化.—put方法通过上图我们知道,hashmap的添加方法是调用了putVal这个方法实现,其中putVal()如下:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * Implements Map.put and related methods *表示实现自Map.put以及相关方法 * @param hash hash for key * @param key the key * @param value the value to put * @param onlyIfAbsent if true, don&apos;t change existing value * @param evict if false, the table is in creation mode. * @return previous value, or null if none */ final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length;//当初始数组为空,就会调用resize()方法为其初始化. if ((p = tab[i = (n - 1) &amp; hash]) == null)//算出键值对在table里的位置 tab[i] = newNode(hash, key, value, null);//如果该位置还没有元素在里面的话就直接new一个放进去 else &#123;//如果该位置已经有元素了 Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p;//如果该键与之前在里面的键完全一样,替换原来的键 else if (p instanceof TreeNode)//如果此时是红黑树结构了,就按照树的方式去存储键值对 e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123;//如果不是红黑树 for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null);//将键值对添加到链表最后 if (binCount &gt;= TREEIFY_THRESHOLD - 1) //如果链表的长度达到了TREEIFY_THRESHOLD就要变为红黑树了 treeifyBin(tab, hash); break; &#125; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break;//如果该键对应的值本来就是这个,直接退出 p = e;//如果该键的值原来不是这个,替换掉. &#125; &#125; if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; if (++size &gt; threshold) resize();//当hashmap的元素大于阈值只有调用resize()方法扩容 afterNodeInsertion(evict); return null; &#125;对于put方法的总结:—get方法12345678910111213141516171819202122232425262728293031public V get(Object key) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value; &#125; /** * Implements Map.get and related methods * * @param hash hash for key * @param key the key * @return the node, or null if none */ final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; if ((e = first.next) != null) &#123; if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; return null; &#125;如何减少哈希碰撞 扰动函数: 促使元素位置分布均匀,减少碰撞几率. 使用final对象,并采用合适的equals()和hashCode()方法. hashmap从获取hash到散列的过程 源码:图解: hashmap的扩容问题 hashmap的扩容因子为0.75,数组初始长度为16,当数组中占用的位置到了16x0.75=12的时候,它就会对数组进行扩容,扩从为其的两倍. 多线程环境下,调整大小会存在条件竞争,容易造成死锁,比如两个线程都发现需要调整hashmap的大小了,两个线程就都会去调整其大小,这就有可能造成死锁. rehashing是一个比较耗时的过程,即每次扩容之后都要重新将数组中的键值对重新hash一遍放到新的数组里面去,这个过程比较耗时. ConcurrentHashMap 我们知道,hashmap并不是线程安全的,那么我们要使它变成线程安全的,那就需要通过Collections的synchronizedMap方法或者加synchronized关键字这样子的话,效率其实就和hashtable一样了,就没有了优越感了哈哈哈,所以为了多线程下的效率问题,java5及其之后引入了ConcurrentHashMap 如何优化Hashtable? 通过锁细粒度化,将整个锁拆解成多个锁进行优化.早期的ConcurrentHashMap:通过分段锁Segment来实现,即将锁一段一段的存储,然后给每个线程配一段锁访问该段锁对应的数据,默认分成16个segment,所以理论上它的效率是hashtable的16倍. java8之后,ConcurrentHashMap取消了分段锁机制,让table数组里的每个位置(也叫buket)都采用一把锁来管理,从而采用了CAS+synchronized使锁更细化来保证并发安全.注意: synchronized只锁住当前链表或者红黑树的头结点,这样只要哈希不冲突,就不会产生并发,效率自然就高了. ConcurrentHashMap源码 ConcurrentHashMap是在J.U.C包下的.大部分变量和hashmap是差不多的,比如初始时候的数组容量都是16,扩容因子都是0.75,链表树化的临界值都是8,而树链表化的临界值是6等. ConcurrentHashMap的put()方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public V put(K key, V value) &#123; return putVal(key, value, false); &#125; /** Implementation for put and putIfAbsent */ final V putVal(K key, V value, boolean onlyIfAbsent) &#123; if (key == null || value == null) throw new NullPointerException();//表名它不允许键值为null,和hashtable一样,hashmap键值都是可以为空的. int hash = spread(key.hashCode());//计算k的哈希值 int binCount = 0; for (Node&lt;K,V&gt;[] tab = table;;) &#123;//for循环是因为cas更新是需要不断去失败重试直到成功为止的 Node&lt;K,V&gt; f; int n, i, fh; if (tab == null || (n = tab.length) == 0) tab = initTable();//数组为空获取没有长度就给它初始化为16 else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123;//不需要初始化就去找队友的应该放在那个位置,f表示头结点 if (casTabAt(tab, i, null, new Node&lt;K,V&gt;(hash, key, value, null))) break; // no lock when adding to empty bin没有该节点就直接利用cas机制添加,添加失败就break去等着下次循环 &#125; else if ((fh = f.hash) == MOVED) tab = helpTransfer(tab, f);// else &#123;//如果发生了哈希碰撞 V oldVal = null; synchronized (f) &#123;//锁住链表或者红黑树的头结点 if (tabAt(tab, i) == f) &#123;//如果f是头结点 if (fh &gt;= 0) &#123;//如果fh(头结点的哈希值)大于0 binCount = 1;//初始化链表计数器 for (Node&lt;K,V&gt; e = f;; ++binCount) &#123;//遍历链表 K ek; if (e.hash == hash &amp;&amp; ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))) &#123;//节点存在就更新其值 oldVal = e.val; if (!onlyIfAbsent) e.val = value; break; &#125; Node&lt;K,V&gt; pred = e; if ((e = e.next) == null) &#123;//不存在就在尾部添加 pred.next = new Node&lt;K,V&gt;(hash, key, value, null); break; &#125; &#125; &#125; else if (f instanceof TreeBin) &#123;//如果头结点是红黑树的节点 Node&lt;K,V&gt; p; binCount = 2; if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key, value)) != null) &#123;//往树里添加节点 oldVal = p.val; if (!onlyIfAbsent) p.val = value; &#125; &#125; &#125; &#125; if (binCount != 0) &#123; if (binCount &gt;= TREEIFY_THRESHOLD) treeifyBin(tab, i); if (oldVal != null) return oldVal; break; &#125; &#125; &#125; addCount(1L, binCount); return null; &#125;ConcurrentHashMap总结比起Segment,锁拆的更细,直接锁的是头结点 - 首先使用无锁操作CAS插入头结点,失败就说明有其他线程在操作头结点,此时就循环重试. - 如果头结点已经存在,则尝试获取头结点的同步锁,再进行操作.HashMap,Hashtable,ConcurrentHashMap区别 HashMap的键值都是可以为null的,而其他两个键值都是不可以为null的. Hashtable(锁住整个对象)和ConcurrentHashMap(CAS+同步锁)是线程安全的,而HashMap是线程不安全的. HashMap和ConcurrentHashMap底层是数组+链表+红黑树,而Hashtable底层是数组+链表]]></content>
      <tags>
        <tag>java基础_2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础_1]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F08%2F05%2Fjava%E5%9F%BA%E7%A1%80_1%2F</url>
    <content type="text"><![CDATA[java异常java的异常处理机制主要回答了三个问题:1. What: 即异常类型,回答了什么异常类型会被抛出.2. Where: 即异常堆栈跟踪,回答了在哪儿抛出的异常.3. Why: 即异常信息,回答了为什么会抛出该异常.java的异常体系由图可知:Throwable是java异常体系的顶层父类,它有两个子类,分别是Error类和Exception类.而Exception类又包括了RuntimeException这个运行时异常和其他的编译期异常.RuntimeException: 表示运行时异常,是不可预知的,不过写程序可以自行避免,例如数组下标越界等.非RuntimeException: 可预知的,从编译器校验的异常,这也是必须处理的异常,不处理程序不执行,如IOException等.其中,可检查异常就是非运行时异常,也就是编译期异常,不能直接抛出,必须处理才能编译通过,如下图中的文件无法找到异常Error和Exception的区别 Error: 指的是程序无法处理的系统错误,编译器不做检查,一般是跟jvm相关的问题. Exception: 程序可以处理的异常,捕获后可能可以恢复程序执行. 总结: 前者是程序无法处理的错误,后者是可以处理的异常. 常见Error以及Exception RuntimeException: NullPointerException-空指针异常 ClassCastException-类型强制转换异常,比如将类A的实例对象转换为无关的类B的对象. IllegalArgumentException-传递非法参数异常,比如传递了不满足要求的参数 IndexOutOfBoundsException-下标越界异常 NumberFormatException-数字格式异常,比如将字符串a转换为int类型的数字 非RuntimeException:1. ClassNotFoundException-找不到指定class异常.2. IOException-IO操作异常.—Error:1. NoClassDefFoundError-找不到class定义异常可能是由于类依赖的class或者jar不存在.或者是类文件存在,但是存在不同的域中.也有可能是大小写问题,javac编译的时候是无视大小写的,很有可能编译出来的文件与想要的不一样.2. StackOverFlowError-栈溢出,通常是由于深递归导致的.3. OutOfMemoryError–内存溢出java的异常处理机制 首先抛出异常: 当一个方法出现错误或者异常时,系统会先创建异常对象,交由运行时系统处理. 然后捕获异常: 寻找一个合适的异常处理器处理异常,否则终止运行. java异常的处理原则]]></content>
      <tags>
        <tag>java基础_1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程面试_13]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F08%2F05%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95_13%2F</url>
    <content type="text"><![CDATA[java线程池 在web开发中,服务器需要接受并处理请求,所以会为一个请求来分配一个线程来进行处理,如果并发的请求数量非常多,但每个线程执行的时间很短,这样就会频繁的创建和销毁线程,这样会大大降低系统的效率,所以,就出现了线程池来重复利用线程. 利用位于J.U.C包下面Executors类创建不同的线程池满足不同场景的需求目前该类提供了五种不同的线程池创建方法以满足不同场景下的需求:对于第一种方式:每一个任务的执行都会去创建一个工作线程,如果线程数量达到线程初始的最大数量,则将提交的任务存入池队列中,如果有工作线程退出,将会有新的工作线程被创建以补足nThreads的数目. Fork/Join框架 该框架把大任务分隔成若干个小任务并发执行,最终汇总每个小任务结果后得到大任务结果的框架. 它是ExecutorService接口的实现. Work-Stealing算法: 某个线程从其他队列中窃取任务来执行,即Fork/Join会把不同的子任务放到不同的队列中,并为每个队列创建一个单独的线程来执行队列里的任务,那么就有可能某个队列里的线程完成任务比其他线程早,那么已完成任务的线程就去其他处于busy状态的线程中偷其等待执行的任务来执行.为什么要使用线程池 降低资源消耗,即通过重用线程来降低线程的创建和销毁带来的消耗. 提高线程的可管理性. Executor的源码解析他们的返回值都是Executor接口下的实现类或接口.Executor框架体系J.U.C的三个Executor接口1. Executor: 运行新任务的简单接口,将任务提交和任务执行细节解耦.通过其源码我们可以看到,该接口只要一个execute方法对于不同的executor接口的实现,execute方法可能有不同的执行结果,可能是创建一个新线程并立即启动,也有可能是通过线程池中已有的工作线程来运行传入的任务,也可能是根据线程池的容量或者阻塞队列的容量来决定是否要将传入的线程放入阻塞队列中或者拒绝接受传入的线程.使用Thread来创建线程并启动的伪代码如下:使用Executor来创建线程并启动的伪代码如下:2. ExecutorService: 它扩展了Executor接口,具备管理执行器和任务生命周期的方法,提交任务机制更完善3. ScheduledExecutorService: 它扩展了ExecutorService接口,支持Future和定期执行任务.ThreadPoolExecutor 大多数情况下,使用Executors类提供的五类线程池就足够了,但还是有些场景需要我们直接利用ThreadPoolExecutor类的构造函数去创建. 如图所示为应用到线程池中进行处理的流程 ThreadPoolExecutor的构造函数参数分析1. corePoolSize: 表示核心线程数量,可以大致理解为长期驻留的线程数.2. maximumPoolSize: 表示线程不够用时能够创建的最大线程数.3. workQueue: 表示任务等待队列,当任务提交时,如果线程池中的线程数量大于或等于corePoolSize的时候,它就会把该任务封装成一个Work类的对象放入到等待队列中,等待队列有很多种,所以排队等待机制也不同.4. keepAliveTime: 表示线程池维护线程所允许的空闲时间,线程池中的线程数量大于或等于corePoolSize的时候,如果这时没有新的任务提交,核心线程之外的线程不会立即被销毁,而是会等待,知道时间超过了keepAliveTime规定的时间再被销毁.5. threadFactory: 主要用来创建新线程,默认使用Executors.defaultThreadFactory()方法.6. handler: 表示线程池的饱和策略,如果阻塞队列满了并且没有空闲的线程,如果此时继续提交任务,就需要采取一种策略提交该任务.—handler的四种饱和策略 AbortPolicy: 直接抛出异常,这是默认策略. CallerRunsPolicy:用调用者所在的线程来执行任务. DiscardOldestPolicy: 丢弃队列中最靠前的任务,并执行当前任务. DiscardtPolicy:直接丢弃任务. 通过实现RejectedExecutionHandler接口自行选择handler策略. 新任务提交execute执行后的判断线程池的状态(五种) RUNNING: 能接受新提交的任务,并且也能处理阻塞队列中的任务. SHUTDOEN: 不再接受新提交的任务,但可以处理存量任务,处于running状态时调用shutdown()方法就会处于该状态. STOP: 不再接受新提交的任务,也不处理存量任务,处于shutdown状态/running状态时调用shutdownNow()就会处于该状态. TIDYING: 所有任务都已终止,此时有效的线程数为0. TERMINATED: 调用terminated()方法后处于的状态. 线程池的状态转换图 工作线程的声明周期 线程池的大小如何选定这个没有答案,按经验来哈哈哈,我也不懂,抄过来的]]></content>
      <tags>
        <tag>多线程面试_13</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程面试_12]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F08%2F05%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95_12%2F</url>
    <content type="text"><![CDATA[CAS(Compare and Swap) Java 平台中的锁包括内部锁(排它锁)（ Intrinsic Lock ）和显式锁 （ Explicit Lock ）。内部锁是通过synchronized关键字实现的；显式锁是通过java.concurrent.locks.Lock接口的实现类(如 java.concurrent.locks.ReentrantLock 类 ) 实现的。 synchronized(ReentrantLock)这种锁属于悲观锁,即它始终都觉得会发生并发冲突,所以会屏蔽一切可能打破数据完整性的操作.同时,还有一种锁叫乐观锁,即它觉得不会发生并发冲突,因此只在提交操作时检查是否违反数据完整性这些规则. 如果提交失败,它就会进行重试,乐观锁最常见的就是这里要说的CAS了. CAS是一种高效实现线程安全性的方法 CAS机制主要是发生于Java中原子操作类（JUC）的底层实现中,它就是一种底层的实现思想,我们不会去直接使用它,我们使用的都是它包装好的类. 它支持原子更新操作,适用于计数器,序列发生器(即给变量自增的工具)等场景. 它属于乐观锁,号称lock-free CAS操作失败时由开发者决定是否尝试,还是执行别的操作,由此执行失败的线程不会被阻塞挂起,只会告知你失败了. CAS一定要与volatile变量配合使用,这样才能保证线程每次拿到的变量都是主内存中最新的那个值 atomic包下的原子类就是使用的CAS机制 CAS思想 CAS的操作包含三个操作数: 内存位置(C),预期原值(A)和新值(B). 执行CAS操作的时候,将内存位置的值(即主内存的值)与预期原值进行比较,如果相匹配,那么处理器就会将该内存位置的值更新为新值,否则处理器不做任何操作. 例如:当一个线程想要修改共享变量的值,那么它首先在主内存中取出该值的副本或引用赋值给A,然后用A去参加运算,得到新值B,执行完毕需要更新共享变量的值的时候,就调用CAS方法区更新变量的值. CAS多数情况下对开发者是透明的 J.U.C的atomic包提供了常见的原子性数据类型以及引用,数组等相关原子类型的更新操作工具,是很多线程安全程序的首选. Unsafe类虽然提供了CAS服务,但因能操纵任意内存地址读写而由隐患. java9以后,可以使用Variable Handle API来替代Unsafe. CAS缺点 若循环时间长,开销会很大. 只能保证一个共享变量的原子操作. ABA问题 即如果内存地址C初次读取的值为A,并且在准备赋值的比较的时候,它的值仍然为A,此时我们就可以说它的值没有被其他线程改变过了吗?他有可能被改变成了B然后又改变回了A. 但是CAS却会认为他没有被改变过. 解决方法: 它提供了一个带有标记的原子引用类AtomicStampedReference,它可以通过控制变量值的版本来保证CAS的正确性.]]></content>
      <tags>
        <tag>多线程面试_12</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程面试_11]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F08%2F04%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95_11%2F</url>
    <content type="text"><![CDATA[java内存模型JMM java内存模型(Java Memory Model,简称JMM) 本身是一种抽象的概念,并不真实存在,它描述的是一组规范或规则,通过这组规范定义了程序中各个变量(包括实例字段,静态字段和构成数组对象的元素的访问方式). 同时我们知道,jvm运行程序的实体是线程,而每个线程创建时jvm都会为其创建一个工作内存(包括堆栈寄存器,程序计数器,线程控制块)用于存储其私有的数据. java内存模型中规定,所有变量都存储在主内存中,主内存是共享内存区域,所有线程都可以访问,但线程对变量的操作,比如读取,赋值等必须在自己的工作内存中进行.对变量的操作步骤:首先,将变量从主内存拷贝到自己的工作内存中去;然后在自己的工作内存中对变量进行操作,操作完成后,再将变量写回主内存.注意:1. 不能直接操作主内存中的变量,每个线程的工作内存存储的时主内存中变量的副本拷贝.2. 工作内存时每个线程的私有区域,因此不同的线程之间无法访问对方的工作内存,线程间的通信(传值)必须通过主内存来完成.JMM的主内存 主内存中主要存储的是java实例对象,所有线程创建的对象都存放在这里. 主内存里还包括了成员变量,类信息,常量,静态变量等. 主内存属于数据共享的区域,所以多线程并发操作时会引发线程安全问题. JMM的工作内存 工作内存主要存储当前方法的所有本地变量信息,每个线程只能访问自己的工作内存,所以说本地变量对其他线程不可见. 工作内存中还有字节码行号指示器,native方法信息 工作内存属于线程私有数据区域,不存在线程安全问题. JMM与java内存区域 JMM与java内存区域划分是不同的概念层次java内存区域就可以直接理解为jvm运行时数据区 JMM描述的是一组规则,通过这组规则控制程序中各个变量在共享数据区和私有数据区的访问方式,围绕原子性,有序性,可见性展开. 两者的相似点: 都存在共享数据区域和私有数据区域,在JMM中主内存属于共享数据区域,从某种程度上讲,它包含了堆和方法区,而工作内存包含了虚拟机栈,本地房发展,程序计数器. 主内存与工作内存的数据存储类型以及操作方式归纳 方法里的8种基本数据类型本地变量将直接存储在工作内存的栈帧结构中. 如果方法中的本地变量是引用类型的,那么引用变量存储在工作内存的栈帧中中,实例对象存储在主内存中,所以实例对象可以被多线程共享,假设两个线程同时调用了同一个对象的同一个方法,那么两个线程都会将要操作的数据拷贝一份到自己的工作内存中. 成员变量,static变量,类信息均会被存储在主内存中. 主内存共享的方式是线程个拷贝一份数据到各自的工作内存,操作完成后刷新回主内存. JMM如何解决可见性问题总的来说:就是把数据从内存加载到缓存,寄存器,然后运算结束再写回主内存.在执行程序的时候,为了提高性能,处理器和编译器常常会对指令进行重排序,但是重排序不是随意的,有一定的条件:1. 在单线程环境下不能改变程序运行的结果.2. 存在数据依赖关系的不允许重排序.总结来说:就是无法通过happens-before原则推导出来的,才能进行指令重排序JMM内部解决可见性的实现通常是依赖于内存屏障,通过禁止某些重排序的方式提供内存可见性保证,也就是实现了各种happends-before原则,与此同时,更多的复杂度在于需要尽量各种编译器和处理器能够提供一致的行为.happends-before原则 该原则是判断数据是否存在竞争,线程是否安全的关键. 通过这个原则我们就可以解决在并发环境下,两个操作存在冲突的问题. 如果A操作的结果需要对B操作可见,则A与B必须存在happens-before关系. 案例:假设线程A的操作就是令i=1,且线程A它happens-before线程B的操作j=1,即线程B要依赖于线程A对j赋值,线程A先于线程B发生.所以我们可以确定,线程B执行后,j=1一定是正确 的.如果他们不存在happends-before原则,那么j=1就不一定成立. happends-before的八大原则—happends-before概念: 如果两个操作不满足上述任何一个happends-before规则,那么这两个操作就没有顺序的保障,jvm可以对这两个操作进行重排序. 如果操作A happends-before 操作B,那么操作A在内存上所做的操作对操作B都是可见的. 例子: 假设线程A执行write操作,线程B执行read操作.他们不满足happends-before原则当中的任何一个,所以这段代码不是线程安全的,read的结果也是不确定的. 解决方法是给value加volatile关键字修饰或者给方法加synchronized关键字修饰 volatile关键字 volatile关键字: 它是jvm提供的轻量级同步机制. 它有如下两个作用: 保证被volatile修饰的共享变量对所有线程总是可见的,即当一个线程对volatile修饰的变量修改了其值的时候,其他线程立刻就会知道. 禁止指令重排序优化. volatile的可见性被volatile修饰的变量对所有线程都是立即可见的,对volatile变量的所有写操作总是能立即反映到其他线程中.但是, 对于volatile变量运算操作在多线程环境中并不保证安全性.例子:上述代码如果多条线程同时调用就会出现问题.要修改该问题,就需要在方法前加上synchronized修饰.这样子就不会有线程安全问题了.synchronized还会创建内存屏障,内存屏障指令保证所有变量的执行结果都会直接刷新到主存中,从而保证了操作的内存可见性,同时也使得先获取该锁的线程的操作都happends-before后获取该锁的线程的操作所以说,synchronized除了具备可重入性,还具备原子性,可见性,有序性.volatile变量是如何做到对其他线程立即可见的? 当写一个volatile变量时,JMM会把该线程对应的工作内存中的共享变量值刷新到主内存中.当读取一个volatile变量时,JMM会把该线程对应的工作内存置为无效,那么该线程只能从主内存中读取该变量的值. volatile如何禁止重排优化? 先看看什么是-内存屏障内存屏障是一个CPU指令,它的作用有两个:1. 保证特定操作的执行顺序由于编译器和处理器都能执行指令的重排优化,如果在指令之间插入一个内存屏障,那么编译器或处理器就知道了这个不能重排序.即通过插入内存屏障指令禁止对内存屏障前后的指令执行重排序优化.2. 保证某些变量的内存可见性,volatile就是通过这个特性实现的可见性.强制刷出各种CPU缓存数据,因此任何CPU上的线程都能读取到这些数据的最新版本volatile就是通过内存屏障实现的可见性和禁止重排序优化线程安全的单例模式 有问题的版本:如图所示: 当重排序后,如果在还没有初始化之前另一个线程来了,发现instance不为空,直接返回,此时instance还没有初始化,所以就会报错. 更改后是这样的:使用volatile禁止重排序就好了 volatile和synchronized的区别]]></content>
      <tags>
        <tag>多线程面试_11</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程面试_10]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F08%2F04%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95_10%2F</url>
    <content type="text"><![CDATA[ReentrantLock这个东西,emm,我没怎么整明白,所以就没怎么写 ReentrantLock(再入锁)java5之前,synchronized是仅有的同步手段,java5开始就提供了ReentrantLock,其语义与synchronized基本相同 - 它位于java.util.concurrent.locks包下 - 和CountDownLatch,Future,Semaphore一样,基于AQS(AbstractQueuedSynchronizer抽象队列同步器)中的代码来实现的. - 能够实现比synchronized无法做到的细节控制,比如控制fairness公平性. - 注意调用lock()加锁之后,必须显式调用unlock()释放锁,否则当前线程就会一直占用该锁而不去释放. - 性能未必比synchronized高,并且也是可重入的.ReentrantLock公平性的设置 我们可以在创建锁的时候选择是否使用公平锁:1234---创建公平锁ReentrantLock lock = new ReentrantLock(true);---创建不公平锁ReentrantLock lock = new ReentrantLock(); 当构造函数参数为true(即创建的是公平锁时),会倾向于将锁赋予等待时间最久的线程,可以有效减少线程饥饿(线程长期等待无法获取锁) 的情况. 公平锁的含义: 获取锁的顺序按先后调用lock方法的顺序以及多个线程获取锁的概率是一样的. 非公平锁含义: 每个线程抢占锁的顺序不一定,谁运气好谁就获取到锁,和调用lock方法的先后顺序无关. synchronized是非公平锁. ReentrantLock操作的的内容最好都用try-catch包裹起来,最后通过finally去释放资源. 案例:1234567891011121314151617181920212223242526272829303132333435363738394041424344---公平锁public class ReentrantLockTest implements Runnable &#123; //创建公平锁实例 private static ReentrantLock lock = new ReentrantLock(true); @Override public void run() &#123; while (true) &#123; try &#123; //尝试去获取锁 lock.lock(); //获取到之后就打印 System.out.println(Thread.currentThread().getName() + &quot;get lock&quot;); Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;finally &#123; //释放锁 lock.unlock(); &#125; &#125; &#125; //让两个线程循环的去获得锁 //由于是公平锁,所以两个获取锁的概率是一样的 public static void main(String[] args) &#123; ReentrantLockTest rlt = new ReentrantLockTest(); Thread t1 = new Thread(rlt); Thread t2 = new Thread(rlt); t1.start(); t2.start(); &#125;&#125;---打印结果Thread-0get lockThread-1get lockThread-0get lockThread-1get lockThread-0get lockThread-1get lock---非公平锁我们将上面的true去掉就可以了,我们很容易发现他们就不是公平的了,比如可能线程1一直获得锁. ReentrantLock将锁对象化 ReentrantLock相比于synchronized的,前者可以像普通对象一样使用,就像上面的例子一样,所以可以利用它来提供很多便利的方法甚至是synchronized没办法做到的,比如: 通过ReentrantLock可以判断是否有线程或者某个特定的线程在排队等待获取锁. 通过ReentrantLock可以带超时的获取锁的尝试,即在我们尝试获取锁超过几秒之后就会放弃获取锁的尝试,直接跑到锁池里等. 通过ReentrantLock可以感知到有没有成功获取锁. ReentrantLock是否能将wait/notify/notifyAll对象化呢? 可以 位于java.util.concurrent.locks包下面的Condition接口结合ArrAyBlockingQueue类做到了这点. ReentrantLock和synchronized的区别 synchronized是关键字,ReentrantLock是类. ReentrantLock可以对获取锁的时间进行设置,避免死锁,synchronized不可以. ReentrantLock可以获取各种锁的信息,synchronized不可以. ReentrantLock可以灵活的实现多路通知,synchronized不可以. 二者的锁机制也不一样:synchronized操作的是对象头中的Mark Word,ReentrantLock底层调用Unsafe类的park()方法加锁.]]></content>
      <tags>
        <tag>多线程面试_10</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程面试_9]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F08%2F04%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95_9%2F</url>
    <content type="text"><![CDATA[synchronized同步锁的四种状态1. 无锁: 就是没有加入锁嘛,这个就很好理解了,也就是说此时的目标共享数据没有被任何一个线程占用.2. 偏向锁3. 轻量级锁4. 重量级锁锁膨胀方向: 无锁–&gt;偏向锁–&gt;轻量级锁–&gt;重量级锁偏向锁 大多数情况下,锁不存在多线程竞争,总是由同一线程多次获得,因此,为了减少同一线程获取锁的代价而引入了偏向锁. 核心思想:如果一个线程获得了锁,那么锁就进入偏向模式,此时Mark Word的结构也变为了偏向结构,当该线程再次请求锁时,无需再做任何同步操作,即获取锁的过程只需要检查Mark Word的锁标记为偏向锁及当前线程Id等于Mark Word的ThreadId即可,这样就省去了大量有关锁申请的操作,即使得线程进入和退出同步块时不需要进行CAS操作来加锁和解锁,从而也就提高了程序的性能. 不适合用于锁竞争比较激烈的场合,当偏向锁失败后,会立即升级为轻量级锁. 轻量级锁 轻量级锁是由偏向锁升级而来的,偏向锁运行在只有一个线程申请进入同步块的情况下,当第二个线程加入锁竞争的时候,偏向锁就会升级为轻量级锁. 偏向锁的适用场景: 线程交替执行同步块. 如果存在同一时间访问多个线程同一锁的情况,就hi导致轻量级锁膨胀为重量级锁. 轻量级锁的加锁过程: 轻量级锁的解锁过程: 锁的内存语义 当线程释放锁时,java内存模型会把该线程对应的本地内存中的共享变量刷新到主内存中.而当线程获取到锁时,java内存模型会把该线程对应的本地内存置为无效,从而使得监视器保护的临界区代码必须从主内存中读取共享变量. 锁的总结]]></content>
      <tags>
        <tag>多线程面试_9</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程面试_8]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F08%2F04%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95_8%2F</url>
    <content type="text"><![CDATA[synchronized的底层实现原理 实现synchronoized的基础 java对象头 Monitor hotspot环境下对象在内存中的布局 主要分为三块区域: 对象头 实例数据 对齐填充 对象头 synchronized使用的锁对象都是存储在对象头里的. 对象头的结构由图可知:1. Class Metadata Address是对象指向其的类元数据的指针,JVM通过这个指针来确定该对象是哪个类的实例.2. Mark Word用于存储对象自身的运行时数据,这是重点,对于轻量级锁和偏向锁有关键性的作用.—Mark Word 对象头的信息是与对象自身定义的数据没有关系的额外存储成本,考虑到jvm的空间效率,Mark Word被设计成一个非固定的数据结构以便存储更多有效的数据.其中的重量级锁便是synchronized的对象锁. Monitor 每个java对象天生自带一把看不见的锁(Monitor锁,可以认为它就是一个锁对象) 结合上图: Mark Word中指向重量级锁的指针 指向的便是Monitor锁对象的地址.每个对象都存在着一个monitor与之关联.Monitor对象存在于每个java对象的对象头中,synchronized便是通过这种方式去获取锁的.这就说明为什么java对象都可以作为锁 Monitor锁的竞争,获取和释放一个概念: 什么是重入: 从互斥锁的设计上来说,当一个线程试图操作一个由其他线程持有的对象锁的临界资源时,将会处于阻塞状态,但 当一个线程再次请求自己持有对象锁的临界资源时,这种情况属于重入,重入请求是会成功的,即synchronized是具有可重入性的. 因此,在一个线程调用synchronized方法的同时,在其方法体内部再去调用该锁对象的另一个synchronized方法是可以成功的. 为什么很多时候会对synchronized嗤之以鼻1. 在java早期版本中,synchronized属于重量级锁,效率很低,因为Monitor锁是依赖于底层操作系统的Mytex Lock实现的.2. 操作系统线程之间的切换需要从用户态转换到核心态,开销较大.java6以后,synchronized性能得到了很大的提升. 下面这些技术都是为了实现线程之间更高效的共享数据以及解决竞争问题,从而程序的执行效率: 自适应自旋锁 锁消除 锁粗化 轻量级锁 偏向锁…等等 自旋锁与自适应自旋锁 自旋锁 产生原因: 在许多情况下,共享数据的锁定状态持续时间较短,切换线程划不来,可以让要获取该资源的另一个线程等一小会,但是不放弃CPU的执行时间,这个等一会但不放弃CPU执行时间的行为就是**自旋**. 实现方法: 通过让线程执行忙循环(可以联想为while(true)这样子) 来等待锁的释放,但是期间不让出CPU(即不像sleep一样放弃CPU的执行时间). 本质上自旋锁和阻塞不一样,如果锁被占用的时间很短的话,那么自旋锁的效率会很高,但是如果锁被其他线程占用的时间太长,会带来许多性能上的开销,因为线程自旋时始终会占用CPU的时时间片,自旋时间太长线程会白白浪费CPU的资源,因此自旋的等待时间应该有一定的限度,如果自旋超过了一定尝试次数,那就应该把这个线程扔到锁池里去,用户可以通过PreBolckSpin这个参数来修改自旋次数. 由于每次线程使用锁的时间和等待的时间是不固定的,所以自旋锁的次数很难设计的比较合理,那咋整啊?用更聪明的锁—自适应自旋锁 自适应自旋锁 从java6开始引进. 自适应自旋锁的自旋次数不再固定,由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定. 如果在同一个锁对象上刚刚自旋成功获取锁的线程正在运行中,那么jvm就会认为该锁通过自旋获取锁的可能性很大,那么就会自动增加等待时机(即自旋次数,例如增加到50次).相反的,如果对于某个锁,自旋很少成功获取到锁,那么之后在获取这个锁的时候就会减少等待时间甚至不自旋了,直接扔锁池里面去. 这样子之后,jvm对锁的自旋次数的预测就会越来越精准. 锁消除它是对锁进行优化的另一种方式,这种优化更彻底. - 它会在JIT编译时,对运行的上下文进行扫描,取出不可能竞争的锁.锁消除例子:JIT编译指的时即时编译,如图所示:锁粗化 一般我们都是通过希望缩小锁的范围来加快执行速度,但是当有重复操作的时候,不断的加锁释放锁会减缓程序的执行效率,所以就有了锁粗化这个概念 通过扩大加锁的范围,避免反复加锁和解锁. 例子:上述例子中append方法的反复执行,由于StringBuffer的append方法是synchronized修饰的,所以是线程安全的,反复执行append,不断的加锁释放锁会使得执行效率较低,所以jvm采用锁粗化方式来讲锁的范围放到循环执行的整个过程.]]></content>
      <tags>
        <tag>多线程面试_8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程面试_7]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F08%2F03%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95_7%2F</url>
    <content type="text"><![CDATA[线程状态及状态之间的转换如图:—线程安全问题 主要诱因: 存在共享数据(也叫临界资源). 存在多条线程共同操作这些共享数据. 解决办法: 同一时刻有且仅有一个线程在操作共享数据,其他线程必须等到该线程处理完数据后再对共享数据进行操作.此时便有了互斥锁. 互斥锁 该锁能达到互斥访问的目的,即当一个共享数据被当前正在操作的线程加上互斥锁之后,在同一时刻,其他线程只能处于等待的状态,直到当前线程处理完释放该锁之后才有可能获得操作该共享数据的权利. 互斥锁的特性 互斥性: 即在同一时间内只允许一个线程持有某个对象锁,通过这种特性来实现多线程的协调机制,这样在同一时间只有一个线程对需要同步的代码块进行访问,互斥性也称为操作的原子性. 可见性: 必须确保锁在释放之前,对共享变量所做的修改,对于随后获取该锁的另一个线程是可见的(即在获得锁时应获得最新的共享变量的值),否则另一个线程可能是本地缓存的某个副本上继续操作,从而引起不一致. synchronized关键字恰好满足了上面互斥锁的特性要求. synchronized synchronized锁的不是代码,锁的都是对象.对象锁和类锁是互不干扰的. 根据获取的锁的分类:1. 获取对象锁.2. 获取类锁. 获取对象锁的两种方法 同步代码块(synchronized(this), synchronized(类实例对象)),其中的对象锁就是小括号里的 实例对象,在获取了这些对象锁之后我们再去执行花括号的内容. 同步非静态方法(synchronized method),也就是以synchronized作为前缀的方法,此时对象锁就是当前对象的实例对象. 获取类锁的两种方法 同步代码块(synchronized(类.class)),其中锁就是小括号中的类的对象(Class对象). 同步静态方法(synchronized static method),其中锁是当前对象的类对象(Class对象). 对象锁和类锁的总结:]]></content>
      <tags>
        <tag>多线程面试_7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程面试_6]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F08%2F03%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95_6%2F</url>
    <content type="text"><![CDATA[Object的notify和notifyAll方法 我们除了给线程设置等待时间让系统自动唤醒线程外,我们还可以通过notify或者notifyAll手动唤醒线程. 案例演示:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class WaitSleepTest &#123; public static void main(String[] args) &#123; final Object lock = new Object(); //通过wait执行等待 new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;threadA is waiting to get lock...&quot;); synchronized (lock) &#123; try &#123; System.out.println(&quot;ThreadA get lock.&quot;); Thread.sleep(20); System.out.println(&quot;threadA do wait method&quot;); //让线程A无限期等待 lock.wait(); System.out.println(&quot;threadA is done&quot;); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;).start(); //由于哪个线程先执行是不一定的,所以我们在这里让主线程休眠一会,等一会再让主线程去启动第二个线程 try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //通过sleep执行等待 new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;threadB is waiting to get lock...&quot;); synchronized (lock) &#123; try &#123; System.out.println(&quot;ThreadB get lock.&quot;); System.out.println(&quot;threadB is sleeping 10 ms&quot;); Thread.sleep(10); System.out.println(&quot;threadB is done&quot;); //线程B执行结束后手动唤醒线程A lock.notify(); //这个效果也一样lock.notifyAll(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;).start(); &#125;&#125;---运行结果threadA is waiting to get lock...ThreadA get lock.threadB is waiting to get lock...threadA do wait methodThreadB get lock.threadB is sleeping 10 msthreadB is donethreadA is done如果没有手动唤醒线程A,那么服务器将一直处于启动状态,最后一句话也不会打印出来.—两个概念 对于jvm中运行程序的每个对象都有这两个池 锁池EntryList 等待池WaitList 锁池EntryList我们上面的案例的代码中就是线程A拥有了lock对象的锁,在线程A没有进去wait()方法释放锁之前,线程B就只能去线程池中等着.—等待池WaitList就是我们上面的例子中线程A调用了wait方法后他就去了等待池,然后线程B就可以占有lock的锁并执行synchronized方法了,并且,只有当线程B执行完方法或者抛出异常之后才会释放锁.—notify和notifyAll方法的区别1. notifyAll会让所有处于等待池的线程全部进入锁池去竞争获取锁的机会,而且在此之后没有获取到锁就会被放到在锁池中等待其他机会去获取锁,不会主动回到等待池了(不过可以通过wait()方法回去哈哈哈).2. notify只会随机选取一个处于等待池中的线程进入锁池去竞争获取锁的机会.—Thread类中的yield 通过看源码知道,这是一个native方法. 概念:当调用Thread.yield()方法时,会给线程调度器一个 当前线程愿意让出CPU使用权的暗示,但是线程调度器可能会忽略这个暗示.注意: yield()方法不会对锁的行为造成影响.案例:123456789101112131415161718192021222324252627282930313233343536373839404142434445public class YieldTest &#123; public static void main(String[] args) &#123; Runnable yieldTask = new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println(Thread.currentThread().getName() + i); //当i为5时,该线程表示愿意让出CPU使用权,线程调度器可能用也可能不用这个暗示 //如果用了,那么i=5时就会暂停该线程去执行另一个线程,如果不用,两个就抢吧就 if (i == 5) &#123; Thread.yield(); &#125; &#125; &#125; &#125;; Thread t1 = new Thread(yieldTask,&quot;A&quot;); Thread t2 = new Thread(yieldTask,&quot;B&quot;); t1.start(); t2.start(); &#125;&#125;---运行结果:这是不一定的,因为调度器不一定用,所以这只是参考的一部分结果A0A1A2A3A4A5A6A7A8A9B0B1B2B3B4B5B6B7B8B9如何中断线程 目前使用的方法: 调用interrupt()方法,通知线程应该中断了,但是具体要不要中断线程需要由被通知的线程自己决定. 如果线程处于阻塞状态,那么线程将立即退出被阻塞状态,并抛出一个InterruptedException异常. 如果线程处于正常活动状态, 那么会将该线程的中断标志设置为true,被设置中断标志的线程将继续正常进行,不受影响. 由上面我们可以知道,interrupt并不会去中断线程,它和yield一样,只是作为一个hint使用. 需要被调用的线程自己配合中断 即一个线程如果有被中断的需求,那就可以通过interrupt这种方法. 在正常运行任务中,经常检查本线程的中断标志位,如果被设置了中断标志就自行停止线程. 也可以在阻塞的线程抛出异常后,捕获异常后就停止该线程(退出run方法就可以了). 如果线程处于正常活动状态, 那么会将该线程的中断标志设置为true,被设置中断标志的线程将继续正常进行,不受影响.]]></content>
      <tags>
        <tag>多线程面试_6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程面试_5]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F08%2F03%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95_5%2F</url>
    <content type="text"><![CDATA[sleep和wait的区别 sleep()是Thread类的方法,而wait是Object类中定义的方法. sleep()方法在任何地方都可以使用,而wait方法只能在synchronized(用于加锁)方法或者synchronized块中使用. Thread.sleep()只会让出cpu,不会导致锁行为的改变(可以理解为不会让资源),即如果当前线程是拥有锁的,那么该线程对象调用sleep()方法不会释放锁,只会让出CPU给其他任务执行,但是该线程所占有的资源其他线程依旧是无法访问的. Object.wait()不仅会让出CPU,还会释放已经占有的同步资源锁,即其他等待该资源的线程此时也是可以获取该资源来运行的,同时这也说明了为什么wait()方法要放在synchronized方法或者synchronized块中,因为我只能获取到了锁才可以释放锁嘛哈哈哈.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class WaitSleepTest &#123; public static void main(String[] args) &#123; final Object lock = new Object(); //通过wait执行等待 new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;threadA is waiting to get lock...&quot;); synchronized (lock) &#123; try &#123; System.out.println(&quot;ThreadA get lock.&quot;); Thread.sleep(20); System.out.println(&quot;threadA do wait method&quot;); lock.wait(1000); System.out.println(&quot;threadA is done&quot;); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;).start(); //由于哪个线程先执行是不一定的,所以我们在这里让主线程休眠一会,等一会再让主线程去启动第二个线程 try &#123; //由于只等待了10毫秒,所以在线程Asleep的过程中线程B就启动了 //因为sleep不会让资源,所以此时线程B只能处于等待状态 //当线程A进入wait方法后,他会让时间和资源,所以线程B就会一直跑完,然后Await时间结束后自动跑完 Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //通过sleep执行等待 new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;threadB is waiting to get lock...&quot;); synchronized (lock) &#123; try &#123; System.out.println(&quot;ThreadB get lock.&quot;); System.out.println(&quot;threadB is sleeping 10 ms&quot;); Thread.sleep(10); System.out.println(&quot;threadB is done&quot;); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;).start(); &#125;&#125;---运行结果threadA is waiting to get lock...ThreadA get lock.threadB is waiting to get lock...threadA do wait methodThreadB get lock.threadB is sleeping 10 msthreadB is donethreadA is done]]></content>
      <tags>
        <tag>多线程面试_5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程面试_4]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F08%2F03%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95_4%2F</url>
    <content type="text"><![CDATA[线程的状态 从Thread的源码里我们可以看到线程的状态一共有如下六种: 新建(New): 线程创建后尚未启动的线程的状态,即new了一个线程对象但是还没有调用start()方法时处于的状态. 运行Runnable: 即线程对象调用了start()方法后的线程所处的状态,包含Running和Ready两个子状态,即处在此状态的线程,有可能正在执行,也有可能正在等待CPU为它分配执行时间,处于Running状态的线程位于可运行线程之中,等待被线程调度选中,获取CPU的使用权,处于Ready状态的线程,位于线程池中,等待被线程调度选中,获取CPU的使用权,Ready状态的线程获取CPU使用权之后就变成了Running状态. 无限期等待WAITING:处于该状态的线程不会被分配CPU执行时间,需要被其他线程显式地被唤醒,以下方法会让线程陷入此状态: 没有设置Timeout参数的Object.wait() 方法. 没有设置Timeout参数的Thread.join() 方法. LockSupport.park() 方法,其中LockSupport是一个工具类. 限期等待TIMED_WAITING: 处于该状态的线程不会被分配CPU执行时间,但是在一定时间后会由系统自动唤醒,主要有以下方法可以使线程处于该状态: 设置了Timeout参数的Object.wait() 方法. 设置了Timeout参数的Thread.join() 方法. LockSupport.parkNanos() 方法. LockSupport.parkUntil() 方法. Thread.sleep() 方法. 这些方法都是要通过线程对象(new出来的或者Thread.currentThread得到的)去调用的哈. 阻塞(BLOCKED): 等待获取排它锁(其他线程释放了它就去获取),在程序等待进入同步区域(例如进入synchronized修饰的方法或者代码块)的时候,除了正在执行的线程外,其他线程都会被阻塞. 结束TERMINATED: 已终止线程的状态,表示线程已经结束执行,当线程的run()方法执行结束时或者主线程执行结束时就处于该状态,此时再次调用start()方法会报错.]]></content>
      <tags>
        <tag>多线程面试_4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程面试_3]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F08%2F02%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95_3%2F</url>
    <content type="text"><![CDATA[如何给run()方法传参 我们都知道,跟线程相关的业务逻辑都是要放在run()方法里去执行的,而run()方法是没有参数也没有返回值的,那么应该如何给run()方法传参呢? 构造函数传参: 这就是我上一篇博客里利用Runnable接口实现多线程的例子. 成员变量传参: 这个就比如我在run()方法里使用了一个全局变量,我们通过给全局变量赋值然后在run方法中使用该值,就起到了传参的效果,就是我上一篇博客Thread实现多线程的例子. 回调函数传参: 我jio的就是在run()方法里去调用其他方法并获取其返回值加以使用的意思. 如何实现处理线程的返回值 我们有的程序的执行依赖于子任务的返回值进行的,当子任务通过线程去执行的时候,是需要获取其返回值的,这可咋整?实现子线程返回值的方法是啥? 主线程等待法,即我们可以让主线程循环等待,直到目标子线程返回了其结果为止,这种方法实现起来比较简单,但是需要自己实现循环等待的逻辑,以及我们不知道要等待多久,需要等待的变量一多,代码就会很臃肿. 1234567891011121314151617181920212223242526272829public class MainThreadWait implements Runnable&#123; private String value; @Override public void run() &#123; try &#123; Thread.currentThread().sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;running&quot;); value = &quot;we have data now&quot;; &#125; public static void main(String[] args) throws InterruptedException &#123; MainThreadWait mtw = new MainThreadWait(); Thread t1 = new Thread(mtw); t1.start(); //直接执行main方法,还是会出现value为空的现象,因为主线程没有等它赋值结束就执行了打印语句,此时我们就需要让主线程一直等着 while (mtw.value == null) &#123; System.out.println(&quot;waiting...&quot;); Thread.currentThread().sleep(100); &#125; //有了上面的代码之后,我们会发现,主线程会等待500毫秒直到value有值之后才会执行这条语句 System.out.println(mtw.value); &#125;&#125; 利用Thread类的join()方法来阻塞当前线程以等待子线程处理完毕.其中,join()的作用就是无限期阻塞当前线程,等待调用join()方法的线程对象被销毁再执行其他线程 1234567891011121314151617181920212223242526public class MainThreadWait implements Runnable&#123; private String value; @Override public void run() &#123; try &#123; Thread.currentThread().sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;running&quot;); value = &quot;we have data now&quot;; &#125; public static void main(String[] args) throws InterruptedException &#123; MainThreadWait mtw = new MainThreadWait(); Thread t1 = new Thread(mtw); t1.start(); //阻塞当前线程等待t1线程执行结束 t1.join(); //有了上面的代码之后,我们会发现,主线程会等待500毫秒直到value有值之后才会执行这条语句 System.out.println(mtw.value); &#125;&#125; 通过Callable接口实现:通过FutureTask这个类或者线程池获取返回值 实现了Callable接口的任务可以有返回值,并且可以抛出异常,run()方法都不可以.在执行Callable任务之后,可以获取一个Future接口对象,然后通过get方法就可以获取Callable任务返回的Object对象了.通过Callable方式获取线程的返回值主要有两种方式: 通过FutureTask这个Future接口的实现类或者线程池获取.123456789101112131415161718192021222324252627282930---创建MyCallable类public class MyCallable implements Callable&lt;String&gt; &#123; @Override public String call() throws Exception &#123; String value = &quot;test&quot;; System.out.println(&quot;ready to work&quot;); //让当前线程休眠1秒 Thread.currentThread().sleep(1000); System.out.println(&quot;task done&quot;); return value; &#125;&#125;---FutureTask方式测试类public class MyCallable_FutureTask &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; FutureTask&lt;String&gt; task = new FutureTask&lt;String&gt;(new MyCallable()); //因为Future接口继承了Runnable接口,而Thread可以通过Ruannable创建线程,所以这里可以穿task. Thread thread = new Thread(task); thread.start(); //如果还没有执行结束 if (!task.isDone()) &#123; System.out.println(&quot;task has not finished, please wait&quot;); &#125; //5秒之后,才会执行这句话 System.out.println(&quot;task return : &quot; + task.get()); &#125;&#125;输出结果如图: 1234567891011121314151617181920我们直接利用一下上面的Callable类public static void main(String[] args) &#123; //线程池创建好之后,就往线程池提交任务去让它执行,此处的任务就是我们的Callable ExecutorService newCacheThreadPool = Executors.newCachedThreadPool(); Future&lt;String&gt; future = newCacheThreadPool.submit(new MyCallable()); if (!future.isDone()) &#123; System.out.println(&quot;task has not finished, please wait&quot;); &#125; try &#123; System.out.println(future.get()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; finally &#123; //关闭线程池 newCacheThreadPool.shutdown(); &#125; &#125; 输出结果和上面的一样的. 使用线程池获取结果的好处就是我们可以提交多个实现Callable接口的类去让线程池并发(可以理解为多个线程同时进行)的处理结果,其他的方法都是线性的,按照代码的顺序执行对应的线程.]]></content>
      <tags>
        <tag>多线程面试_3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程面试_2]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F08%2F02%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95_2%2F</url>
    <content type="text"><![CDATA[Thread中start和run方法的区别1. 调用start()方法会创建一个新的子线程并启动.2. run()方法只是Thread的一个普通方法的调用,还是在主线程内执行.例子: 通过start()方法启动线程时通过查看start()方法的源码我们知道,它是通过一个native方法start0() 实现的,而start0()源码中的确创建了一个新的线程.通过run()方法启动线程时Thread和Runnable是什么关系1. Thread是一个类,而Runnable是一个接口,并且Thead类实现了Runnable接口.12345678910111213141516---Thread类:public class Thread implements Runnable &#123;private Runnable target;@Override public void run() &#123; if (target != null) &#123; target.run(); &#125; &#125;&#125;---Runnable接口public interface Runnable &#123; public abstract void run();&#125;2. Runnable接口自身并不能实现多线程,多线程的实现需要靠Thread类的start()方法来生成线程,之后通过Thread类中run()方法去调用重写的run方法来实现.3. 由于java类的单一继承原则,在实际开发过程中推荐多实用Runnable接口.4. 多线程的实现方法如下面的例子:—通过Thread类实现多线程的案例如下:123456789101112131415161718192021222324252627---MyThread类public class MyThread extends Thread&#123; private String name; public MyThread(String name1) &#123; this.name = name1; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println(&quot;Thread start : &quot; + this.name + &quot;,i=&quot; + i); &#125; &#125;&#125;---多线程测试类public static void main(String[] args) &#123; //创建多个线程 MyThread mt1 = new MyThread(&quot;mythread1&quot;); MyThread mt2 = new MyThread(&quot;mythread2&quot;); MyThread mt3 = new MyThread(&quot;mythread3&quot;); mt1.start(); mt2.start(); mt3.start(); &#125;部分测试结果如图:由图可知,线程执行过程中,并不是一个线程执行结束另一个线程才开始执行,而是他们是交互执行的.—通过Runnable接口实现多线程的案例如下: 由于Runnable接口里是没有start()方法的,它只有一个run()方法,所以就只通过这个接口是不可能实现多线程的.但是我们可以通过Thread类的一个构造函数实现,如下:12345678910111213141516171819202122232425262728293031323334---Thread类里的构造方法://该构造方法使用默认名public Thread(Runnable target) &#123; init(null, target, &quot;Thread-&quot; + nextThreadNum(), 0); &#125;//该构造方法还可以自己给线程命名 public Thread(Runnable target, String name) &#123; init(null, target, name, 0); &#125;---MyRunnable接口public class MyRunnable implements Runnable&#123; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println(&quot;Thread start : &quot; + Thread.currentThread().getName() + &quot;,i=&quot; + i); &#125; &#125;&#125;---测试类public static void main(String[] args) &#123; //通过Runnable接口创建多个线程 //使用默认名 Thread thread1 = new Thread(new MyRunnable()); //使用自定义名 Thread thread2 = new Thread(new MyRunnable(), &quot;mr2&quot;); Thread thread3 = new Thread(new MyRunnable(), &quot;mr3&quot;); thread1.start(); thread2.start(); thread3.start(); &#125;---部分结果如图: 由图可知: 这样也一样实现了多线程的交互执行的特点.]]></content>
      <tags>
        <tag>多线程面试_2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程面试_1]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F08%2F02%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95_1%2F</url>
    <content type="text"><![CDATA[进程和线程的区别 进程:指的是 一个用户程序在同一数据集合上的一次执行过程,它是资源分配的基本单位,可以理解为它就是运行中的一个程序.线程:线程是进程上的一个实体,也是真正的执行体,它是系统调度的基本单位.进程和线程的由来:—进程和线程的区别:1. 正如上面所说:进程是资源分配的最小单位,线程是CPU调度的最小单位.2. 所有与进程相关的资源,都被记录在PCB(Process Control Block, 进程控制块) 中.3. 进程是抢占处理器的调度单位,每个进程都拥有一个完整的虚拟内存地址空间,当进程发生调度时,不同的进程拥有不同的虚拟内存地址空间,线程属于某个进程,同一进程内的不同线程共享该进程资源.4. 线程只由堆栈寄存器(存储线程内的局部变量,不能存储其他线程的变量),程序计数器和TCB(Thread Control Block, 线程控制块)组成.—总结: 线程不能看作独立应用去独立执行,而进程可以看作独立应用. 进程有独立的地址空间,相互不影响,线程只是进程的不同执行路径,也就是其执行体,当进程停止后,其中的所有线程都会停止. 线程没有独立的地址空间,多进程的程序比多线程程序健壮. 进程的切换比线程切换开销大. 一个程序运行至少有一个进程，一个进程里面至少包含一个线程，线程是进程的组成部分. Java中进程和线程之间的关系 java对操作系统提供的功能进行了封装,包括线程和进程. 每运行一个java程序都会产生一个java进程,每个java进程至少包含一个线程. 每个java进程对应一个jvm实例(也就对应一个jvm堆这些),多个线程共享jvm里的堆但是每个线程都有自己私有的的栈. java采用单线程编程模型,如果自己没有创建线程的话,程序会自动创建一个主线程,当java程序启动时,主线程立即运行. 主线程可以创建子线程,原则上主线程要后于子线程完成执行,因为主线程还要执行一些关闭的动作.]]></content>
      <tags>
        <tag>多线程面试_1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM面试_9]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F08%2F01%2FJVM%E9%9D%A2%E8%AF%95_9%2F</url>
    <content type="text"><![CDATA[Object中的finalize()方法的作用是否与C++的析构函数作用相同1. 它与C++的析构函数不同,析构函数调用时机是确定的,即对象离开作用域后就会被delete掉,而finalize()方法调用时机是不确定的.2. 当垃圾回收器要宣告一个对象死亡时,要经过至少两次标记过程,如果对象在经过可达性算法分析后发现其没有与GC Roots相连的引用链,它就会第一次被标记,并且判断是否执行finalize()方法,如果该对象没有重写finalize()方法或者finalize()方法已经被虚拟机调用过了,那么它就会直接被回收,否则(即重写了finalize()方法且虚拟机为调用过该方法,gc就是调用finalize方法)它会将未被引用的对象放到一个F-Queue队列中,稍后会由一个虚拟机自动创建的低优先级的Finalizer线程去触发finalize方法.3. 由于Finalizer的优先级比较低,触发该方法后,它不会等这个方法运行结束.所以方法执行后随时可能会被终止.4. finalize()方法的作用就是给对象创造最后一次重生的机会,只要在finalize方法执行结束前 让对象和一个存活对象的引用链中的任意一个对象相连,如图中的finalization=this就是让对象获取重生.—java中强引用,软引用,弱引用,虚引用有什么用 强引用: 它是最普遍的引用: 例如Object obj = new Object();其中的obj就属于强引用. 如果一个对象有强引用,当内存内存空间不足的时候,虚拟机宁可抛出OutOfMemoryError异常终止程序,也不会回收有强引用的对象的内存. 如果我们不使用该有强引用的对象了,就需要通过将对象设置为null来弱化引用或者等待该对象超过其生命周期范围,使其被回收. 软引用: 软引用表示一个对象处在有用但非必须的状态. 如果一个对象具有软引用,只有当内存空间不足时,GC才会回收该引用的对象的内存. 软引用可以用来实现高速缓存. 其用法如图: 弱引用: 弱引用指向的对象是非必须的对象,强度比软引用更弱一些. 弱引用对象在GC时就会被回收(不论当前内存是否充足). 被回收的概率也不大,因为GC线程优先级比较低,所以有可能找不到哈哈哈. 适合于偶尔使用且不影响垃圾收集的对象. 用法如图: 虚引用: 顾名思义,它就是形同虚设的引用,它不会决定对象的生命周期. 如果一个对象只有虚引用,那它跟没有引用一样一样的,在任何时候都可能被垃圾回收器回收. 虚引用主要用来跟踪对象被垃圾回收器回收的活动,起哨兵作用. 必须和引用队列ReferenceQueue联合使用. 用法如图:软引用和弱引用也可以通过上述方式进行调用,GC在回收一个对象时,如果发现该对象具有虚引用,那么在回收前会首先将虚引用加入到与之关联的引用队列当中,程序可以通过判断引用队列是否已经加入虚引用来了解被引用的对象是否被GC回收,也就是起到了一个哨兵的作用. 引用队列: 引用队列没有实际的存储结构,存储逻辑依赖于内部节点之间的关系来表达,可以理解为一个链表的结构,只是它会自带一个head头结点,其余的节点(也就是引用本身)通过next连接. 存储关联的且被GC的软引用,弱引用以及虚引用. 引用总结: 其级别由高到低:强引用&gt;软引用&gt;弱引用&gt;虚引用 引用相关的类层次结构:]]></content>
      <tags>
        <tag>JVM面试_9</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM面试_8]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F08%2F01%2FJVM%E9%9D%A2%E8%AF%95_8%2F</url>
    <content type="text"><![CDATA[老年代常见的垃圾收集器 Serial Old收集器 通过命令UseSerialOldGC可以使老年代使用该收集器回收垃圾,它使用的是标记-整理算法. 单线程收集,进行垃圾收集时,必须暂停所有的工作线程. 简单高效,Client模式下默认的老年代收集器 Parallel Old收集器 1. 通过命令UseParallelOldGC可以使老年代使用该收集器回收垃圾,它使用的是标记-整理算法. 2. 多线程收集,吞吐量优先.—CMS收集器1. 通过命令UseConcMarkSweepGC可以使老年代使用该收集器回收垃圾,它使用的是标记-清除算法.2. 它的意义在于垃圾回收线程和用户线程几乎可以做到同时工作.3. 其垃圾回收过程主要分为以下六步: 1. 初始化标记: 此时会发生stop-the-world,这个阶段需要虚拟机停顿正在执行的任务. 2. 并发标记: 并发追溯标记,程序不会停顿(与应用程序线程并发执行). 3. 并发预处理: 查找执行并发标记阶段从年轻代晋升到老年代的对象. 4. 重新标记: 暂停虚拟机,扫描CMS堆中的剩余对象. 5. 并发清理: 清理垃圾对象,程序不会卡顿. 6. 并发重置: 重置CMS收集器的数据结构.—G1收集器(Garbage First收集器)1. 通过命令UseG1GC可以使老年代使用该收集器回收垃圾,它使用的是复制+标记-整理算法.2. Garbage First收集器既用于年轻代,也用于老年代.3. 它会将整个java堆内存划分为多个大小相等的Regin(区域).4. 新生代和老年代不再物理隔离,他们可以是一部分不连续的Regin的集合.Garbage First收集器的特点 并发和并行: 使用多个cpu来缩短stop-the-world的停顿时间,与用户线程并发执行. 分代收集 空间整合 可预测的停顿.]]></content>
      <tags>
        <tag>JVM面试_8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM面试_7]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F08%2F01%2FJVM%E9%9D%A2%E8%AF%95_7%2F</url>
    <content type="text"><![CDATA[Stop-the-World 这个单词就是说,JVM由于要执行GC而停止了应用程序的执行,即除了GC的线程执行外,所有线程都处于等待状态,并且这种情况在任何一种GC算法中都会发生.多数GC优化就是通过减少Stop-the-World发生的时间来提高程序性能. Safepoint安全点 形象的说: jvm垃圾回收就好比是宝洁阿姨在打扫卫生,如果一边打扫,一边有人扔垃圾可咋整?为了不让这种情况发生,即保洁阿姨在开始打扫前就和所有人说,我要搞卫生了,别扔垃圾了就成了. 在jvm垃圾回收时,如何达到上面的情况呢? 在可达性分析算法中,要分析哪个对象没有被引用的时候,必须在一个快照的状态点(可以理解为一瞬间) 进行,在这个点,所有的线程都被冻结了,不可以出现分析过程中引用关系还在变化的情况,因此,分析结果需要在某个节点具备确定性,该节点就叫安全点. 即安全点就是在可达性分析算法中对象引用关系不会发生变化的点,程序只有在安全点才会停下来. 产生Safepoint的地方:方法调用;循环跳转;异常跳转等;—JVM的运行模式 server模式:启动较慢,但是启动之后,由于采用的是重量级的虚拟机,优化更多,所以程序跑起来更快. client模式:启动较快,由于采用的是轻量级的虚拟机,所以程序跑起来相对慢一些. 通过在cmd的命令提示符窗口下输入java -version就可以看到我们当前jvm的运行模式了. 垃圾收集器之间的联系垃圾收集器之间有连线就说明他们可以搭配使用.年轻代常见的垃圾收集器 Serial收集器 通过命令UseSerialGC就可以使年轻代用这个收集器,它采用复制算法. Serial收集器采用单线程收集,进行垃圾收集时,必须暂停所有工作线程. 它简单而且高效,是Client模式下默认的年轻代收集器. ParNew收集器 通过命令UseParNewGC就可以使年轻代用这个收集器,它采用复制算法. 它采用多线程收集. 其余的行为.特点和Serial收集器一样. 它是server模式下首选的年轻代垃圾收集器. 单核执行效率不如Serial,在多核下执行才有优势. Parallel Scavenge收集器吞吐量 = 运行用户代码时间/(运行用户代码时间+垃圾回收时间) 通过命令UseParallelGC就可以使年轻代用这个收集器,它采用复制算法. 使用多线程进行垃圾回收. 比起关注用户线程停顿时间,更关注系统的吞吐量. 在多核下执行才有优势,Server模式下默认的年轻代收集器.]]></content>
      <tags>
        <tag>JVM面试_7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM面试_6]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F08%2F01%2FJVM%E9%9D%A2%E8%AF%95_6%2F</url>
    <content type="text"><![CDATA[垃圾回收算法分类: 标记-清除算法 复制算法 标记-整理算法 标记清除算法 顾名思义,该算法进行垃圾回收共分为两个阶段: 标记: 从根集合出发,进行扫描,通过可达性算法对需要回收的对象进行标记. 这里有的地方说的是对存活的对象进行标记,其实也有道理,不过书上说的是对需要回收的对象,那就写需要回收的对象 清除: 对堆内存从头到尾进行线性遍历,回收不可达对象内存. 标记清除算法的不足: 由于标记-清除算法不需要进行对象的移动并且仅对不存活的对象进行处理,所以回收后,会产生很多不连续的碎片化的空间,这就有可能导致较大的对象没有足够的内存存放,因此不得不提前触发另一次垃圾回收. 效率比较低. 复制算法 将可用的内存按容量及一定比例划分为两块, 并选择其中一块作为对象面,另一块作为空闲面. 对象在对象面上创建. 当对象面的内存用完之后,就将存活的对象从对象面复制到空闲面. 将对象面的所有对象内存全部清除. 这种方法适用于对象存活率较低的场景. 移动的时候,只需要移动堆顶指针,按顺序分配内容即可. 复制算法的好处:1. 由于每次是对一整个区域进行回收,所以不会产生不连续的碎片化的空间.2. 移动的时候直接顺序分配内存,简单高效.3. 年轻代的垃圾回收主要通过这种算法.—标记-整理算法当复制算法在对象存活率比较高的时候就要进行较多的复制操作,效率就会变低,而且,如果不想五五开这样浪费50%的空间的话,就需要额外空间进行担保,防止空闲面的内存不够存活对象放的情况,因此,老年代不采用这种算法,老年代采用标记-整理算法.—标记-整理算法过程: 1. 标记: 从根集合进行扫描,通过可达性分析算法,对存活的对象进行标记. 2. 清除: 清除时移动所有存活的对象,且按照内存地址次序依次排列,然后将末端内存地址以后的内存全部回收.—标记-整理算法好处:1. 解决了碎片化空间的问题.2. 不需要像复制算法一样设置两块内存.3. 适合于对象存活率较高的场景.—分代收集算法(主流GC算法) 分代收集算法可以认为是垃圾回收算法的组合拳它将堆内存进行进一步的划分,按照对象生命周期的不同来划分区域以采用不同的垃圾回收算法.这样的目的就很简单: 用于提高JVM的回收效率. 一般来说,年轻代存活率低,就采用复制算法,老年代存活率高,就采用标记-清除算法或者标记-整理算法. GC的分类分代收集算法的GC主要有两种: 1. Minor GC: 也就是发生在年轻代的垃圾收集动作,所采用的的是复制算法,年轻代几乎是所有java对象出生的地方, 即java对象申请的内存以及对象的存放都在这里进行. 2. Full GC: 该GC与老年代相关,由于对老年代的回收一般会伴随着年轻代的垃圾收集,因此它才被称为Full GC.—JDK7及其之前的堆内存分布图:由图可知,JDK7及以前,堆内存可以分为三个部分: 年轻代,老年代,永久代.—JDK8及其以后的堆内存分布图:如图所示: JDK8及其以后,由于没有了永久代,所以堆内存就只有两部分了:年轻代,老年代.—年轻代 年轻代中存放的都是那些朝生夕灭的对象,所以它会尽可能快速地收集掉那些生命周期短的对象,主要包括三个区域: Eden区: 伊甸园啊~~~,所以说我们就可以知道对象刚被创建出来的时候,都是被放在Eden区的,当然了,Eden放不下了还是有可能放在Survivor区的. 两个Survivor区(from区, to区): 这两个区域不是固定的,会随着垃圾回收相互转换. 三个区域的比例如图:在年轻代中,每次它都只会使用Eden区和其中的一块Survivor区(一般认为是From Survivor区)用来存放对象,当进行GC的时候,它就把这两个区域里存活的对象全部都放到另一个Survivor区域(To Survivor区)中去,然后一次性清除掉之前的Eden区和From Survivor区,最后交换两个Survivor区的身份,将From Survivor当作To Survivor区,同时注意:当survivor区域的内存不足以存放所有的存活对象的时候,就会往老年代中放. 老年代 老年代中存放的一般都是生命周期较长的对象,采用标记-清除算法或者标记-整理算法进行垃圾回收.由于对老年代的回收一般会伴随着年轻代的垃圾收集,也就是说会对整个堆进行回收,所以它被称为Full GC或Major GC. Full GC比Minor GC慢,但是执行频率较低. 触发Full GC的条件 老年代空间不足. CMS GC(并发标记-清除算法)时出现promotion failed(minor gc时survivor中放不下了,对象要放到老年代,同时此时老年代也放不下), concurrent mode failure. Minor GC晋升到老年代的平均大小大于老年代剩余空间. 调用System.gc(),此时会提醒虚拟机要对老年代和新生代进行回收,但是具体啥时候回收,要不要回收还是由虚拟机决定. 对象如何晋升到老年代 经历一定的Minor GC次数之后依然存活的对象(对象在新生代每经历一次Minor GC,它的年龄计数器就会加1,一般年龄计数器到15了就会进入老年代). Survivor区中存放不下的对象会直接进入老年代. 新生成的大对象直接进入老年代中(-XX: +PretenuerSizeThreshold控制大对象的大小,超过该值的就直接进入老年代). 常见的调优参数:比如当值设置为8的时候,就表示Eden与其中一个Survivor的比例为8:1.比如当值设置为2的时候,那么老年代的内存和年轻代内存的比例为2:1.新生代和老年代所占内存的总大小是通过-Xmx和-Xms决定的.]]></content>
      <tags>
        <tag>JVM面试_6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM面试_5]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F08%2F01%2FJVM%E9%9D%A2%E8%AF%95_5%2F</url>
    <content type="text"><![CDATA[对象被判定为垃圾的标准 没有被其他对象引用的对象应该被判定为垃圾. 判断对象是否为垃圾的算法 引用计数算法 可达性分析算法 引用计数算法 通过判断对象的引用数量来决定对象是否可以被回收. 在这种机制下,堆中的每个实例对象都有一个引用计数器,对象被引用则计数器+1,完成引用(引用失效)则-1. 当引用计数器值为0的时候,该实例对象便被认为可以被当做垃圾回收. 引用计数算法优点:执行效率高,程序执行受影响较小引用计数算法缺点:无法检测出循环引用的情况,可能会因此导致内存泄漏.比如两个对象互相引用,对象ojbA和对象objB都有字段instance,赋值令objA.instance = objB和objB.instance = objA,那这两个对象永远都不会回收.但是实际上 ,jvm没有采取这种方式进行垃圾标记.—可达性分析算法通过判断对象的引用链是否可达来决定对象是否可以被回收.可达性分析算法原理: 通过一系列名为GC Roots的对象作为起始点,从这些节点开始向下搜索,搜索所走过的路径就被称为引用链,当一个对象到GC Roots没有任何引用链相连的时候,就认为从GC Roots到这个对象是不可达的,也就证明了该对象是不可用的,可以被回收. 可以作为GC Roots的对象: 虚拟机栈中引用的对象(栈帧中的本地变量表里面引用的对象),比如说我们将一个new出来的对象赋值给了一个局部变量,那么在这个方法执行结束前,这个new出来的对象就可以作为GC Root. 方法区(也就是元空间,存放的是类的信息)中常量引用的对象, 比如在类里定义了一个常量,该常量保存的时某个对象的地址,那么这个对象也是GC Root. 方法区中类静态属性引用的对象,和第二条差不多. 本地方法栈中JNI(Native方法)的引用对象. 活跃状态的线程(也就是线程还在跑的状态下)的引用对象.]]></content>
      <tags>
        <tag>JVM面试_5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis_5]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F08%2F01%2Fmybatis_5%2F</url>
    <content type="text"><![CDATA[动态sql简介if标签使用步骤(创建jdbc连接这些我就省略了哈,我把全部代码都放后面): StudentDao接口12345@Mapperpublic interface StudentDao &#123; List&lt;Student&gt; selectif(@Param(&quot;name&quot;) String name, @Param(&quot;age&quot;) int id);&#125;StudentDaoMapper配置文件1234567891011121314151617&lt;mapper namespace=&quot;com.ctgu.dao.StudentDao&quot;&gt; &lt;!--查询--&gt; &lt;!--可以根据姓名查询,也可以根据id查询,或者两个都有等等--&gt; &lt;!--注意用if标签的时候,这里要有一个1=1,防止所有参数都没有的时候sql语句报错--&gt; &lt;select id=&quot;selectif&quot; resultType=&quot;com.ctgu.bean.Student&quot;&gt; select name,age,address from student where 1=1 &lt;if test=&quot;name != null and name != &apos;&apos;&quot;&gt; and name like &apos;%&apos; #&#123;name&#125; &apos;%&apos; &lt;/if&gt; &lt;if test=&quot;age &gt;= 0&quot;&gt; and age &gt;= #&#123;age&#125; &lt;/if&gt; &lt;/select&gt;&lt;/mapper&gt;测试类1234567@Test public void selectif() &#123; List&lt;Student&gt; list = studentDao.selectif(&quot;&quot;, 10); for (Student s : list) &#123; System.out.println(s); &#125; &#125;完整代码链接]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis_5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM面试_4]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F07%2F31%2FJVM%E9%9D%A2%E8%AF%95_4%2F</url>
    <content type="text"><![CDATA[关于java内存模型我还没怎么整明白,我先写着,大家先看看jvm内存模型的面试题先 java内存模型简介 内存简介: 计算机所有程序都是在内存中运行的.在程序执行的过程中,需要不断地将内存的逻辑地址和物理地址进行映射,找到相关的指令和数据去执行.32位处理器: 2^32的可寻址范围,即4G.64位处理器: 2^64的可寻址范围.内存中地址空间的划分 内核空间 用户空间(java程序使用的就是这个)emm,我在这里先粗暴的认为java内存模型包括用户空间和内核空间,而用户空间就包括运行时数据区(jvm内存模型) JVM内存模型–JDK8下 java程序运行在虚拟机之上,运行时需要内存空间,虚拟机执行java程序的过程中,会把它管理的内存划分为不同的数据区域. 从线程角度看: 线程私有: 程序计数器,虚拟机栈,本地方法栈.线程共享: MetaSpace(元空间,可以就理解为方法区,方法区是一种规范,而元空间是一种实现), java堆. java内存模型之线程独占部分 程序计数器 它是一块较小的内存空间,它的作用: 可以看作是当前线程执行的字节码文件的行号指示器,它是一个逻辑计数器,不是物理计数器. 字节码解释器工作时,就是通过改变计数器的值来选取下一条需要执行的字节码指令. 为了保证线程切换后能恢复到正确的执行位置,计数器和线程是一对一的关系,即“线程私有”. 如果当前线程执行的是java方法,这个计数器记录的就是正在执行的虚拟机字节码指令的地址;而如果是Native方法那这个计数器则为Undefined. 不会发生内存泄漏. java虚拟机栈 可以认为是java方法执行时的内存模型. 每个方法被执行时都会创建一个栈帧(栈帧中包含的数据如图所示),每个方法的执行,对应栈帧的入栈虚拟机到出虚拟机栈(所以栈不需要GC,它会自动滚蛋)的过程,虚拟机栈中包含多个栈帧. 会出现java.lang.StackOverflowError异常以及java.lang.OutOfMemoryError异常. 栈帧所包含的内容如图所示:局部变量表: 一般都是一个数组,包含方法执行过程中的所有变量(this啊,布尔啊,对象引用啊各种类型的都包括). 操作数栈(在执行字节码指令过程中使用,即它代表着执行代码的操作): 主要包括入栈,出栈,复制,交换,产生消费变量几个步骤. 局部变量表主要是为操作数栈进行数据支持. 举例:如图所示: 每个长方形代表一个栈帧(随时都只有一个哈,只是为了表示执行步骤才这么画的),操作数栈的深度为2,局部变量表的深度为3,store表示出操作数栈,load表示入操作数栈. 递归为什么会引发java.lang.StackOverflowError异常 当线程执行一个方法时,就会随之创建一个栈帧,同时会将栈帧压入到虚拟机栈中,当方法执行完毕后,就会将栈帧出栈,由此我们可以知道,线程当前执行的方法所对应的栈帧一定是在java虚拟机栈顶. 而递归函数不断去调用自身,每次方法调用会涉及下面几个步骤:-. 每次方法调用都会生成一个栈帧.-. 同时它会保存当前方法的栈帧状态,将其置于虚拟机栈中.-. 栈帧上下文切换的时候,会切换到最新的方法栈帧当中.由于我们每个虚拟机的虚拟机栈的深度是固定的,每次递归调用会导致栈深度的增加,当我们递归次数太多了之后,压入的栈帧数会超过虚拟机栈深度,就报错了. 虚拟机栈为什么会引发java.lang.OutOfMemoruError异常 当虚拟机栈可以动态扩展时,如果无法申请足够多的内存,就会抛出这个异常. 本地方法栈 本地方法栈与虚拟机栈类似,其主要作用于标注为native的方法. java内存模型之线程共享部分元空间与永久代的区别 在JDK8及以后,开始将类的元数据放到本地堆内存中,这一块区域就叫做元空间(但是习惯上我们还是将其当做方法区看待,也就是说还是当做在堆外面),该区域在JDK7及以前都是属于永久代的.元空间和永久代都是用来存储class的相关信息,包括class对象的方法和字段等.同时我们要注意:元空间和永久代均是方法区的实现,只是实现有所不同.方法区只是jvm的一种规范,在jdk7之后,原先位于方法区里的字符串常量池被移到了java堆中,并且在JDK8及其之后,使用元空间替代了永久代. 元空间使用本地内存,而永久代使用的是jvm的内存. 元空间没有字符串常量池(这也就说明,我们还是可以把元空间看成一个独立的部分的). MetaSpace相对于PermGen的优势 - 字符串常量池存在于永久代中,容易出现性能问题和内存溢出. - 类和方法的信息大小难以确定,给永久代的大小指定带来困难. - 永久代会为GC带来不必要的复杂性. - 方便HotSpot和其他jvm(没有永久代)和Jrockit的集成.—java堆 - 它是对象实例的分配区域,是java虚拟机管理的最大的一块,被所有线程共享,在虚拟机启动时创建. - java堆可以处于物理上不连续的内存空间中,只要逻辑上是连续的即可,当前主流的虚拟机都是按照可扩展实现的,通过-Xmx设置最大值和-Xms设置最小值,如果在堆中没有内存完成实例分配并且堆也无法再扩展时,将会抛出OutOfMemory异常. - java对是GC的主要区域,可以分为以下几个部分:JVM三大性能调优参数:-Xms, -Xmx, -Xss的含义 - -Xss: 规定了每个线程虚拟机栈(即堆栈)的大小,默认情况是256k,此配置将会影响此进程中并发线程数的大小. - -Xms: 堆的初始值,即该进程刚创建出来的时候,其专属java堆的大小,一旦对象容量超过了java初始堆的容量,java堆就会自动扩容至-Xmx大小. - -Xmx: 堆能达到的最大值,通常情况下,我们都将-Xms和-Xmx设置为一样的.Java内存模型中的内存分配策略内存分配策略有三种,分别为: 1. 静态存储: 编译时确定每个数据目标在运行时的存储空间需求,因而在编译时就能给他们分配固定的内存空间,这就要求代码里不能有可变数据结构或者嵌套递归等的出现. 2. 栈式存储: 该分配可称为动态的存储分配,是由一个类似于堆栈的运行栈来实现的,和静态存储的分配方式相反,数据区需求在编译期未知,运行时才能知道,但是在进入一个程序模块的时候必须要知道数据区所需大小,以此为其分配内存. 3. 堆式存储: 编译时或运行时进入程序模块时都无法确定数据区大小,动态分配,比如对象实例和可变长度串.Java内存模型中堆和栈的联系 创建对象,数组时,栈中可以定义变量(被称为对象和数组的引用变量)用于保存该对象在堆中的首地址. Java内存模型中堆和栈的区别 管理方式: 栈自动释放,堆需要GC. 空间大小: 栈比堆小. 碎片数量: 栈产生的碎片远小于堆. 内存分配方式: 栈支持静态和动态分配,而堆仅支持动态分配. 效率: 栈的效率比堆高. 元空间,堆,线程独占部分间的联系 例子如图: 从内存角度看上面的代码不同JDK版本之间的intern()的区别–JDK6 VS JDK6+ intern()方法的用法:JDK6: 当调用intern()方法时,如果字符串常量池先前已有该字符串对象值,则返回池中该字符串的地址,否则,将此字符串对象添加到字符串常量池中,并且返回该字符串的地址. JDK6+: 当调用intern()方法时,如果字符串常量池先前已经有该字符串对象值,则返回池中该字符串常量池的地址.,如果该字符串对象已经存在于java堆中但还没有将值加载到字符串常量池中,则将堆中此对象的引用添加到字符串常量池中,并且返回该引用;如果堆中不存在,则在池中创建该字符串,同时在堆中创建String对象,并返回String对象的引用(注意不是值在字符串常量池中的地址哈). JDK6之前,字符串常量池中仅会添加字符串对象或者堆中字符串对象的副本,虽然也是字符串对象,而JDK6以后,字符串常量池中不仅可以添加字符串对象,还可以添加字符串对象在堆中的引用. JDK1.8 运行结果:运行过程分析:对于jdk7及其以上版本而言,由于运行时常量池中可以放引用了,所以两个地址有可能一样 1. string s = new string(“a”); 它会先在字符串常量池中创建一个a,然后在堆中创建一个对象,同时使得对象引用s指向堆中的对象. 2. s.intern(); 首先会去字符串常量池中看有没有a这个值,如果有,直接返回其在字符串常量池中的地址,如果没有,他就会将对象的引用放到字符串常量池中. 3. String s2 = “a”; 此时它会去字符串常量池中去找看有没有a的存在,有就直接返回其在字符串常量池中的地址,没有就会在字符串常量池中创建一个a. 4. System.out.println(s == s2); 此时我们通过上面的分析可以知道,s指向的是堆中的地址,而s2指向的时常量池中a的地址,所以肯定不相等啦! 5. String s3 = new String(“a”) + new String(“a”); 它首先会在堆中创建两个值为a的对象,由于此时a在字符串常量池中有了,所以不会在字符串常量池中创建,然后创建一个aa的对象,但是注意此时不会在常量池中创建ab这个值.然后使s3指向堆中值为ab的对象. 6. s3.intern(); 它去字符串常量池中去找有没有aa这个值,发现没有哈哈哈^^,然后它就会把值为aa的对象的引用放到字符串常量池中去(也就是其地址). 7. String s4 = “aa”; 它去字符串常量池中找,发现字符串常量池中有aa这个值,直接返回其地址(该地址也是堆中值为aa对象的地址). 8. System.out.println(s3 == s4); 两个指向的都是堆中值为aa的对象地址,你说相等不相等嘿嘿嘿.所以说,当直接创建字符串的时候,会自动在字符串常量池中创建对应的值,但是通过+连接两个字符串对象的时候就不会去字符串常量池创建对应的值 JDK1.6 运行结果: 运行过程分析:JDK6及以前,都是放副本进去,所以说肯定不可能一样. string s = new string(“a”); 它会先在字符串常量池中创建一个a,然后在堆中创建一个对象,同时使得对象引用s指向堆中的对象. s.intern(); 首先会去字符串常量池中看有没有a这个值,如果有,直接返回其在字符串常量池中的地址,如果没有,他就会将对象的引用放到字符串常量池中. String s2 = “a”; 此时它会去字符串常量池中去找看有没有a的存在,有就直接返回其在字符串常量池中的地址,没有就会在字符串常量池中创建一个a. System.out.println(s == s2); 此时我们通过上面的分析可以知道,s指向的是堆中的地址,而s2指向的时常量池中a的地址,所以肯定不相等啦! String s3 = new String(“a”) + new String(“a”); 它首先会在堆中创建两个值为a的对象,由于此时a在字符串常量池中有了,所以不会在字符串常量池中创建,然后创建一个aa的对象,但是注意此时不会在常量池中创建ab这个值.然后使s3指向堆中值为ab的对象. s3.intern(); 它去字符串常量池中去找有没有aa这个值,发现没有哈哈哈^^,然后它就会把值为aa的对象的副本(注意是副本)放到字符串常量池中去(也就是值为aa的字符串). String s4 = “aa”; 它去字符串常量池中找,发现字符串常量池中有aa这个值,直接返回其地址(该地址是字符串常量池中aa字符串的的地址). System.out.println(s3 == s4); s3指向的是堆中值为aa的对象地址,而s4指向的是字符串常量池中aa字符串的地址,当然不相等啦嘿嘿嘿. 一个小小的时间线: jdk7运行时常量池被放到了堆中,同时intern()方法有了些许改变 jdk8以后用元空间取代了永久代]]></content>
      <tags>
        <tag>JVM面试_4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM面试_3]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F07%2F30%2FJVM%E9%9D%A2%E8%AF%95_3%2F</url>
    <content type="text"><![CDATA[类的加载方式 隐式加载: new,程序在运行过程中,遇到通过new方式来生成对象时,隐式调用类加载器去加载对应的类到JVM中. 显式加载: 通过loadClass(), forName(),等显式加载需要的类,对于显式加载来讲,当我们生成了对应的Class对象后,就需要用Class对象去调用其newInstance()方法生成对应的类的对象实例,而隐式加载就不需要调用其newInstance()方法也可以获取对象实例. loadClass和forName()的区别 相同点: 对于任意一个类,他们都能在运行时知道该类的所有属性和方法. 对于任意一个对象,都能调用其任意方法和属性. 不同点: 通过看两个方法的源码,我们可以知道: ClassLoader.loadClass(调用该方法只会走到连接那一步,只完成了装载过程的第一步)获取到的对象是还没有连接的,而forName(调用该方法直接走到了装载过程中初始化那一步)获取到的Class对象是已经初始化过的. 类的装载过程(Class对象的生成过程) 加载: 通过ClassLoader的loadClass()加载class字节码文件到内存中,然后将这些静态数据转换为运行时数据区的方法区的类型数据,运行时在内存中生成一个代表这个类的java.lang.Class对象作为方法区中访问该类数据的入口. 连接: 连接过程一共有三步. 校验:检查加载的class文件的正确性和安全性,比如检查class文件格式是否正确. 准备:为 类变量(static变量,随类型信息存放在方法区中) 分配存储空间并设置类变量初始值(默认值,比如String默认为null). 解析(可选):JVM将常量池内的符号引用转换为直接引用. 初始化: 执行类变量赋值和静态代码块.]]></content>
      <tags>
        <tag>JVM面试_3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM面试_2]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F07%2F30%2FJVM%E9%9D%A2%E8%AF%95_2%2F</url>
    <content type="text"><![CDATA[什么是反射? 概念: Java反射机制是指在运行状态下,对于任意一个类,都能够知道这个类的所有属性和方法;对于任意一个对象,都能够调用它的任意方法和属性;这种动态获取信息以及动态调用对象方法的功能称为java的反射机制. 写一个反射的例子 我之前专门写过一篇博客全是例子: 反射案例 类从编译到执行的过程(以Test.java为例) 首先编译器会将.java的源文件编译为.class的字节码文件. ClassLoader将对应Test类的字节码文件转换为JVM中的Class&lt;Test&gt;对象. JVM将Class&lt;Test&gt;对象实例化为Test对象. 谈谈ClassLoader(抽象类)的作用 它在java中有着非常重要的作用,它主要工作在Class装载的加载阶段,其主要作用是从系统外部获取Class二进制数据流. 它是java的核心组件,所有的Class都是由ClassLoader进行加载的,ClassLoader负责通过将Class文件中的二进制数据流装载进系统,然后交给java虚拟机进行连接,初始化等操作. 谈谈ClassLoader的种类 BootStrapClassLoader(启动类加载器): C++编写,加载核心库java.*.(例如java.lang包中的类),负责放在&lt;JAVA_HOME&gt;\lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的类库,用户无法直接使用. Extension ClassLoader(扩展类加载器): java编写,加载扩展库javax.*,它负责&lt;JAVA_HOME&gt;\lib\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库,用户可以直接使用. App ClassLoader(应用程序/系统类加载器): java编写,加载程序所在目录的类,即负责类路径（ClassPath）所指定的类库,用户可以直接使用,如果用户没有自己定义类加载器，默认使用这个. 自定义ClassLoader: java编写,定制化加载. 自定义ClassLoader的实现 关键函数该函数主要用于如何寻找class文件,即根据名称和位置去加载.class字节码文件对象,然后调用defineClass方法去解析定义字节流,然后返回Class对象.顾名思义:这个类就是去定义一个类,我们可以注意到这个方法的参数有一个byte类型的数组,我们读取class字节码文件的时候就是通过byte数组实现的.谈谈类加载器的双亲委派机制 我们从上面的只是可以知道,不同的ClassLoader加载类的路径和方式有所不同,为了实现分工,各自负责各自的区块,使得逻辑更加明确.加载类的时候,肯定会按照自己管理的区域各司其职,所以一定会存在一个机制,让他们之间相互协作,形成一个整体, 这就是双亲委派机制. 原理图如图所示:由上图我们可以知道,当一个class文件要被加载时的加载流程为:1. 首先会去各个类加载器去找,看是否已经加载过这个类,加载过了就不加载了,直接返回,没有加载过就委派给其父加载器,继续往上找,顺序为: 自定义类加载器–&gt;应用程序类加载器–&gt;扩展类加载器–&gt;启动类加载器.2. 如果找到BootStrap ClassLoader了还是没有加载过该类,那么它就会从上往下开始,去看每个类加载器对应的目录的jar包有没有该字节码文件,如果有就加载该文件并返回,如果没有就委派给下一个类加载器去找,如果到自定义类加载器了还没有找到,就报错.为什么要使用双亲委派机制去加载类 能避免多份同样的字节码文件重复加载,不会在内存中有多个同样的Class类对象.&lt;/font+&gt; 以System.out.println为例,实际我们需要的是一个java.lang包下的System的类对象,只需要一份就可以了,如果不用双亲委派机制,那么就会创建多份System的类对象,浪费空间. System.out.println()的含义:System是java.lang包下的一个类out是System类下的一个静态变量,是java.io包下的PrintStream类型的实例对象println()方法是PrintStream类下的一个方法.]]></content>
      <tags>
        <tag>JVM面试_2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM面试_1]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F07%2F30%2FJVM%E9%9D%A2%E8%AF%95_1%2F</url>
    <content type="text"><![CDATA[谈谈你对java的理解 java具有平台无关性: 即可以一次编译,到处运行. jvm具有自动GC功能: 正因为有了GC,我们就不用像C++那样去手动释放内存了. java有自己的语言特性:如泛型,反射,lamda表达式 java是面向对象的(OOP): 即将现实的事物和关系抽象出来变成类,不用在意过程的实现过程,包括了封装,继承,多态. 1234567有一天你想吃鱼香肉丝了，怎么办呢？你有两个选择1、自己买材料，肉，鱼香肉丝调料，蒜苔，胡萝卜等等然后切菜切肉，开炒，盛到盘子里。2、去饭店，张开嘴：老板！来一份鱼香肉丝！看出来区别了吗？这就是1是面向过程，2是面向对象。 java有自己的类库. java有异常处理机制. java的平台无关性如何实现(即Compile Once, Run Anywhere) java程序执行主要分为两个阶段:1. 编译期: 通过javac将源码编译为字节码文件.2. 运行期:字节码文件也就是class文件,其中保存的就是我们java文件翻译成的字节码文件,即java文件中的方法,对象,常量信息等都会被放在字节码文件中, 除此之外,还会添加一个公有的静态常量属性class,这个属性记录了相关的属性信息和类型信息,是class的一个实例,这样我们就可以通过类.class获取其class对象.我们想看class文件,直接通过notepad++这样子的工具打开是乱码,所以我们需要知道javap这个JDK自带的反编译指令,通过这个指令可以查看字节码文件可以通过在命令提示符窗口输入javap-help获取javap指令的帮助信息,其中javap -c 类名是用于对代码进行反编译,可以看到java从字节码文件到机器码文件再到显示执行结果的执行过程.为什么JVM不直接将源码解析成机器码去执行 如果我们不直接将源码转换成机器码去执行,主要有以下原因: 准备工作太多: 每次执行都需要各种检查,效率会比较低(.class文件是编译时已经检查过基本语法等之后生成的文件). 为了实现兼容性,脱离java的束缚: 也可以将别的语言解析成字节码,由JVM进行调用. JVM如何加载.class文件 JVM是一个内存中的虚拟机,也就是说,JVM的存储就是内存. JVM大致架构 ClassLoader(类加载器): 依据特定格式(并不是随便一个class文件都可以加载),加载class文件到内存,它只负责加载,能不能运行就要看Execution Engine了. Execution Engine(解释器): 对命令进行解析,解析完成后就提交到操作系统中去执行了. Runtime Data Area(运行时数据区): JVM内存空间结构模型,我们的代码都会被加载到这里,之后才开始运行. Native Interface(本地方法接口): 它融合了不同开发语言的原生库为java使用,也就是说,实现不是通过java实现的,但是java可以直接调用.]]></content>
      <tags>
        <tag>JVM面试_1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux面试_3]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F07%2F29%2FLinux%E9%9D%A2%E8%AF%95_3%2F</url>
    <content type="text"><![CDATA[如何对文件内容做统计 通过awk指令 语法: awk [options] ‘cmd’ file. 工作原理: 一次读取一行文本,按输入分隔符进行切片,切成多个组成部分. 将切片直接保存在内建的变量中,$1,$2…($0表示行的全部). 支持对单个切片判断,支持循环判断,默认分隔符为空格. 注意awk也是支持管道操作的. 案例: 提前准备了一个文本文件netstat.txt,内容如图:假设我们要获取第一列proto和第四列local address的信息,应该怎么做? awk &#39;{print $1, $4}&#39; netstat.txt,这就表示它会逐行遍历每个内容,然后将netstat文件中每行的内容按照空格切片出来,$1保存的是proto的内容,$4保存的是local address的内容,然后将他俩的内容打印出来即可. 跟操作相关的,都要用花括号括起来,指令都用单引号,字符串都用双引号 假设我们要打印proto为tcp的数据且统计出现的次数,应该怎么做? awk &#39;$1 == &quot;tcp&quot; &amp;&amp; $2 == 1 {print $0}&#39; netstat.txt,表示满足里两个条件之后就输出指定文本中该行的所有数据. 假设我们要打印proto为tcp且recv-q为1的整行的数据同时保留表头,应该怎么做? 借助內键遍历NR即可,表示记录读取的数据的行数.想要读取表头,我们将NR==1即可. awk &#39;($1 == &quot;tcp&quot; &amp;&amp; $2 == 1 ) || NR == 1{print $0}&#39; netstat.txt,这就表示输出的数据要么是第一行(也就是表头),要么就是满足两个条件的数据. 假设我们要统计tcp出现的次数,应该怎么做? grep &quot;tcp&quot; netstat.txt | awk &#39;{restcp[$1]++}END{for(i in restcp)print i &quot;\t&quot; restcp[i]}&#39;,表示先找到文本中符合条件的内容,每行内容再作为标准输入送给awk指令,awk指令中通过名为restcp为名的数组中,结束后遍历数组,打印下标i以及i对于的内容,中间通过制表符连接. awk默认是按照空格来进行切片的,我想自定义分隔符,应该怎么做? 给定test.txt文件,其内容如图所示:awk -F &quot;,&quot; &#39;{print $2}&#39; test.txt, 表示将test.txt中的数据通过,进行切片,同时打印第二个切片变量中的数据,其中-F &quot;,&quot;表示以什么符号来切片行内容. 总结: awk指令很适合做一些格式化的东西 筛选给定文件中某些列的数据,文件可以有多个,有多个文件时,加个空格再在后面接文件名即可. 依据一定条件去筛选给定文件中的数据,然后输出满足条件的数据 对内容逐行去做统计操作,并列出对应的统计结果. 批量替换文件内容 通过sed指令 语法: sed [option] ‘sed command’ filename sed全名stream editor,流编辑器. 适合用于对文本的行内容(awk是对列进行处理)进行处理,适合做文本编辑. 案例: 有这样一个代码文件及其内容如图所示:我们可以注意到:其中Str应该是String,末尾的句号应该是分号,而且中间不应该有那么多空格. 首先,我们先将Str替换为String: sed &#39;s/^Str/String/&#39; replace.java,表示将replace.java中的以Str开头的字符串替换为String.其中,s表示要进行的是字符串的操作,^Str表示以Str开头,第二个反斜杠后面的内容表示将第一个反斜杠的内容替换为什么数据,此例中表示将Str开头的字符串替换为String 注意: 上面的命令只会输出更改后的数据,但是不会真正的修改文本中的数据,要真正的修改文本中的数据,要输入sed -i s/^Str/String/‘ replace.java 然后,我们将末尾的句号替换为分号 sed -i &#39;s/\.$/\;/&#39; replace.java,表示将replace.java文件中末尾的句号替换为分号,其中,\是为了转义,$表示以什么结尾. 如果我们想将Jack的名字换成我们自己的应该怎么做? sed -i s/Jack/Fan/ replace.java,这样子会出现问题,就是还会有一些Jack没有被替换,那是因为这条语句只会替换首次符合条件的字符串,怎么改进呢? sed -i s/Jack/Fan/g replace.java,此时就会全文替换了,g就表示全文替换. 如果我们想删除中间的空行应该怎么做? sed -i /^ *$/d replace.java,此时就表示删除了所有空行.其中,^ *$表示空行,注意*和^中间有个空格,d表示删除符合条件的行,而且只有两个反斜杠. 如果我们想删除包含Integer字段的行应该怎么做? sed -i &#39;/Integer/d&#39; replace.java 总结:将replace.java中以Str开头的字符串替换为String. 将replace.java中的以.结尾的语句换成以;结尾. 将replace.java中的Jack全部替换为me.]]></content>
      <tags>
        <tag>Linux面试_3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux面试_2]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F07%2F29%2FLinux%E9%9D%A2%E8%AF%95_2%2F</url>
    <content type="text"><![CDATA[如何查找特定的文件 通过find指令 语法: find path [options] params作用: 在指定目录下查找文件,任何位于参数前的字符串都将会被当做预查找的目录名.如果不设置任何参数,则find指令将会当前目录下查找子目录及其文件,并且将查找到的子目录和文件全部进行显示. 案例:本文件夹/或其子文件夹中包含一个文件taeget.java,查找到它:find -name &quot;target.java&quot;,然后就会返回target.java的路径—如果其他文件夹中有给文件target.java,那么我该如何进行全局查找:find / -name &quot;target.java&quot;, 然后它就会从根目录开始,一致递归去找该文件,找到了就返回target.java的文件路径了(其中/表示linux的根路径).—如果要查找全部以tar开头的所有文件路径怎么办?find ~ -name &quot;tar*&quot;,其中~表示去当前用户的home目录,`表示可以后面可以跟0个或者多个字符*. --- **如果要查找全部以tar开头(不区分大小写)的所有文件路径怎么办?**find ~ -iname “tar“`,其中iname表示忽略大小写.总结:—如何根据文件名检索文件内容 文本检索就要用到grep指令 grep全称: Global Reqular Expression Print通过全称我们就可以知道–它是支持正则表达式(regular expression)的. 语法: grep [options] pattern file 作用: 查找文件里符合条件的字符串 如果不指定任何文件名称,则grep指令会等待用户输入包含haha的字符串, 例如输入grep &quot;haha&quot;,它就会等待你输入字符串,而且要输入包含haha的字符串之后才会结束,然后返回haha所在行的内容. 案例: 如何实现查找全部文件名以tar开头的且包含mooc内容的所有文件 grep &quot;mooc&quot; tar*就可以找到所有包含mooc的且以tar开头的文件,返回文件名同时会输出目标字符串所在的行的所有内容. 管道操作符 | 的作用 作用: 1. 可将指令连接起来,前一个指令的输出作为后一个指令的输入.前提是前面的输入是正确的标准输入,不然后面的就执行不了,最后输出的时command3里面的数据例子 执行find ~ -name &quot;tar*&quot;,可以找到当前home目录下tar开头的文件. 上述功能也可以通过find ~ | grep &quot;tar*&quot; 其中,|左边的命令表示列出当前home目录下的所有目录及其文件. 我们通过上面的只是可以知道,grep &quot;tar*&quot;表示会从标准输入流里面去查找包含tar开头的字符串,而我们又知道,|就是连接标准输入/出流,所以^^,你懂了吧. |右边就会把左边的标准输出作为标准输入传递到右边,然后你就懂了吧! 使用管道操作符注意的要点:1. 管道命令只能处理前一个命令正确输出,不处理错误输出,|左边的输入错误的话会直接报错.2. 管道命令右边必须是能够接收标准输入流的指令,否则传递过程中数据会被抛弃.3. 常用来接收数据管道的命令有:sed,awk,head,grep,cut, top, less,more,wc,join,sort,split等.如何在指定文件中查找包含指定字符串partial[true]的行 grep &#39;partial\[true\]&#39; data.info.log.表示从data.info.log这个文件里去找包含partial[true]字符串的行,其中由于[]是特殊字符,所以需要转义一下. 如何在指定文件中查找包含指定字符串partial[true]的行,而且只显示符合engin字符串数据 grep &#39;partial\[true\]&#39; data.info.log | grep -o &#39;engine&#39;,-o表示只输出符合后面字符串内容的数据. 同时,我们还可以通过grep -v,去查询不含 指定字符串内容 的字符串. 总结:表示在指定文件中查询包含指定字符串的文本内容. 表示查找包含指定字符串的内容 查询不包含指定字符串的内容.]]></content>
      <tags>
        <tag>Linux面试_2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux面试_1]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F07%2F29%2FLinux%E9%9D%A2%E8%AF%95-1%2F</url>
    <content type="text"><![CDATA[linux的体系结构如图所示: linux体系结构主要分为用户态(用户上层活动)和内核态,当然还有其他的哈,就是图片中的那些.下面就图片中的各个部分进行讲解内核: linux启动的时候,首先会启动内核,其本质是一段计算机程序,这个程序直接管理计算机硬件设备的程序,包括CPU,内存,硬盘接口,网络接口等.所有的计算机操作,都要通过内核传递给硬件 用户态: 即上层应用程序的活动空间,应用程序的执行必须依托于内核提供的资源(比如CPU,IO等).系统调用: 为了使上层应用能够访问到这些资源,内核必须为上层应用提供访问的接口,即系统调用,这是一种不能再简化的操作,类似于原子操作.一个操作系统的功能,可以看作是系统调用的主核的效果,而且一个操作系统不可能做出超越系统调用的动作 ,比如说,给某个变量分配内存空间,就必须要调用很多的系统调用.由于系统调用非常基础,所以使用起来很麻烦,比如给某个变量分配空间就会有很多操作,程序员就不用活了,此时,就产生了公共函数库 公共函数库: 系统调用的组合拳,将程序员从复杂的细节中解脱出来,它实现了对系统调用的封装,将简单的业务逻辑接口呈现给用户,方便用户调用,极大地增强了程序设计的灵活性.对于简单的操作,我们可以直接调用系统调用来访问资源,对于复杂的操作,我们通过公共库函数来实现. Shell 它就是一个特殊的应用程序,本质上是一个命令解释器(类似于cmd的命令行窗口),它下通系统调用,上通各种应用,通常充当着一种胶水的角色来连接各个小功能程序,在没有图形界面之前,shell充当着用户界面,当用户要执行某些操作的时候,通过shell输入命令进行操作. 它是可编程的,它可以执行符合shell语法的文本(shell脚本),通常几行shell脚本语句就可以实现很强大的功能,因为shell语句一般都对系统调用做了一层封装,]]></content>
      <tags>
        <tag>Linux面试_1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis面试_5]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F07%2F28%2FRedis%E9%9D%A2%E8%AF%95_5%2F</url>
    <content type="text"><![CDATA[使用PipeLine的好处 Pipeline和linux的管道类似,Redis从文本中读取数据到内存的时候,就用到了Pipline. Redis基于请求/响应模型,单个请求处理需要一一应答. 正常情况下,客户端发送一个命令就要等待redis的应答,要是有很多请求,要等前面的执行结束才能执行下一个,这样效率会很低. Pipeline批量执行指令,节省多次IO往返的时间,即允许客户端同时发送多条请求,不用等着上一条请求处理结束才能发送下一次请求.客户端首先会将要执行的命令存入缓存中,之后再一次性发送给Redis 有顺序依赖的指令建议分批发送. Redis的同步机制 主从同步原理如图所示,一般都是一个Master(主服务器)进行写操作,多个slave(从服务器)进行读操作.按照同步内容的多少可以分为全同步和增量同步.全量同步过程 slave发送sync命令到master. master启动一个后台进程,将Redis中的数据快照保存到文件中(也就是BGSAVE的过程). master将保存数据快照期间接收到的写命令(也就是增量数据,注意其实不只保存写命令到AOF,只是一般都是写命令,所以习惯性就叫写命令,更新语句都会保存)缓存起来. master完成第二步的写文件操作后,将该文件发送给slave. slave接收到文件后,就将文件保存到磁盘中,使用新的AOF文件替换掉旧的AOF文件,然后加载文件到内存中恢复数据快照. master将这期间收集的增量写命令发送给slave. 全量同步完成后,后续的所有写操作都是在master上进行,所有读操作都是在slave上进行. 增量同步过程 master接收到用户的操作指令(增删改指令),执行操作函数判断是否需要传播到slave. 将操作记录追加到AOF文件(将操作转换为Redis内部的协议格式,并以字符串的形式存储). 将操作传播到其他slave,包括两步: 首先对齐主从库,确保从数据库是该操作对应的数据库. 往响应缓存写入指令,即将命令和参数按照redis的协议格式写入到响应slave的缓存中 将缓存中的数据发送给slave. 主从模式的弊端,就是不具备高可用性,当msater宕机之后,redis就不能对外提供写入操作了,这就有了Redis哨兵 Redis Sentinel 用于解决主从同步master宕机后的主从切换问题. Redis哨兵是官方提供的集群管理工具,其本身就是一个独立运行的进程,他能监控多个master-slave集群,发现master宕机之后,能进行自动切换.其主要功能有如下几点: 监控: 检查主从服务器是否运行正常. 提醒: 通过API向管理员或者其他应用程序发送故障通知. 自动故障迁移: 主从切换,即当一个服务器不能正常工作时,哨兵就会开始一次自动故障迁移操作,将失效的master下的一个slave升级为master.]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>Redis面试_5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis面试_6]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F07%2F28%2FRedis%E9%9D%A2%E8%AF%95_6%2F</url>
    <content type="text"><![CDATA[Redis集群相关问题 如何从海量数据里快速找到所需? 方法1–分片: 可以按照某种规则,对海量数据进行划分,将其分散存储在多个Redis节点上.这种规则通常就是获取key的哈希值,然后根据节点数求模,然后根据结果决定放在哪个节点 这种方法有明显的弊端: 当我们动态的增加或者减少节点的时候,会造成大量的key无法被命中,即常规的哈希划分无法实现节点的动态增减. 为此,Redis提出了一致性哈希算法 方法2:一致性哈希算法 对2^32取模,将哈希值空间组织称虚拟的圆环,称为哈希环. 将各个服务器使用相同的哈希算法去进行哈希的变换,可以选择服务器的ip或者主机名进行哈希,然后根据值确定其在哈希环上的位置. 将数据key使用和服务器哈希时相同的函数Hash计算出哈希值,然后根据值确定此key在哈希环上的位置,然后沿着环顺时针走,将数据存放在第一台遇到的服务器上,也就是目标服务器.这样做的好处就是: 假设C节点宕机,A,B,D节点并不会受到影响,此时新增的本来要加载到C节点里的数据会跑到D节点里面去. 一致性哈希算法的问题 哈希环的数据倾斜问题: 一致性哈希算法,在节点值比较少的时候,容易因为节点不均匀,而导致很多数据都会被缓存到为数不多的服务器上,造成服务器分配严重不均匀. 引入虚拟节点解决数据倾斜问题 虚拟节点机制是指对每个服务器节点计算多个哈希,计算出来的位置都放在哈希环中作为虚拟节点,然后 让虚拟节点映射到真正的服务器节点上就行,可以通过在服务器ip或者主机名后面增加编号来实现.]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>Redis面试_6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis面试_4]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F07%2F28%2FRedis%E9%9D%A2%E8%AF%95_4%2F</url>
    <content type="text"><![CDATA[AOF持久化 AOF(Append-Only-File)持久化: 保存Redis服务器所执行的写状态来记录数据库,默认是关闭的,且其文件名为appendonly.aof.可以通过conf set appenonly yes使得AOF持久化生效,也可以去配置文件中修改.RDB持久化相当于备份数据库状态,而AOF持久化是备份数据库接收到的指令,所有被写入AOF的命令都是以Redis的命令格式来保存的. 1. 记录下除了查询以外的所有变更数据库状态的指令. 2. 以append的形式追加保存到AOF文件中(增量).appendfsync配置 AOF持久化的appendfsync配置,相当于RDB持久化的SAVE m n配置 一共有三种配置方式: appendfsync everysec(默认): 表示每隔一秒就将数据写入到AOF文件中. appendfsync always: 表示一旦缓冲区的内容发生变化,就总是及时的把缓冲区的内容写入到AOF文件中. appendfsync no: 表示将数据写入AOF的操作交给操作系统来决定,一般都会等缓冲区填满才写入到内存中去. AOF文件不断增大的解决办法 比如当我们从0加到100,我们其实只需要保存最后一个值就可以了,但是AOF会记录下所有的运算记录,这就可以用到日志重写. 日志重写解决了AOF文件大小不断增大的问题,同样用到了写时复制,其原理如下: Redis调用fork()函数,创建一个子进程. 子进程把新的AOF文件(当前内存中的数据,不读取原来文件中的数据)写到一个临时文件里,不依赖原来的AOF文件. 主进程持续将新的变动同时内存和原来的AOF里. 主进程获取子进程重写AOF的完成信号,往新的AOF同步增量变动(也就是将步骤3中内存中的buffer数据追加到AOF文件中) . 使用新的AOF文件替换掉就得AOF文件. 日志重写可以手动触发,也可以自动触发 手动触发: 通过执行BGREWRITEAOF指令触发aof重写. 自动触发: 忽略了,不怎么考,我就懒得记,大家百度一哈子. Redis数据的恢复 RDB和AOF共存情况下的恢复流程由图可知,Redis服务器启动时,会先检查是否存在AOF文件如果存在,就直接加载AOF文件,忽略RDB文件;如果不存在,就尝试加载RDB文件.RDB和AOF的优缺点 RDB优点: RDB文件本质上是一份内存快照,保存了创建RDB文件那个时间点的Redis全量数据,文件小,恢复快. RDB缺点: 由于RDB保存的是某个时间点的快照数据,所以无法用来保存RDB创建后的增量数据. AOF优点: AOF文件本质上是一份执行日志,保存了所有对Redis进行更改的指令,可读性高,适合保存增量数据,数据不易丢失. AOF缺点: 文件体积大,恢复时间长. Redis通过RDB-AOF混合模式实现持久化(目前比较推荐的方式) 混合模式持久化在Redis4.0版本以后开始支持并且作为了默认配置,结合两者优点,既可以进行全量备份,也可以保存增量. 混合模式持久化过程: 先以RDB格式写入全量数据,然后子进程通过管道从父进程获取增量数据并缓存下来到AOF文件中. 这样既可以提高重写恢复速度,也可以减少文件大小, 同时还可以保证数据的完整性. 这样之后,AOF文件是RDB格式的全量数据,后半段是Redis命令格式的增量数据. RDB-AOF混合模式持久化总结 通过BGSAVE做镜像全量持久化,AOF做增量持久化,在Redis服务器重启时,就可以完整恢复之前的状态了.]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>Redis面试_4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis面试_2]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F07%2F28%2FRedis%E9%9D%A2%E8%AF%95_2%2F</url>
    <content type="text"><![CDATA[Redis供用户使用的几种数据类型(针对k-v结构中的value) 注意: Redis存储的时key-value键值对格式,其中key永远是字符串,value值可以有多重不同的数据结构同时,不论value是什么类型,它里面的数据都是字符串类型 String: 最基本的数据类型,二进制安全(可以存二进制的东西,比如图片等),也就是说可以存很多东西. Hash: String元素组成的字典,适合用于存储对象. List列表: 按照String元素插入顺序排序,可以当做队列使用. Set集合: String元素组成的无序集合,通过哈希表实现,不允许重复. Sorted Set:通过分数(自己给的,可以重复)来为集合中的成员进行从小到大的排序. 关于基本数据类型我之前写过一篇博客: redis的基本用法. 问题1: Redis从海量key里查询出某一固定前缀str的key 留意细节: 摸清数据规模,即问清楚边界.解法1: 如果我们直接回答使用keys指令(keys str*)来扫描出指定模式的key列表的话,会出问题.如果面试官继续问你:该redis正在给线上的业务提供服务,那使用keys指令会有什么问题?会卡成皮皮虾解法2(正确指令):我们可以使用scan指令,实现无阻塞的提取出符合指令模式的key列表.它每次执行只会返回少量元素,所以可以用于生产环境,不会像keys指令那样会卡.使用keys对线上的业务的影响 KEYS pattern: 查找所有符合给定模式pattern的key. 它有如下缺点: keys指令会一次性返回所有匹配的key,当数据量很大时就很慢. 键的数量过大会使服务卡顿. SCAN指令 命令格式: SCAN cursor [MATCH pattern][COUNT count]. 其中,cursor表示游标,MATCH括号里就是我们要查找的模式了,就比如上面的str*,COUNT括号就表示希望每次返回的数量. SCAN指令是基于游标的迭代器,需要基于上一次的游标延续之前的迭代过程. 当SCAN的游标参数cursor被置为0的时候,那么它会开始一次新的迭代,即SCAN指令是以0为游标开始直到命令返回游标0完成一次遍历. SCAN指令并不保证每次执行都返回给定数量的元素,支持模糊查询. 一次返回的数量不可控,只能大概率符合count参数. SCAN指令获取到的元素有可能重复,所以外部需要去重. 问题2: 如何通过Redis实现一个分布式锁 集群：多个人在一起作同样的事 。 分布式 ：多个人在一起作不同的事 。 分布式锁:是分布式系统或不同系统之间共同访问一个共享资源的一种锁的实现,如果不同系统或同一个系统的不同程序之间共享了某个资源时,往往需要互斥来防止彼此干扰,进而保证一致性. 分布式锁需要解决的问题: 互斥性: 即任意时间只能有一个客户端获取锁,不能同时有多个客户端获取了锁. 安全性: 锁只能被持有该锁的客户端删除,不能被其他客户端删除. 死锁: 如果获取锁的客户端因为某些原因宕机导致未能释放锁,那么其他客户端就再也无法获取到该锁,导致了死锁. 容错: 当部分节点,比如一些redis节点宕机的时候客户端依然能够获取锁和释放锁. 答案:1. 通过SETNX指令加锁,其命令行格式为:SENTX key value, 如果key不存在,则创建锁并赋值.其时间复杂度为O(1).返回值: 设置成功返回1,设置失败返回0.例如(给key为locknx的资源加锁并赋值为test):setnx locknx test // 返回1setnx locknx task// 试图将locknx改为task,返回0,修改失败.get locknx //test2. 给setnx设置一个过期时间,其命令行格式为: EXPIRE key seconds,设置key的生存时间,当key过期时(生存时间为0),会被自动删除.例如(给key为locknx的资源设置超时时间为20秒):expire locknx 20 // 20秒后就可以重新对locknx设置值了.上述两个操作会出现问题,比如说可能会加锁之后程序出错了,执行不到过期的指令,就会导致死锁3. 上述的两个操作在redis2.6.12版本开始,就可以通过一条指令执行了,这就解决了上面的问题.命令行: SET key value [EX seconds] [PX milliseconds] [NX | XX]其中:EX seconds用于设置键的过期时间为second秒.PX milliseconds用于设置键的过期时间为milliseconds毫秒.NX表示只有当键不存在时,才对键进行设置操作,此时效果等同于setnx.XX表示只在键已经存在时,才对键进行设置操作.SET操作成功完成时,返回OK,否则返回nil此时就满足了分布式锁的原子性需求(要么都提交,要么都不提交)如果大量key同时过期的注意事项:如果大量的key过期时间相同,由于清除大量的key很耗时,会出现短暂的卡顿现象.解决方案:在设置key的过期时间的时候,给每个key的时间上加上一个随机值,这样清除key的时间节点就会比较分散,就可以很大程度上避免卡顿现象的发生.如何使用Redis做异步队列首先,我们应该想到使用List作为队列,RPUSH生产消息(往右侧添加),LPOP消费消息(从左边弹出).例如:rpush testList aaarpush testList bbbrpop testList // aaa缺点:没有等待队列里有值就直接消费,即有可能list中没有值但是却会执行弹出指令,此时会立刻返回nil.弥补办法1:可以通过在应用层引入sleep机制,适当sleep之后再去去调用LPOP重试.弥补办法2:使用BLPOP指令.其格式为: BLPOP key [key …] timeout: 没有消息的时候会阻塞队列,直到队列有消息(当在阻塞时消息进来后就会输出消息并停止阻塞)或者超时.使用BLPOP/LPOP指令的优缺点: 缺点: 生产的消息只能提供一个消费者消费,即BLPOP/LPOP之后就没了,能不能实现生产一次,供多个消费者消费呢?. 答案是肯定的–通过redis的pub/sub主题订阅者模式 pub/sub主题订阅模式 它可以实现一对多的消费队列. 发送者(pub)发送消息,订阅者(sub)接收消息. 订阅者可以订阅任意数量的频道(topic),当频道中生产消息之后,订阅者都会收到消息. pub/sub的缺点 消息的发布是无状态的,无法保证该消息是否被接收到.解决这个问题就要使用专业的消息队列,例如kafka等.]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>Redis面试_2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis面试_3]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F07%2F28%2FRedis%E9%9D%A2%E8%AF%95_3%2F</url>
    <content type="text"><![CDATA[因为我们知道,如果不进行数据的持久化,一旦服务器退出,数据就会丢失掉. 持久化方式之RDB RDB(快照)持久化: 保存某个时间点的全部数据快照到dump.rdb文件中. 其中,快照, 可以理解为拍照一样，把整个内存数据映射到硬盘中，保存一份到硬盘，因此恢复数据起来比较快，把数据映射回去即可. RDB的创建命令(手动)1. SAVE(很少用): 阻塞Redis的服务器进程,直到RDB文件被创建完毕,创建结束后会发送OK信号,这个很少被使用是因为SAVE指令是在主线程中保存快照的,而Redis是通过一个主线程来处理所有的请求的,这种方式会阻塞所有请求2. BGSAVE: Fork(派生)出一个子进程来创建RDB文件,不阻塞服务器进程,父进程继续处理接收到的命令,子进程完成文件的创建后会发送OK信号给父进程(即Redis主进程).我们可以通过last save指令查看操作是否成功(里面记录了上一次成功执行SAVE/BGSAVE的时间).自动化触发RDB持久化的方式 根据redis.conf配置里的SAVE m n定时触发(通过BGSAVE方式),即m秒内数据集存在n次修改时，自动触发BGSAVE. 主从复制时候,主节点自动触发(主节点发送RDB文件给从节点进行复制操作). 执行Debug Reload. 执行Shutdown且没有开启AOF持久化. BGSAVE原理注意:1. 当执行BGSAVE指令后,它会首先检查有没有正在执行的AOF/RDB子进程,有就直接返回错误.2. 其实调用BGSAVE指令生成RDB文件就是通过调用操作系统的fork()方法: 其作用就是创建进程(传统方式下,fork函数创建子进程时会直接把全部资源复制给子进程,这种实现方式简单但是效率很低,而在linux下它做了改进,实现了Copy-on-Write写时复制)Copy-on-Write写时复制 如果有多个调用者同时要求相同的资源(比如说内存或者磁盘上的数据存储),他们会共同获取相同的指针指向相同的资源,直到某个调用者试图修改资源的内容时,系统才会真正复制一份专用副本给调用者(资源修改后会更新指针),而其他调用者所见到的最初的资源仍保持不变. Redis持久化 当Redis需要做持久化时,Redis会fork一个子进程,子进程将数据写到磁盘上一个临时的RDB文件中,当子进程完成临时文件的写入之后,就将原来的RDB文件给替换掉,这样也就相当于实现了写时复制缺点: 每次快照持久化都是将内存数据完整的写入到磁盘,由于是内存数据的全量同步,数据量大会由于大量的I/O操作而影响性能. 由于快照方式是在一定间隔时间做一次,可能会因为Redis宕机而丢失从当前至最近一次快照期间的数据,如果要求不能丢失任何修改的话可以采用AOF持久化.]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>Redis面试_3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis面试_1]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F07%2F28%2FRedis-1%2F</url>
    <content type="text"><![CDATA[主流应用架构缓存中间件–Memcache和Redis的区别 Memcache(我这个是直接看别人复制过来的,没怎么见过这个中间件,所以就没管): 1. 它非常简单易用,代码层次类似于Hash. 2. 它支持简单数据类型. 3. 不支持数据持久化存储,一旦服务器宕机,数据保存不下来的. 4. 不支持mysql那样的主从同步. 5. 不支持分片.Redis 数据类型丰富,支持set.list等类型. 支持数据磁盘持久化存储. 支持主从同步. 支持分片. Redis为什么能这么快 他们说可以达到十万+的QPS(QPS即query per second,每秒查询次数). Redis完全基于内存,绝大部分请求纯粹是内存操作,不会受到硬盘,IO等的线坠,执行效率高,Redis采用的是单进程-单线程的K-V数据库,C语言写的. 数据结构简单(key-value结构,类似于哈希表),对数据操作也简单,Redis不使用表,它的数据库不需要预定义或者强制要求用户对Redis存储的不同数据进行关联. 采用单线程,单进程也能处理 高并发(注意区分并行) 请求,想多核也可以启动多实例. 并发和并行的区别:并发的关键是你有处理多个任务的能力，不一定要同时。并行的关键是你有同时处理多个任务的能力。 例如:你吃饭吃到一半，电话来了，你一直到吃完了以后才去接，这就说明你不支持并发也不支持并行。你吃饭吃到一半，电话来了，你停了下来接了电话，接完后继续吃饭，这说明你支持并发。 （不一定是同时的）你吃饭吃到一半，电话来了，你一边打电话一边吃饭，这说明你支持并行。 4. 使用多路复用I/O复用模型,即非阻塞IO,因为Redis是跑在单线程的,所有的操作都是按照顺序线性执行的,但是由于读写操作,等待用户输入输出这些都是阻塞的,所以IO操作一般情况下往往不能直接返回,就会导致某一文件的IO阻塞,进而导致某个进程无法对其他客户端提供服务,而I/O多路复用就是为了解决这个问题而出现的.FD: File Descripter, 文件描述符.在操作系统中,一个打开的文件通过唯一的描述符进行引用,该描述符是打开文件的元数据到文件本身的映射.传统的阻塞I/O模型当使用read或者write对某一个文件描述符进行读写时,如果当前FD不可读或者不可写,整个redis服务就不会对其他的操作做出响应,这就会导致整个服务不可用,所以,在需要处理多个客户端任务的时候,往往都不会使用阻塞模型,所以需要一种更高效率的IO模型来支持Redis的高并发处理,这就用到了多路I/O复用模型.多路复用I/O复用模型 Select系统调用select()可以同时监控多个文件描述符的可读,可写情况,当其中的某些文件描述符可读或者可写时,select()方法就会返回可读/可写的文件描述符个数也就是说,select是负责监听文件是否可读或者可写的,那监听的任务交给select之后呢,我们的线程又可以继续去做别的事情而不会被阻塞了.Redis采用的I/O多路复用函数: epoll/kqueue/evport(linux中)/select这么多多路复用函数,那么Redis具体用哪个呢?1. 因地制宜,因为redis需要在多个平台上运行,同时为了最大化的提高执行效率和性能,所以会根据编译平台的不同,选择不同的复用函数.2. 优先选择时间复杂度为O(1)的I/O多路复用函数作为底层实现.3. 以时间复杂度为O(N)的select作为保底.4. 基于react设计模式监听I/O事件.]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>Redis面试_1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库考点_6]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F07%2F25%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E8%80%83%E7%82%B9_6%2F</url>
    <content type="text"><![CDATA[MyISAM和InnoDB关于锁方面的区别是什么 MyISAM默认使用的是表级锁,不支持行级锁. InnoDB默认使用的是行级锁,也支持表级锁. 下面的东西针对于MyISAM引擎: 什么是表级锁 举例: 前提: 我当前有一张表student,使用的是MyISAM引擎. 我们在这里模拟一个并发操作哈: 当我们对表进行查找操作的时候,倘若我们在查找操作还没有结束,还在执行的过程中去执行一个修改操作,我们会发现 只有当我们的查询操作结束后,才会执行我们修改操作的指令. 这是因为我们在执行查询语句的时候,MyISAM自动地给我们的student表上了一个表锁,也就是说,它会锁住这张表,不允许此时其他对表的更新操作(增删改) 其实是这样子的: 当我们对数据库表使用查询语句select的时候,它会为该数据库表加上一个 表级的读锁 当我们对数据库表进行增删改的时候,它会自动为该数据库表加上一个表级的写锁 当我们的查询操作还没有执行结束,即读锁还没有被释放的时候,我们去执行增删改操作,这时MyISAM会给数据库表添加写锁,但是读锁还没有释放,所以添加写锁的操作就会被阻塞,直到所有的读锁都被释放为止. 如何显式地给数据库表添加表级锁 添加读锁: LOCK TABLES 表名 READ; 添加写锁: LOCK TABLES 表名 WRITE; 释放锁: UNLOCK TABLES; 读锁也叫作共享锁: 即我并发的同时执行两个读取操作(执行查询语句会自动添加写锁),两个读操作不会有影响(也就是说支持同时上两个共享锁),不会像更新操作那样要等一个执行结束才执行另一个. 写锁也叫作排它锁: 即我并发的同时执行两个更新操作(更新操作会自动添加写锁),要等先执行的那一个执行结束,释放了写锁后,执行另一条更新语句才会被执行,此时数据库表再次被加上一个写锁. MyISAM引擎注意事项: 一个数据库表同一时间只能上一个锁. 它只支持表级锁,不支持行级锁,也就是说,它会锁住整张表. 它不支持事务管理,所有对数据库的操作都会直接影响数据库的数据. 支持同时上多个共享锁,即可以多次读取,互相不影响,但是如果先上的是排它锁,那么其他的任何操作都是不允许的,必须等排它锁被释放才可以. 我们也可以为查询语句加上排它锁: 例如:当执行了select * from user where id between 1 and 200000 for update语句后,user表就被添加了排它锁,此时,我们在该查询语句没有结束前再并发地执行另一条查询语句的话,那么另一条查询语句就只能等之前的查询语句执行结束后释放了排它锁之后才能执行. 下面的东西针对于InnoDB引擎: 上面的共享锁和排它锁在InnoDB中也有,效果也一样(比如加了共享锁不能加排它锁啊,可以同时加共享锁啊这些都一样),不过还是有些许差别(比如select语句不自动加共享锁等). InnoDB支持事务管理,MySQL默认自动提交事务,而且只有当前事务commit了之后,锁才会被释放. 例子:我们同时对一个表进行两次更新操作,我们会发现,两次更新操作是互不影响的,这如果在MyISAM引擎中是不应该发生的. 这种情况主要是因为,InnoDB使用的是二段锁. 什么是二段锁 二段锁也就是说: 加锁和解锁是分成两个步骤来进行的,即先对同一个事务里的一批操作分别加锁,然后在提交commit的时候,再对事务里加上的锁进行统一的解锁. 由于mysql默认自动提交,所以看起来和MyISAM没啥区别. 几条mysql命令 查看自动提交的状态: SHOW VARIABLES LIKE ‘autocommit’ 关闭自动提交: SET autocommit = 0; 打开自动提交: SET autocommit = 1; 手动添加排它锁: select * from person where id = 3 for update; 手动添加共享锁同时验证行级锁: select * from person where id = 3 lock in share mode; 执行上面的语句之后,就表示给id=3的那一行添加了共享锁,此时我们对id=3的那一行进行更新操作会被阻塞,只有当我们对当前事务进行了提交(共享锁被释放)之后,更新操作才会进行.但是,如果我们是并发的对id=4(只要不等于3就行)进行增删查改操作的话,丝毫不会受到影响,这就说明InnoDB默认支持行级锁 InnoDB中对select语句进行了特殊处理 例子如下:我们将数据库设置为不自动提交后 如果我们对数据库中某行进行查询操作,它会自动添加共享锁然后我们并发的对该行进行更新操作,我们发现更新操作不受查询操作的影响,amazing!这就是因为InnoDB中对select语句进行了改进,使得select没有对该行上锁,所以才导致更新是成功的,这个我之后再写 小知识 当用到表级锁的时候,只要操作了表里的数据,表都会被锁住,所以表级锁与索引无关. 当查询语句用到了索引的时候,用的时行级锁,即只对操作的这一行加锁,对其他行的操作不会有影响. 当查询语句不走索引的时候,用的是表级锁. MyISAM使用的是非聚簇索引(索引保存数据文件的指针和数据分开放,主键索引和辅助索引都可以直接拿到数据,在纯检索,即增删改很少的系统中性能比InnoDB要好),InnoDB有且仅有一个聚簇索引(数据文件和索引放在一起的,必须要有主键,通过主键索引效率很高,但是当用到辅助索引的时候需要查两次,) 不论是表级锁还是行级锁,都分为共享锁和排它锁. 共享锁简写是S,排它锁简写是X,这都是针对于行的行级锁. 意向共享锁IS,意向排他锁IX,这是InnoDB针对于表的表级锁. 是不是行级锁一定比表级锁要好? 不是的 因为锁的范围越小,代价越高,相比于表级锁在表的头部直接加锁来讲,行级锁还要扫描到某行然后对其上锁,代价比表级锁大多了 同时InnoDB支持事务,相比于MyISAM也带来了更大的开销.]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>数据库考点_6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库考点_5]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F07%2F25%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E8%80%83%E7%82%B9_5%2F</url>
    <content type="text"><![CDATA[联合索引 什么是联合索引:即由数据库的两列及以上组成的索引.最左匹配原则 最左匹配原则举例: 前提条件: 我们将a和b两列设置为联合索引,且a在前,b在后. 当我们在where语句中调用where a= x and b = y(x,y为任意数值)的时候,它就会走这个联合索引. 当我们在where语句中调用where a= x (x为任意数值)的时候,它也会走这个联合索引. 但是,当我们在where语句中调用where b = y (y为任意数值)的时候,它就不会走这个联合索引,而是去全文搜索. 什么是联合索引的最左匹配原则: 最左匹配原则,又叫最左前缀匹配原则,这是一个非常重要的原则. 1.其定义为: mysql在执行查询语句过程中,对于查询的where条件为联合索引时,它会一直向右匹配直到遇到范围查询(&lt;, &gt;, between, like)就停止匹配. 比如: 现有一个(a,b,c,d)顺序的联合索引,当查询条件为a=3 and b=4 and c&gt;5 and d=6时, d是用不到索引的(也就是说这样子就用不到联合索引了),如果建立顺序为(a,b,d,c)的索引(abd的顺序随便调,反正c在最后就可以)则都可以用到,那么就会用到我们的联合索引了. where语句中有=和in的话,用到=和in的联合索引的字段可以任意顺序,反正都会用到. 比如:当查询条件为a=1 and b=2 and c=3时,(a,b,c)三个字段创建的联合索引顺序可以任意调整,不需要a一定在前,b在第二个这样子,mysql的查询优化器会帮你把sql语句优化成索引可以识别的形式,也就是会帮你调整sql语句中字段的顺序来保证和联合索引字段顺序匹配.反正你不用管就行了. 联合索引的最左匹配原则的成因mysql创建联合索引的时候:首先会对联合索引中 最左边的索引字段(也就是第一个索引字段)进行排序;然后在第一个索引字段排好序的基础上再去对第二个字段排序,这样依次类推…所以,第一个字段是绝对有序的,第二个字段不一定是我们想象的那种有序(比如小的在前面,大的在后面),因此当我们直接用后面的字段进行条件判断是用不到索引的也就是说,它是根据第一个索引字段去建立B+Tree的,第二个第三个字段等都是直接跟在第一个字段后面的,所以你把后面的索引作为条件的话,实际上是没得B+Tree给你查找的这就是mysql为什么要强调最左匹配原则的原因几条mysql命令1. 创建普通索引(和创建联合索引一样):CREATE INDEX 索引名 ON 表名(字段名);ALTER TABLE 表名 ADD INDEX 索引名(字段名);2. 创建唯一索引:CREATE UNIQUE INDEX 索引名 ON 表名(字段名);ALTER TABLE 表名 ADD UNIQUE 索引名(字段名);3. 创建主键索引:创建表的时候直接设置为主键或者用下面的语句;ALTER TABLE 表名 ADD PRIMARY KEY(字段名);4. 创建联合索引:用book表中的name和title字段为例创建联合索引:CREATE INDEX name_title ON book(title,name);alert table book add INDEX name_title (title,name);5. 删除索引:DROP INDEX 索引名 ON 表名;6. 查看所有数据库:SHOW DATABASES;7. 查看所有表:SHOW TABLES;8. 查看表结构:DESC 表名;9. 查看表的创建语句:SHOW CREATE TABLE 表名;索引是建立的越多越好吗? 肯定不是的 数据量小的表不需要建立索引,建立会增加额外的索引开销,就好比我看试卷,总共就几页,难道我还会去看目录嘛一样的道理. 数据变更(比如增删查改)需要维护索引,因为更多的索引意味着更多的维护成本. 更多的索引也意味着更多的空间,就好比一百页的内容,我目录就有50页,书平白无故厚了一沓,读个鬼]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>数据库考点_5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库考点_4]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F07%2F25%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E8%80%83%E7%82%B9_4%2F</url>
    <content type="text"><![CDATA[如何定位并优化慢查询sql(慢查询语句只会是DML,数据操作语言) 这个问题属于开放性的题目,具体场景需要具体分析,这里给个大致思路 根据慢日志定位慢查询sql. 使用explain等工具分析sql. 修改sql或者尽量让sql走索引. 1. 根据慢日志定位慢查询sql 慢日志的作用就是用来记录执行速度比较慢的sql语句. 首先我们先看看慢日志变量的状态及相关信息 连接数据库后,输入图中的语句show VARIABLES LIKE &#39;%quer%&#39;对变量进行模糊查询,就可以看到慢日志--&gt;slow_query_log,也就是我圈出来的部分.慢日志默认是关闭的. 通过图我们可以看到还有一个变量,名为long_query_time,其值默认为10秒,这就表示如果执行这个sql语句花费了超过十秒,它就会被记录到慢日志之中. 然后我们再来看看系统中慢日志的状态,输入语句:SHOW STATUS LIKE ‘%slow_queries%’进行模糊查询即可看到当前慢查询语句的数量 修改慢日志的设置 打开慢日志功能: SET GLOBAL slow_query_log = on; 去数据库的配置文件my.ini中修改慢查询时间为1秒,这样执行超过1秒的语句也会被记录在慢日志中了. 2. 使用explain等工具分析sqlexplain在分析查询语句很有用,一般放在select关键字前面explain主要用于描述mysql如何执行查询操作,即mysql的执行计划.注意: 添加了explain关键字以后,sql语句并没有真正的执行,只是返回了mysql的执行计划例如(用的别人的例子):emmm,我就不去说所有的字段了哈,网上有,我懒得记,等面试问到了我再来看,这里重点说几个字段: 1. rows:这一列是mysql估计要读取并检测的行数，注意这个不是结果集里的行数 2. tyoe:它表示mysql找到需要数据行的方式,其性能依次从最优到最差分别为：system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL其中index和ALL表示走的是全表扫描当我们发现如果某条语句是慢查询语句**或者**type值为index/all,那么就说明这条语句是可以优化的.3. extra:写的是一些额外信息,辅助我们了解该语句的执行,它的字段也非常的多,这里写两个很有可能需要被优化的字段,如图: 3. 修改sql或者尽量让sql走索引 这是当我们出现慢查询语句的时候的两种可选的解决办法,可以给查询的字段加索引或者使用其他索引查询]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>数据库考点_4</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2Ffanfan999.github.io%2F2019%2F07%2F25%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E8%80%83%E7%82%B9_3%2F</url>
    <content type="text"><![CDATA[这篇文章加了很多我的理解哈,反正网上的千篇一律,一股脑的写上我感觉也没怎么自己思考,要是有大佬看到哪里有错多谢大佬指正!!!! 写在前面我自己理解的点: - 我的理解是:密集索引和稀疏索引和下面写的聚簇索引和非聚簇索引一样,只是索引的一种具体存储方式(怎么说呢,就是理解为B+Tree怎么具体存储的吧这样子),他们都不是索引的类型. - 针对于mysql而言,密集索引/稀疏索引 == 聚簇索引/非聚簇索引密集索引 定义:叶子节点保存的不只是键和值，还保存了位于同一行记录里的其他列的信息，由于密集索引决定了表的物理排列顺序，一个表只有一个物理排列顺序，所以一个表只能创建一个密集索引稀疏索引 定义:叶子节点仅保存了键位信息以及该行数据的地址，有的稀疏索引只保存了键位信息及其主键对于稀疏索引,定位到叶子节点之后,仍然需要通过地址或者主键信息进一步定位到数据 密集索引和稀疏索引的区别 密集索引文件中的每个搜索码值都对应一个索引值. 稀疏索引文件只为索引码的某些值建立索引项.针对mysql的具体分析 mysql有两种主要的存储引擎: MyISAM: 它不管是主键索引,唯一索引还是普通索引或是全文索引,都是稀疏索引. InnoDB:它有且仅有一个密集索引. InnoDB的索引选取规则 1. 如果定义了一个主键,那么该主键则作为密集索引而存在. 2. 如果没有定义主键,那么该表的第一个唯一非空索引则作为密集索引. 3. 若不满足以上条件,InnoDB内部会生成一个隐藏主键(该主键会被作为密集索引,这个主键是一个6个字节的列,该列的值会随着数据的插入而自增). 4. 也就是说,InnoDB必须有一个主键,而且该主键作为密集索引存在.聚簇索引和非聚簇索引 如图所示(注意聚簇索引和非聚簇索引只是索引存储的两种方式,不是索引的类型哈): 聚簇索引:可以理解为通过拼音的首字母查字典,a开头的汉字一定在f开头的汉字的后面,也就是说,首字母和汉字所在的位置是一一对应的,首字母在前的,汉字也在前这样子理解,对比上面的密集索引,是不是也是决定了表的物理排列顺序,所以只有一个聚簇索引表 聚簇索引的特点: 当你查数据的时候,如果需要通过一个辅助索引+主键索引,它查找辅助索引时,会在辅助索引的叶子节点找到主键的id,然后在主键索引树上通过主键id去找到数据. 这样的好处就是节省空间,只加载一次,而且只加载部分内容,这个我也没大懂,反正省空间记着就成吧.非聚簇索引:可以理解为通过偏旁部首查字典,到时候的汉字不一定谁在前谁在后勒,比如广字头和单人旁的汉字,在字典里谁在前这个还真不好说.非聚簇索引的特点: 不论你是通过主键索引还是通过辅助索引,都可以直接查找到数据,但是这样就很占用空间,因为它的数据和索引不是放在一起的,每次找一个数据,都要加载所有的数据.InnoDB使用的是密集索引(聚簇索引),将主键组织到一棵B+Tree中,而行数据就存储在叶子节点上,因为InnoDB的主键索引和对应的数据是保存在同一个文件上的,所以检索的时候在加载叶子节点的主键进内存的同时,也加载了对应的数据,即若使用 select * from user where id = 14这样的条件查询主键,则按照B+Tree的检索算法就可以直接查找到对应的叶子节点并获取对应的行数据. 若使用稀疏索引(非聚簇索引)进行条件筛选,则需要进行两个步骤(例如 where name = Ellison): 在稀疏索引的辅助键索引B+Tree中检索name为指定值的主键,比如检索上图中的Ellison,然后它就可以得到主键信息,获取到主键信息只有,就要开始第二步. 根据主键信息id=14去主键索引B+Tree树中,按照B+Tree的检索算法去查找对应的叶子节点然后获取其对应的行数据. MyISAM采用的都是稀疏索引,而且两棵B+Tree没有什么不同,节点的结构完全一致,只是存储的内容不一样而已.主键索引B+Tree存储的主键,而辅助键索引B+Tree存储的时辅助键,两棵树是互相独立的,并且表数据(由B+Tree的叶子节点中的地址指向)存储在其他地方,即索引和数据是分开存储的 索引的分类(这个我发现各有各的说法,我就综合了一下) 单列索引:一个索引只包含一列,但是可以有多个单列索引 唯一索引:列值唯一,可以为空 主键索引: 列值唯一,且不能为空 普通索引:只是为了加速,没有唯一和是否为空限制 联合索引(也叫组合索引):一个索引包含两列及以上. 全文索引:对文本的内容进行分词，进行搜索,搜索引擎用的就是这个. 索引覆盖和覆盖索引‘’ 索引覆盖和覆盖索引是同一个东西 通俗的说就是需要的数据通过索引就能找到,不需要从磁盘中去拿就比如说我将id设置为主键索引,name为辅助索引,我要拿name=f的name和id的值的时候,可以直接通过索引name拿到,因为直接存在了B+Tree里,就很快嘛.]]></content>
  </entry>
  <entry>
    <title><![CDATA[数据库考点_1]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F07%2F24%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E8%80%83%E7%82%B9_1%2F</url>
    <content type="text"><![CDATA[关系型数据库和非关系型数据库的区别 简单来说:1.关系型数据库通过 外键关联 来建立表与表之间的关系2.非关系型数据库通常指 数据以对象的形式存储在数据库中，而对象之间的关系通过每个对象自身的属性来决定 比如 有一个学生的数据： 姓名：张三，性别：男，学号：12345，班级：二年级一班 还有一个班级的数据： 班级：二年级一班，班主任：李四 关系型数据库中，我们创建学生表和班级表来存这两条数据，并且学生表中的班级存储的是班级表中的主键。 非关系型数据库中，我们创建两个对象，一个是学生对象，一个是班级对象 如何设计一个关系型数据库 一个合格的RDBMS(Relational Database Management System, 关系型数据库管理系统)应该包含下面几个内容: 要有一个存储模块负责存储我们的数据(类似于文件系统,将数据持久化地存入到磁盘中). 除了有存储模块一块,我们还需要组织和使用这些数据,需要一个程序实例,用逻辑结构映射出物理结构,并且在程序中提供获取以及管理数据的方式以及必要的问题追踪机制. 这主要包括: 存储管理模块:我们需要对数据的格式以及文件的分隔进行统一的管理, 即把物理数据通过逻辑的形式给组织和表示出来 缓存机制:把取出来的数据块(因为一行一行从磁盘读太慢了,多读一点放内存里,这样可以提高数据库效率) 存放在缓存里,下次需要的时候,直接从内存里返回,而不用发生io行为. SQL解析模块:将SQL编译解析转换为机器可执行的指令. 日志管理模块:对我们的操作做记录,方便我们做数据库的灾难恢复等. 权限划分模块:给用户提供一定的私密空间,根据不同的权限,只能看到不同的数据. 异常容灾机制模块:但我们数据库出现异常,应该怎么恢复这些问题. 索引模块:优化数据查询效率. 锁模块:使得数据库支持并发操作. 总结如下为什么要使用索引 索引是对某个字段进行排序的一种方式。数据库表中一个或多个列（例如，employee 表的姓氏 (lname) 列）的值进行排序的结构。 如果我们使用全表扫描的方式,将整张表的数据都一起加载到内存中,然后一块一块(数据库的加载单位是数据块或者数据页)得扫描数据,当数据量小的时候很快,但是当数据量非常大的时候,会极其缓慢,内存压力也贼大. 索引就是为了解决全表扫描在数据量很大的情况下效率很低而产生的,其 灵感来自于字典,可以根据偏旁部首这些去很快地查到我们想要的字词所在的页面,而 这些关键信息以及根据关键字查找数据的方式便组成了我们的索引 所以,使用索引的原因: 通过索引,可以大幅度地提升查询数据的速度. 什么样的信息可以成为索引 肯定是那种可以把数据限定在某一范围的字段啦哈哈哈哈 主键 当然首当其冲,肯定可以,唯一键以及普通键也可以,能起到那种作用都可以. 索引的数据结构 最简单的: 生成索引,建立二叉搜索树(左边都比根节点小,右边都比根节点大,且没有重复的节点,查找的时间复杂度可以O(logN))进行二分查找. 复杂点的: 生成索引,通过它的变种–&gt;平衡二叉树(AVL树)–&gt;红黑树(自平衡的二叉搜索树)–&gt;B-Tree(平衡多路查找树)结构进行查找. 再牛逼一点的: 生成索引,建立B+Tree(B树的变形)结构进行查找,mysql索引是通过B+Tree实现的. 还有一种,生成索引,建立Hash结构进行查找.]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>数据库考点_1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库考点_2]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F07%2F24%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E8%80%83%E7%82%B9_2%2F</url>
    <content type="text"><![CDATA[二叉查找树作为索引 优点: 因为二叉查找树是有序的,左孩子都比父节点小,右孩子都比父节点大,所以其查找效率很高,类似于二分查找可以达到O(logN). 缺点: 当二叉查找树的结构变成了下图右边这种结构之后,时间复杂度就会变成O(N). B-Tree作为索引 B-Tree就是平衡多路查找树,如果每个节点最多有m个孩子,那么这棵树就叫做m阶B树,如图所示就是一棵3阶段B树:上述每个节点就可以理解为一个存储块,主要包含了关键字和指向孩子的指针. B-Tree的特征: 根节点至少包括两个孩子. 树中的每个节点最多含有m个孩子(m&gt;=2) 除了根节点和叶节点外,其他每个节点至少有Math.ceil(m/2)个孩子,即对m/2向上取整,例如m为3的话就取2. 除了满足第3点外,还要非根非叶节点至少有两个孩子. 所有叶子节点都位于同一层,叶子节点的高度都是一样的. 假设每个非叶子节点中包含了n个关键字信息(就是上面的图的蓝色部分),其中: Ki(i=1…n)为关键字,且关键字按顺序升序排序,即K(i-1) &lt;Ki. 关键字的个数n必须满足: [ceil(m/2)-1]&lt;=n&lt;=m-1,即关键字的个数永远比阶数少至少一个 非叶子节点的指针:P[1],P[2],…P[M];其中P[1]指向关键字小于K[1]的子树,P[M]指向关键字大于K[M-1]的子树,其它P[I]指向关键字属于(K[I-1],K[i])的子树,即对比上面的图来说,指向的左子树永远小于左边的关键字,指向的右子树永远大于右边的关键字,中间的子树位于左右两个关键字之间 B+Tree作为索引 B+Tree是B-Tree的变体,其特征基本与B树相同,除了: 其非叶子节点的子树指针与关键字个数相同. 其非叶子节点的子树指针P[i],指向关键字值范围为[K[i],K[i+1]]这个闭区间的子树. 非叶子节点仅用来做关键字的索引,数据都保存在叶子节点中.所以B+Tree的检索都是从根节点开始,叶子节点结束. 所有叶子节点均有一个类似于链表指针的结构指向下一个叶子节点并按照大小顺序连接,例如P1叶子节点中的5-&gt;8-&gt;9,P2叶子节点中的10-&gt;15-&gt;18. B+Tree如图所示:总结: B+Tree更适合用来做存储索引 B+Tree的磁盘读写代价更低,因为B+Tree的非叶子节点只存放索引的信息,而不存放数据,所以可以指向更多的数据,可以一次性读取更多的数据哈哈哈哈. B+Tree的查询效率更加稳定.因为其非叶子节点不是指向文件内容的节点,只是叶子节点中关键字的索引,所以任何数据的查找都是从根节点到叶子节点,所有数据的查询长度都是一样的,自然效率也一样,这就稳定了嘛,基本保持在O(logN). B+Tree更利于对数据库的扫描.可以直接只在叶子节点里根据链表指针做扫描,不用每次都遍历整棵树 Hash作为索引 Hash作为索引就是通过哈希函数计算出数据所在地址,然后加载该地址对应的所有数据,再去查找指定的数据,理论上说,这个比B+Tree的效率还要高. 如图:Hash作为索引的缺点: 仅仅能满足”=”,”IN”,不能使用范围查询,因为经过哈希函数运算后的哈希值和为运算前的哈希值的大小关系并不一定完全一样,比如上图中的Sandra Dee和John Smith的哈希值不就一样了. 无法被用来避免数据的排序操作,因为计算后的哈希值和计算前是没有关系的. 不能利用部分索引键查询,组合索引键查询它是把两个当成一个整体计算哈希值的,不能分开计算而B+Tree支持组合索引中的部分索引查询. 不能避免表扫描,如上图所示,哈希后计算的值存在重复的情况,即计算出来的哈希就相当于是一个桶,这个桶里存放着很多的数据,数据库虽然找到了地址,但是还是要扫描桶里的数据才能找到指定的数据. 遇到大量hash值相等的情况后,性能就会大大降低,不一定比B+Tree高.]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>数据库考点_2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis_4]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F07%2F24%2Fmybatis_4%2F</url>
    <content type="text"><![CDATA[mybatis动态代理 我们之前写StudentDao的实现类的时候,很多实现方法都是大同小异的,所以就导致代码重复度很高,所以我们可以偷懒不写哈哈哈,让mybatis自动去给我们生成这个类,我们只需要写一个接口就可以了 关于动态代理,大家可以移步我这篇博客: 动态代理 在mybatis里,动态代理大概是这样的: 没使用动态代理之前:1. 首先我们把sql语句都写在mapper中2. 刚开始我们在测试类中会去创建studentDaoImpl对象,然后去调用其中的方法,然后StudentDaoImpl类中的方法再去mapper中调用对应的sql语句.使用动态代理之后:我们就不用写接口的实现类了,交给mybatis去创建实现类对象(这就叫动态代理对象)1. 测试类直接操作mybatis自动创建的动态代理对象.2. 通过动态代理对象去操作mapper中的sql语句.将之前的程序改成动态代理 StudentDao接口12345@Mapperpublic interface StudentDao &#123; void insertStudent(Student student);&#125; StudentDaoMapper.xml配置文件1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!--namespace写的是接口的名称,写上之后就不用写实现类了--&gt;&lt;mapper namespace=&quot;com.ctgu.dao.StudentDao&quot;&gt; &lt;!--新增--&gt; &lt;insert id=&quot;insertStudent&quot; parameterType=&quot;com.ctgu.bean.Student&quot;&gt; insert into student(name, age, address) values(#&#123;name&#125;, #&#123;age&#125;, #&#123;address&#125;) &lt;/insert&gt;&lt;/mapper&gt; 测试类1234567891011121314151617181920212223242526272829303132333435public class Studentdemo2Test01 &#123; //创建接口对象 private StudentDao studentDao; //获取sqlSession对象 private SqlSession sqlSession; /* 创建studentDao和sqlSession对象 */ @Before //表示运行测试方法之前会先执行该注解的内容 public void initDao() &#123; sqlSession = MybatisUtil.getSqlSession(); //由mybatis创建动态代理对象,括号中的参数为被代理的接口对象 //没有这条语句的话,接口对象是没有实例化的,是空的,肯定会报错的 studentDao = sqlSession.getMapper(StudentDao.class); &#125; /** * 使用结束后关闭sqlSession */ @After public void closeSession() &#123; if (sqlSession != null) &#123; sqlSession.close(); &#125; &#125; @Test public void insertStudent() &#123; Student student = new Student(&quot;stu&quot;,22,&quot;宜昌&quot;); studentDao.insertStudent(student); &#125;&#125;]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis_4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络_HTTP与HTTPS的区别]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F07%2F23%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%2F</url>
    <content type="text"><![CDATA[HTTPS简介 HTTPS(Hypertext Transfer Protocol Secure),即超文本传输安全协议, 它是一种以计算机网络安全通信为目的的传输协议. 它相对于HTTP来说,多了一个SSL(TLS)层,从而具有了保护数据安全以及完整性,并且提供了对网站服务器进行认证的功能,简单来说,它就是安全版的HTTPSSL SSL(Security Socket Layer,安全套接层) 为网络通信提供安全以数据完整性的一种安全协议,位于应用层和会话层之间. 是操作系统对外的API,SSL3.0以后更名为TLS. 采用 身份验证和数据加密 保证网络通信的安全和数据完整性. 我们采用http传输的时候,不论是get还是post,数据都是 通过明文传输的,也就是相当于裸奔了哈哈哈哈. 加密的方式非对称加密一般是服务器采用的,对称加密一般是客户端这边用的 HTTPS使用的加密方式是证书配合各种加密手段的综合加密方式,一般是对称加密+非对称机密+哈希算法这些辅助算法. HTTPS数据传输流程 HTTPS在进行数据传输之前, 会与网站服务器和客户端浏览器进行握手,在握手时确定双方的加密密码信息,具体过程如下: 浏览器将支持的加密算法信息(比如只支持对称加密这样子)发送给服务器. 服务器根据浏览器提供的加密方式,在服务器支持的加密算法中,选择一套浏览器和服务器都支持的加密算法,然后再选择一套哈希算法,然后将验证服务器身份的信息以证书的形式回发给浏览器,其中证书的信息包括:证书发布的机构CA(就好比四六级委员会才有资格发布四六级证书一样),证书的有效期,服务器非对称算法的公钥以及证书所有者,数字签名(就是验证服务器身份的信息经过哈希和CA的私钥加密生成的)等等. 浏览器验证证书的合法性(证书受到浏览器信任的话在浏览器地址栏会有标志显示,证书受信之后,浏览器会随机生成一串密码,并使用证书中的服务器的公钥加密),然后生成一串随机数(作为对称加密的公钥)并用公钥加密,然后浏览器还会使用约定好的hash算法生成握手消息并用随机数密码加密,之后和公钥一起回发给服务器. 服务器收到浏览器发送过来的数据后,使用私钥*确定随机数密码,然后通过密码解密web浏览器发送过来的握手信息,并 **验证哈希是否与浏览器发来的(浏览器会发送为加密的哈希和加密的哈希)一致***,然后服务器会使用密码加密新的握手信息回发给浏览器. 浏览器解密并计算握手消息的哈希值,如果与服务器发送过来的哈希值一致,则此握手过程结束后,服务器和浏览器会使用之前浏览器生成的随机数密码和公钥对数据进行加密交互数据. 这里浏览器和网站互相发送加密的握手消息并验证是为了保证双方都获得了一直的密码,并且可以正常解密加密数据,为后续真正数据的传输做一次测试 https数据传输流程总结HTTP与HTTPS的区别 HTTPS需要到CA机构申请证书,HTTP不需要. HTTPS是基于SSL协议的超文本传输协议,是密文传输,HTTP明文传输. 连接方式不同,而且HTTPS默认使用443端口,而HTTP默认使用80端口. HTTPS是HTTP协议+SSL协议(有状态)构建的可进行加密传输和身份认证的传输协议,较HTTP(无状态)更安全. HTTPS真的安全吗? 不一定 由于我们在访问网站的时候,一般只会输入一个域名,例如www.baidu.com,不会输入http或者https,而浏览器默认填充是http://,然后网站管理员会将请求进行跳转为https,在此过程有被拦截的风险. 解决方法:可以使用HSTS(HTTP Strict Transport Security)即http严格安全传输协议优化,其作用是强制客户端（如浏览器）使用HTTPS与服务器创建连接。]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>计算机网络_HTTP与HTTPS的区别</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis_3]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F07%2F23%2Fmybatis-3%2F</url>
    <content type="text"><![CDATA[原生态mybatis实现增删查改操作 我把整个项目都放这里,大家可以去下载下来自己看一眼,改一下数据库的配置信息就可以了,以及记得去下载lombok插件,不然会因为没有get/set方法报错,或者自己手动生成一下get/set方法也可以,然后emm,有不懂的再问我吧呢. mybatis实现增删查改完整代码. 字段名与属性名不一致的情况 比如我数据库中student表的一个字段名为name,但是我student这个bean中用的是userename属性名对应的name字段名,这就叫字段名与属性名不一致 解决方案: 在sql语句中起一个别名:select name as username from student where id = 1. 使用mybatis提供的结果集映射resultMap(很重要)123456789101112131415&lt;!--使用resultMap,这个名字随便写的,唯一就行--&gt; &lt;resultMap id=&quot;studentMapper&quot; type=&quot;student&quot;&gt; &lt;!--这个id一般都写上,因为id一般都是主键,他们说写上查询快一些--&gt; &lt;!--column指的是数据库的字段名,property指的是bean对象中的字段名--&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;&gt;&lt;/id&gt; &lt;!--这就用于处理字段名不一致的问题,一致的不用写了--&gt; &lt;result column=&quot;name&quot; property=&quot;username&quot;&gt;&lt;/result&gt; &lt;/resultMap&gt; &lt;!--通过resultMap查询数据_属性名和字段名不一致--&gt; &lt;!--此处的resultMap(注意不是resultType哈)写成上面定义的resultMap的id,这样我们 的sql语句查询返回的就是一个resultMap了--&gt; &lt;select id=&quot;selectStudentMapper&quot; resultMap=&quot;studentMapper&quot;&gt; select id,name,age from student; &lt;/select&gt;]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis_3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis_2]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F07%2F20%2Fmybatis-2%2F</url>
    <content type="text"><![CDATA[Mybatis主配置文件详解 配置文件的作用 mybatis一共有两个配置文件(都是.xml文件):一个是映射文件mapper,一个是主配置文件文件mapper. 主配置文件中可以注册db.properties属性文件(也就是配置数据源的文件),方便使用. 注册实体类的全限定类名的别名 配置MyBatis的运行环境,即数据源与事务管理器. 注册映射文件Mapper. Mybatis配置文件实现注册db.properties属性文件12345678910111213141516171819202122232425262728293031323334------db.propertiesjdbc.driver=com.mysql.jdbc.Driver//当连接数据库时候出现时区异常的时候后面加上这句话就好了:------useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=true&amp;serverTimezone=UTCjdbc.url=jdbc:mysql://127.0.0.1:3306/mybatis_project?useSSL=falsejdbc.username=rootjdbc.password=root------mybatis.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;!--注册配置文件,告诉mybatis去哪里找配置文件--&gt; &lt;properties resource=&quot;db.properties&quot;&gt;&lt;/properties&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;!--去配置文件中读取jdbc的信息--&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;!--注册映射文件--&gt; &lt;mapper resource=&quot;com/ctgu/dao/StudentDaoMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt;Mybatis主配置文件注册实体类的全限定类名的别名123456789101112&lt;typeAliases&gt; &lt;typeAlias type=&quot;com.ctgu.bean.Student&quot; alias=&quot;student&quot;&gt; &lt;/typeAlias&gt; &lt;/typeAliases&gt; 这样子以后就可以用`student`代替Student这个类了,一般我们的别名就是类名首字母小写.------还有一种写法:因为我们有时候会创建很多bean,所以要写很多行,很麻烦,我们可以把这个交给mybatis去做&lt;typeAliases&gt; &lt;package name=&quot;com.ctgu.bean&quot;&gt;&lt;/package&gt; &lt;/typeAliases&gt;这样之后,bean包下面的所有类,mybatis都会给他取个别名名称就是类名首字母小写,比如StudentMap,那么它的默认别名就是studentMap.Mybatis主配置文件配置MyBatis的运行环境我们在开发的过程中,可能会有很多的数据库给我们使用,比如我们自己电脑上会有一个,服务器会有一个,客户也会有一个,我们不能在哪里用就去改配置文件吧,这也蛮麻烦,所以Mybatis支持多数据源配置哈哈哈哈,就是可以同时配置多个数据库,这个没连接上连接另一个当你想切换数据库的时候,修改&lt;environments default=&quot;development&quot;&gt;中default的内容为对应数据源的id即可比如我想用test的数据源,我就讲其修改为&lt;environments default=&quot;test&quot;&gt;,它就会去使用测试数据库了.123456789101112131415161718192021222324252627282930-------environments标签中environment 标签中的内容就是在配置数据库环境-------可以有多个environment 标签配置多个数据源-------注意在db.properties中记得配置不同数据源的参数就可以了&lt;environments default=&quot;development&quot;&gt; &lt;!--开发环境--&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;!--去配置文件中读取jdbc的信息--&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;!--测试环境--&gt; &lt;environment id=&quot;test&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;!--去配置文件中读取jdbc的信息--&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;test.driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;test.url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;test.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;test.password&#125;&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt;Mybatis主配置文件注册映射文件Mapper 1234567------就是下面的内容,就表示注册mapper.xml映射文件------此时mybatis就知道了sql语句在哪里了,他就会去里面找.&lt;mappers&gt; &lt;!--注册映射文件--&gt; &lt;mapper resource=&quot;com/ctgu/dao/StudentDaoMapper.xml&quot;/&gt; &lt;/mappers&gt; 注意: 我们在写配置文件的时候,一般都写全限定类名,就是包名.类名的形式 好了配置文件的基本东西就知道了,这里接着写一个小东西 Mybatis获取主键 在前一篇博客mybatis-1中,我在创建数据库的时候使主键id自增,我们就不需要手动输入主键,当插入数据库之后我们就能知道这条数据的id,其实我们可以在数据插入到数据库前获取主键 ,即这样做:12345678910------resultType表示返回的时int类型的数据------keyProperty表示要返回的属性是id------order=&quot;AFTER&quot;表示获取的是&quot;假如成功插入后&quot;的数据 此时就算你在事务提交之前获取id,它的id值也会是`如果事务提交之后`的id------order=&quot;BEFORE&quot;表示获取还没插入前的id,那么一定是0 即你不管在事务提交前还是事务提交后获取id,都是0 &lt;selectKey resultType=&quot;int&quot; keyProperty=&quot;id&quot; order=&quot;AFTER&quot;&gt; select @@identity &lt;/selectKey&gt;]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis_2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络-TCP的滑窗]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F07%2F18%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP%E7%9A%84%E6%BB%91%E7%AA%97%2F</url>
    <content type="text"><![CDATA[RTTRTT(Round Trip Time): 发送一个数据包到收到对应的ACK,所花费的时间,简单来说,就是我发送一个数据包,对方给我会有一个ACK包这个过程所花费的时间.font color=orange&gt;RTORTO(Retransmission Time Out): 重传超时时间,TCP在发送一个数据包之后,就会自动启动一个重传定时器,RTO就是定时器规定的重换时间,也就是说,如果你在RTO时间内给我回复了ACK包,重传定时器就失效,不需要重传,当超过RTO时间还没有收到ACK包时,发送发就会重新发送数据包RTO不是写死的,是根据RTT计算出来的TCP的滑动窗口 我们知道TCP为了传输效率,会将报文分割成数据包之后再进行传送,但是出于效率的考虑,不可能只是一段一段地发送,也就是说不可能上一段发送结束了再发送下一段,这样太慢了 而要实现数据包的批量发送,TCP就必须要解决 可靠传输,以及 包乱序的问题 TCP使用滑动窗口做流量控制与乱序重排,其主要作用如下 保证TCP的可靠性,基于确认重传机制的(即发送窗口只有收到接收端对本段数据的确认后才会滑动窗口,接收窗口在前面所有的段都已经被确认的前提下才会移动左边界滑动窗口). 保证TCP的流控特性TCP(通过报文头中的window字段使接收方通知发送方还有多少缓冲区可以接受数据,发送方根据接收方的处理能力来返送数据,这样接收方就不会出现处理不过来的情况) 滑动窗口还体现了TCP面向字节流的设计思路 窗口数据的计算过程图中左边是发送端缓冲区,右边是接收端缓冲区,下面的 长方形表示要发送的数据流,假设里面装满了数据,并且需要按照顺序从左向右依次发送或者接收 TCP会话发送方的窗口滑动过程 TCP会话接收方的窗口滑动过程]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>计算机网络-TCP的滑窗</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络-HTTP相关]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F07%2F18%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_HTTP%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[HTTP简介 它是位于应用层的协议. 是基于请求-响应模型的无状态的协议. 中文名为超文本传输协议. 基于TCP协议. HTTP协议定义了web客户端如何从web服务器请求web页面以及服务器如何把web页面传送给客户端. HTTP协议的主要特点: 支持客户端/服务器模式(客户端向服务器发送请求,服务器根据请求向客户端发送响应信息). 简单快速: 客户端发出请求的时候只需要传送请求方法(get/post等)和路径即可. 灵活: HTTP允许传输任意类型的数据对象,传输类型由contentype加以标记. 无连接,也就是说,每次连接只处理一个请求,服务端完成客户端的请求并受到客户端的确认后就会断开连接(HTTP1.1之后就换成了长连接,即连接一段时间才会断开连接). 无状态,即协议对于事务处理没有记忆能力,同时也意味着如果后续处理需要前面的处理信息就只能被重传. HTTP请求报文结构(包括请求行,请求头和请求体三部分): 1. 请求行: 包括请求方法+空格+URL+空格+协议版本,例如GET /index.html HTTP/1.1. 2. 请求头: 由若干个头部字段名 + : + 值组成.用于通知服务器有关于客户端请求的信息,常见的头部字段名如下. 1. User-Agent：产生请求的浏览器类型,例如User-Agent: Chrome/74.0.3729.169 Safari/537.36. 2. Accept：客户端可识别的内容类型列表,例如Accept: text/html. 3. Host：请求的主机名,例如Host: www.baidu.com.3. 请求体不在GET方法中使用，而是在POST方法中使用.HTTP响应报文结构(包括状态行,响应头和响应体三部分): 1. 状态行: 包括协议版本+空格+状态码+空格+状态码描述,例如HTTP/1.1 200 OK. 2. 响应头: 和请求头一样,用于告知客户端服务端的信息,由多个头部字段名+空格+值组成,例如Content-Type: text/html;charset=utf-8. 3. 响应体: 返回的就是客户端请求的数据.HTTP协议中请求和响应的步骤: 客户端连接到web服务器 发送HTTP请求(文本请求) 服务器接收到请求并返回HTTP响应消息 释放TCP连接 客户端浏览器解析HTML内容 在浏览器地址栏输入URL,按下回车后经历的流程 DNS(域名系统)解析:即将主机名(如www.sina.com或者mail.163.com)转换为对应的ip地址. 根据IP地址和端口(端口用于确认是哪个进程,默认是80)和服务器建立TCP连接(三次握手). 向服务器发送HTTP请求. 服务器处理请求并返回HTTP响应报文. 浏览器解析响应报文并渲染页面. 浏览器释放TCP连接(四次挥手). HTTP状态码(五种) 1xx: 指示信息—表示请求已接收,继续处理. 2xx: 成功—表示请求已被成功接收,理解,接收.例如200表示请求已成功，请求所希望的响应头或数据体将随此响应返回. 3xx: 重定向—表示客户端要完成请求必须进行更进一步的操作. 4xx: 客户端错误—表示请求有语法错误或请求无法实现(比如请求参数有误). 5xx: 服务端错误—服务器端未能实现合法的请求. 常见状态码 200 OK: 正常返回信息. 400 Bad Request: 客户端请求有语法错误,不能被服务器所理解. 401 Unauthorized: 请求未经授权,这个状态码必须和WWW-Authenticate一起使用. 403 Forbidden: 服务器收到请求,但是拒绝提供服务. 404 Not Found: 请求资源不存在,例如输入了错误的URL. 500 Internal Server Error: 服务器发生了不可预知的错误. 503 Server Unavailable: 服务器当前不能处理客户端的请求,可能会在一段时间后恢复正常. GET请求和POST请求的区别 从HTTP报文层面: GET将请求信息放在URL中,POST将请求信息放在请求体中.因此浏览器在GET请求中会对数据长度进行一定限制,而对POST请求没有限制,注意:HTTP是不安全的,不管是什么方式,通过抓包都是可以抓到数据这点可以体现. 从数据库层面: GET请求(主要做查询操作)符合幂等性(对数据库的一次操作和多次操作的结果是一致的)和安全性(对数据库的操作不改变数据库中的数据),POST不符合(因为它主要用于修改,会向服务器提交数据,比如我们的登录就是用的post). 从其他层面: GET请求可以被缓存(例如参数会保存在浏览器的浏览记录中,这也是get请求被广泛应用的根本),被存储(例如get请求的url可以被保存为书签),但是POST请求都不可以. 因为http是无状态的,那么我们每次请求的时候都需要输入账号密码,但是实际上我们并没有这样子,那么因为有某种操作记住了我们的状态,其中就有cookie和session Cookie简介 Cookie: 作用在客户端,即服务器发送给客户端的特殊信息,以文本形式存放在客户端,客户端每次给服务器端发送请求的时候,都会带上这些特殊的信息. 例如: 当我们用浏览器访问一个支持Cookie的网站的时候,如果我们提交了账号密码等信息至服务器,服务器在处理完我们发送的请求并回传响应文本的同时,也会带上这些我们提交的个人信息,但是这些信息不存放在响应体,而是存放在响应头中,当浏览器接收到服务器的响应消息后,浏览器会将这些信息存放在一个统一的位置. 有了上面的一系列操作之后,当客户端再次向服务端发起请求的时候,会把相应的Cookie存放在HTTP请求头中发回给服务器. 当服务器再次收到请求后,会解析Cookie中的信息,并生成与客户端相对应的内容(例如记住密码之类的提醒,选中之后,下次就不用再重新登录了). Cookie设置及发送过程 1. 客户端发送http请求给服务器. 2. 服务器处理请求并返回响应消息给客户端,其中响应消息的响应头中包含了Set-Cookie这个字段值的信息,例如 Set-Cookie: rememberMe=deleteMe; Path=/xg; . 3. 客户端再次发送http请求到服务器,其中请求报文的请求头中包含了Cookie字段值 的信息,例如 Cookie: JSESSIONID=GQnkdx. 4. 服务器给客户端发出一个HTTP响应,比如问是否记住密码之类的,点击记住密码后,客户端再次登录就不需要输入密码了. 5. 其实有的是会第一次登录就提醒你是否记住密码,但是流程都差不多.Session简介 服务器端的机制,在服务器上保存的信息. 当服务器需要为某个客户端的请求创建一个session的时候,它会先检查客户端的请求里是否已包含了jsessionid这个字段,如果有,则说明以前为此客户端创建过session,它就会解析jsessionid这个字段值,检索其对应的session并使用. 如果请求中没有jsessionid这个字段或者检索不到传来的jsessionid对应的session,那么服务器就会为此客户端新创建一个session,同时生成一个与之相关的jsessionid(不会重复,也不容易破解的字符串),这个id会随着响应信息发送给客户端进行保存. Session的实现方式 使用Cookie来实现服务器给每个session分配一个唯一的jsessionid,并通过cookie发送给客户端(放在响应头中的set-cookie字段中),当客户端发起新的请求的时候,将在cookie字段中携带这个jsessionid,这样服务器就能找到客户端对应的session. 使用URL回写来实现 URL回写是指服务器在发送给浏览器页面的所有链接中,都会携带jsessionid这个参数及其值,这样客户端点击任何一个链接都会把jsessionid带回到服务器中. 如果直接在浏览器地址栏输入服务器资源对应的URL来请求资源,那么存放在服务器中的session是匹配不到的,因为没有jsessionid字段及其值. tomcat对session的实现: 一开始同时使用回写url和cookie,如果发现客户端支持cookie,就继续使用cookie而停止使用url回写,如果不支持cookie或者cookie被禁用,就只使用url回写. Cookie请求和Session的区别 Cookie存放在客户端浏览器上,而Session存放在服务器端. Session相对于Cookie更安全(Cookie存放在本地,可以自己伪造). Session由于保存在服务器上,当访问增多会占用服务器的性能,考虑到减轻服务器负担,应当使用Cookie. Cookie只能保存字符串类型对象,而Session中可以保存任意类型的对象. 单个Cookie的容量大小一般为4KB,Session没有容量限制.]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>计算机网络-HTTP相关</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot简介及核心]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F07%2F18%2Fspringboot%E7%AE%80%E4%BB%8B%E5%8F%8A%E6%A0%B8%E5%BF%83%2F</url>
    <content type="text"></content>
      <tags>
        <tag>springboot简介及核心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络-TCP与UDP的区别]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F07%2F17%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP%E4%B8%8EUDP%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[UDP简介UDP: 即User Datagram Protocol, 用户数据报协议 UDP报文结构如图:UDP特点 面向非连接,和TCP必须要建立连接才能传输数据不一样,它只管发,不管你收没收到,它传送数据直接抓取来自应用程序的数据,并尽可能快得把它扔到网络上,所以在发送端UDP传送的速度仅仅受到应用程序生成数据的速度,计算机的能力和传输带宽的限制的影响,在接收端,UDP把每个消息段放在队列中,应用程序每次从队列中读取一个消息段. 由于传输数据不建立连接,自然也就不需要维护连接状态(包括收发状态),因此一个服务器支持同时向多个客户端传输相同的消息. 数据包报头只有8个字节(TCP需要20个字节),额外开销较小. 吞吐量只受限于数据生成速度,传输速度以及机器性能. 它尽最大努力交付,但是不保证可靠交付,不需要维持复杂的链接状态表. 它是面向数据报的,不对应用程序提交的报文信息进行拆分或者合并,即发送端的UDP对应用程序交下来的报文添加首部后就直接给了网络层的IP协议,不会拆分,也不会合并.,因此应用程序需要选择合适的报文大小. TCP和UDP的区别 他俩都是传输层的协议. TCP协议是面向连接的的通信协议,而UDP是面向无连接的通信协议. TCP有三次握手的连接过程,UDP适合消息的发布,即从单个点向多个点传输信息. TCP协议传输数据是可靠的,而UDP是不可靠的,只管发,不管是否收到. TCP协议传输数据的时候利用序列号保证数据的有序性,而UDP不具备有序性. 从速度上讲,TCP的速度比较慢,因为要创建连接,保证数据的可靠性等,需要做很多额外的事情,而UDP没有什么限制,所以速度比较快,就比较适合对速度比较敏感的应用,比如在线视频媒体,电视广播等. 从量级上讲,TCP属于重量级的,UDP属于轻量级的,这体现在报文的头部大小,UDP只有8个字节,而TCP有20个字节. TCP面向字节流( 即将大块数据分割成以报文段（segment） 为单位的数据包)的传输，因此它能将信息分割成组，并在接收端将其重组； UDP是面向数据报的传输，没有分组开销。]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>计算机网络-TCP与UDP的区别</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络_TCP的四次挥手]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F07%2F17%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP%E7%9A%84%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%2F</url>
    <content type="text"><![CDATA[挥手是为了终止TCP连接,四次挥手是指总共要发出四个包来确认连接的断开,这一过程由客户端或者服务器端任意一方执行CLOSE来触发本文假设客户端主动触发CLOSE TCP的四次挥手的流程图如下 1. 刚开始客户端和服务端都处于ESTABLIS的状态,我们这里假设客户端主动关闭,服务器被动关闭. 2. 首先,客户端进程发出连接释放报文,并且停止发送数据,在报文中的FIN结束标志位为1,seq序号为u(该值为在连接状态下已经发送给服务器的数据的最后一个字节的序号+1),报文发送结束后,客户端就进入了 FIN-WAIT-1结束等待1的状态,此时TCP会消耗掉一个序号. 3. 当服务器端收到释放连接报文之后,向客户端发出确认报文,其中ACK=1,seq=v(v就是服务器端给客户端发的报文的最后一个字节的序号+1),ack=u+1(因为前面消耗掉了一个序号).发送之后服务器端就进入了 CLOSE-WAIT关闭等待状态. 该状态下,客户端不会再发送数据,但是服务器发送数据客户端依旧可以收到,相当于是一个半关闭状态 4. 客户端收到服务器端的确认报文后,客户端就进入了FIN-WAIT-2结束等待2的状态,等待服务器发送第三次挥手的报文. 5. 服务器在此期间将数据发送完以后,就向客户端发送FIN报文,其中FIN=1,ACK=1,seq=w(w等于服务器端向客户端发送的数据的最后一个字节的序号+1),ack=u+1,发送连接释放报文之后,服务器就进入了LAST-ACK最后确认状态,等待客户端的最终确认. 6. 客户端收到连接释放报文后,向服务器发送确认报文,其中ACK=1,seq=u+1,ack=w+1,发送报文后,客户端就进入了TIME-WAIT状态.注意此时客户端的TCP连接还没有释放,要等待2MSL(MSL即最长报文段寿命,规定为2分钟,linux下一般为30秒)时间后才进入了CLOSED状态,即客户端的TCP连接此时才中断. 7. 服务器端接收到确认报文后便进入了CLOSED状态,即TCP连接已断开,完成四次挥手!总结:为什么会有TIME-WAIT状态 确保有足够的时间让对方收到ACK包,如果服务器端没有收到ACK包的话会向客户端重发FIN包,然后客户端再重新向服务器端重发ACK包,这样一来一去刚好是两个MSL. 有足够的时间保证这个连接不会跟后面的连接混在一起,避免新旧连接混淆,因为有可能路由器会缓存IP数据包,如果这个连接立即被其他客户端重用了,那么这些数据包可能会跟新发送的数据混在一起,造成接收数据错误. 为什么需要四次握手才能断开连接 我们知道TCP协议是全双工的协议,即建立连接后,在同一时间,客户端可以发送数据给服务器端,同时服务器端也可以发送数据给客户端,这也就导致了发送方和接收方都需要FIN报文和ACK报文才能确认关闭连接 为什么服务器会出现大量CLOSE-WAIT状态(即客户端一直请求关闭连接,但是服务器端没有做出应答) 产生这种现象的原因: 服务器端收到客户端发来的FIN结束报文后,没有向客户端发送ACK确认报文或者没有发送FIN结束报文 . 也就是说有可能服务器端已经关闭了连接,但是程序没有检测到或者程序本身就没有关闭连接这个功能,于是 资源就一直被占用着. 这种情况的发生有可能是代码有bug,检查代码去吧,尤其是释放资源的代码,有可能是没有释放连接导致的,也有可能是线程的配置有问题.]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>计算机网络_TCP的四次挥手</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis_1]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F07%2F17%2Fmybatis-1%2F</url>
    <content type="text"><![CDATA[mybatis简介 mybatis是一个持久层框架,主要作用就是在java中操作数据库,其实就是在jdbc的基础上进行了封装. 使用mybatis之后,开发者不用再费精力去比如说注册驱动,创建connection,配置statement等繁琐的过程. mybatis不需要web容器也可以使用,反正就是用来操作数据库的,支持注解和xml配置两种方式. 第一个mybatis程序注意每次新建了一个项目之后所有的设置都要记得确认一下,比如说编码格式这些的 1. pom设置(注意区别springboot集成mybatis的依赖) 添加依赖,驱动的版本要适应自己mysql的版本 注意: 除了上面添加的依赖以外,我们还需要在pom.xml文件中的build标签中添加依赖,目的是将xml文件放到classes目录中去,否则mybatis会找不到配置文件,就照着下面图片写就行 反正记住.xml配置文件都是要放在classes文件(就是编译后生成的文件夹中有一个classes文件夹)下去才能读取到,不然会有一系列奇奇怪怪的错误. 创建数据库表(自己随便创建一个就成,我这里是student表) 创建实体类如下(添加get和set方法) 1234567891011121314/** * 学生实体类 */public class Student &#123; private int id; private String name; private int age; private String address; //省略了get和set方法+&#125; 创建接口和实现类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * 学生类接口 */public interface StudentDao &#123; void insertStudent(Student student);&#125;/** * 学生dao层的实现类 */public class StudentDaoImpl implements StudentDao &#123; /** * 添加学生 * @param student 添加的学生对象 */ @Override public void insertStudent(Student student) &#123; try &#123; //读取主配置文件 InputStream input = Resources.getResourceAsStream(&quot;mybatis.xml&quot;); /** * 创建sqlSessionFactory对象 * 可以把sqlsession理解为jdbc的connection对象 * 而sqlSessionFactory是生成sqlsession对象的. */ SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(input); //创建sqlsession对象,这样子创建的话mybatis不会自动提交事务,只能我们手动提交事务 SqlSession sqlSession = sqlSessionFactory.openSession(); /** * 通过sqlsession对象完成对数据库的操作--新增一个学生记录 * * 他会去映射文件里查找insertStudent这个名字的标签,然后执行里面的语句. * * 括号里的student对应于映射文件对应insertStudent标签的parameterType * 这就相当于是一个parameterType所代表的类型的引用 * xml文件中insert标签里的插入语句里的值就是从student中取到的 * */ sqlSession.insert(&quot;insertStudent&quot;, student); //手动提交事务 sqlSession.commit(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 添加映射文件(也就是一个xml文件,命名要方便辨识) 映射文件,一般称之为mapper,主要是在里面编写SQL语句 123456789101112131415161718&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//ibatis.apache.org//DTD Mapper 3.0//EN&quot; &quot;http://ibatis.apache.org/dtd/ibatis-3-mapper.dtd&quot;&gt;&lt;!--namespace写的是接口的名称,写上之后就不用写实现类了--&gt;&lt;mapper namespace=&quot;StudentDao&quot;&gt; &lt;!--id一般写执行插入语句的方法名,因为不要重复,而且要与StudentDaoImpl中 sqlSession.insert(&quot;insertStudent&quot;, student);中的第一个参数一致--&gt; &lt;!--parameterType指的是参数类型,可以省略让mybits自己去找,记得写全类名,一般就不省略了吧--&gt; &lt;insert id=&quot;insertStudent&quot; parameterType=&quot;com.ctgu.bean.Student&quot;&gt; -- 这个语句就相当于preparestatement语句,有预编译操作 -- values后面的#&#123;&#125;内容是Student类的属性名 -- #&#123;&#125;中的这些值就从parameterType对应的引用中去取,也就是实现类的insert语句中的student insert into student(name,age,address) values (#&#123;name&#125;, #&#123;age&#125;, #&#123;address&#125;) &lt;/insert&gt;&lt;/mapper&gt; 添加mybatis的主配置文件(命名要易于辨识) 主配置文件要放在maven项目的resources目录下12345678910111213141516171819202122232425&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;!--主配置文件主要用于配置数据源--&gt;&lt;configuration&gt; &lt;environments default=&quot;development&quot;&gt; &lt;!-- 配置数据源 --&gt; &lt;environment id=&quot;development&quot;&gt; &lt;!-- 使用JDBC事务管理 --&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis_project&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 映射文件mapper路径 --&gt; &lt;mappers&gt; &lt;mapper resource=&quot;com/ctgu/dao/StudentDaoMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 7. 创建测试类测试类要写在test目录下1234567891011121314/** * student的测试类 */public class StudentTest01 &#123; @Test public void insertStudent() &#123; StudentDaoImpl studentDao = new StudentDaoImpl(); Student student = new Student(&quot;学生1&quot;, 18, &quot;武汉&quot;); studentDao.insertStudent(student); System.out.println(&quot;插入成功!&quot;); &#125;&#125; 8. 记录日志方便查看在main下面的resources目录下创建log4j.properties文件 123456789101112#配置根Loggerlog4j.rootLogger=trace, console#配置日志信息输出目的地Appender及Appender选项log4j.appender.console=org.apache.log4j.ConsoleAppenderlog4j.appender.console.Target = System.outlog4j.appender.console.layout = org.apache.log4j.PatternLayoutlog4j.appender.console.layout.ConversionPattern = [%-5p][%d&#123;yyyy-MM-dd HH:mm:ss&#125;]%m%n 运行test类就会发现数据库中多了一条数据. log4j 的基础知识 1.log4j 是Apache为java提供日志管理的工具作用：可以调试程序，就像输出一样 2.核心概念： log4j有三大组件： 日志器（Logger） 日志输出的目标（Appender） 格式化器（Layout） 日志器（Logger）:用来输出消息的类，可以输出不同级别的，比如错误消息，警告消息等 日志输出的目标（Appender）：日志输出到哪里去，文件 ，控制台 格式化器（Layout）：对输出消息进行格式化，比如添加日期 https://blog.csdn.net/sun8112133/article/details/81276020]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis_1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络_TCP的三次握手]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F07%2F16%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_TCP%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%2F</url>
    <content type="text"><![CDATA[IP协议 IP协议是 无连接 的通信协议, 作用在网络层 *主要作用是:负责寻址和路由选择,即将网络地址翻译为物理地址然后确定如何将数据从发送方路由到接收方. 它不会占用两台正在通信的计算机之间的通信线路, 这样IP协议就降低了对网络线路的需求,每条线可以同时满足许多不同计算机之间的通信需要. 通过IP协议,消息或者其他要传送的数据会被分割为较小的独立的包然后在网络中传送,这种被分割成的包叫做数据包. IP协议 只负责将每个包路由至它的目的地,但是IP协议没有做任何事情来确认数据包是否按顺序发送或者包是否被破坏,这个需要它的上层传输层中的协议来解决. 传输层控制协议TCP 面向连接的,可靠的,全双工的(两边都可以发送也可以接收),基于字节流的传输层通信协议. 将应用层的数据流分割成报文段并发送网络层. 注意:应用层以上数据单位都是报文,数据链路层是数据帧,网络层是数据包,物理层是比特流 TCP协议为了保证不丢失包,每个数据包都有序号(seq Sequence Number),对方收到则发送ACK确认,如果发送端在合理的往返时延TCP_TIMEOUT_INIT内未收到确认则重传. TCP协议用一个奇偶校验和函数来检验数据在传输过程中是否有误. TCP报文头如图:TCP Flags URG: 紧急指针标志,为1表示紧急指针有效,为0则忽略紧急指针. ACK:确认序号标志,为1表示这是一个用于确认的报文. PSH: push标志. RST: 重置连接标志. SYN:同步序号标志,用于建立连接过程,为1表示这是一个请求建立连接的报文. FIN:结束标志,用于释放连接,为1时表示发送方已经没有数据发送了,关闭连接. TCP的三次握手握手是为了建立连接,TCP三次握手流程图如下: 1. 刚开始客户端和服务器端都会处于关闭状态,当双方打开之后,服务端便立刻进入LISTEN即监听状态. 2. 客户端首次向服务器端发送请求报文,此时同步序号标志SYN为1,而序号seq为任意正整数值x,向服务器端发送完报文后,客户端便进入了名为SYN_SENT(同步_已发送)的状态.在此时之前发送的那个报文段被称为SYN报文段,这个报文不能携带数据,但是会消耗一个序号,这就是第一次握手!!! 3. 当服务器接收到请求报文以后,先确认客户端发来的请求报文, 如果同意连接,则向客户端发出确认报文,确认报文中的SYN同步标志位为1,ACK确认标志位为1,序列号为y(任意正整数), 确认号ack为x+1(客户端传过来的序列号+1).给客户端发送确认报文之后,服务器便进入了SYN_RCVD(同步_已接收)阶段,这个报文也不能携带数据,但是仍然会消耗一个序列号,这就是 第二次握手. 4. 当客户端接收到确认报文之后,先检查服务器端发来的确认报文,然后向服务器发出一个确认报文,其中ACK确认序号标志为1,seq序号为x+1,ack确认号为y+1(服务器发给我的序号是y,我作为回应要还给你,但是又消耗了一个序号,所以+1),这个报文 是可以携带数据,会消耗一个序列号,不携带数据就不消耗序号 这就是 第三次握手. 5. 客户端将确认报文发送给服务器端之后,客户端就进入了ESTABLISHED已建立连接的状态. 6. 服务器端收到确认报文后,服务器端便也随之进去了ESTABLISHED已建立连接的状态,此时可以发送数据了.总结小知识: TCP和UDP数据包中都是不包含ip信息的,因为ip是网络层的事情,而他俩在传输层. TCP和UDP数据包中都会有源端口和目的端口,也就是说,端口是在传输层的. 两个进程在同一台计算机内部进行通信,可以被PID(进程号)来唯一标识某个进程,但是这个只在本地唯一. 如果把两个进程放在了不同的计算机,那么如果要进行通信的话,PID是不能唯一定位到两个进程的,解决方法就是使用在传输层中的端口号来唯一标识某个进程 IP地址+端口号+协议号(标识上层是TCP还是UDP)可以唯一标识某一台主机的某个进程. 为什么需要三次握手才能建立起连接? 为了初始化Sequence Number的初始值,让双方知道对应的seq,也就是上面的x和y,这个序列号是以后进行通信的序号,来保证应用层接收到的数据不会因为网络等问题而乱序,之后TCP会用这个序号来拼接数据,所以会有第三次握手,客户端通知服务器端已经收到服务器端的seq的初始化值. 如果只有两次握手,那么服务器端收到了客户端传来的SYN=1的请求连接数据包之后,便会分配资源并向客户端发送ACK=1的确认连接数据包 这样会产生一个问题: 当客户端与服务器端正常建立连接,发送数据结束关闭TCP连接之后,如果在之前客户端与服务器端建立连接过程中残留的数据包此时才到达服务器端,那么服务器端就会认为客户端又申请了一次连接,然后又给客户端分配资源发送确认连接报文,但是此时是没有数据会发送给服务器端的,服务器就只能一直等着,知道超时,这就造成了服务器端资源的浪费. 首次握手会有一个隐患:—&gt;SYN超时问题 SYN超时问题是指: 如果服务器端收到了客户端的SYN,向客户端回复SYN-ACK报文之后客户端发生了掉线了之类的情况,导致服务器端未收到客户端发送的ACK确认的情况. 当服务器端没有收到客户端的ACK确认报文前,此时暂时双方就处于一个中间状态,没有成功也没有失败,一定时间后如果服务器端还没有收到客户端发来的ACK报文后,服务器端就会不断重试(即重发SYN-ACK报文至客户端)直至超时,linux下默认重试次数为5次,重试的间隔时间从1秒开始,每次都翻倍,比如:1s-&gt;2s-&gt;4s-&gt;8s-&gt;16s,第五次发出去之后,再等待32s,还没收到就判定位超时,断开连接(即63s后TCP断开连接). 这样子可能会使得服务器遭受SYN Flood攻击,即恶意程序给服务器发一个SYN报文之后就不发ACK报文了,服务器每次都会等待一段时间才断开连接,次数太多了,会使得SYN半连接队列(server收到SYN请求连接报文后将client放到半连接队列)耗尽,会导致其他正常的请求无法处理.SYN Flood攻击解决办法(有好几个,我只写一个嘿嘿嘿):其一就是: 当server收到client的SYN之后,不立即分配资源,而是根据client发送过来的SYN计算出一个cookie值,这个cookie值用来 存储server返回给client的SYN+ACK数据包中的初始序列号seq,当client发送第三次握手的ACK包之后进行校验,如果校验成功则server分配资源,建立连接.那么当syn半连接队列满了之后没有进行校验的请求就会被抛弃.如果已经建立连接,客户端出现故障怎么办? TCP有保活机制: 也就是说,TCP设有保活计时器,服务器每收到一次客户端的请求后都会重新复位这个计时器,时间一般是俩小时,如果俩小时服务器端还没收到客户端的任何数据,即连接处于非活动状态,则服务器端会向客户端发送探测报文,如果未收到响应,会每隔75分钟发送一个,若连续发送10个仍然没反应,服务器端就会断开连接.]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>计算机网络_TCP的三次握手</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot-day02-3]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F07%2F16%2Fspringboot-day02-3%2F</url>
    <content type="text"><![CDATA[springboot导出jar包 1. 在pom.xml中的build标签下添加插件依赖以及配置文件依赖(不配置的话导出就没配置文件,跑不起来)如下:123456789101112131415161718192021222324252627&lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;!--这就是说通过哪个类来跑这个项目--&gt; &lt;mainClass&gt;springboot_mybatis.App&lt;/mainClass&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;repackage&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;resources&gt; &lt;!--将resources下的配置文件也到导出去--&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.*&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;/resources&gt;2. 在idea中,控制台那里会有一个Terminal字样,点击它之后输入:12//导包D:\IDEA_Codes\springboot_case3&gt;mvn clean install3. 导包结束后,点开项目中的target文件夹,会发现一个以项目命名的jar包,如图: 其中版本号可以在pom.xml中的version标签中修改,默认是1.0 4. 我们将jar包拷贝出去放到桌面或者其他你想放的地方 首先. 在桌面通过ctrl + r调出命令行窗口 然后. 通过cd命令跳转到jar包所在的目录 最后. 输入:java -jar springboot_case3-1.1-SNAPSHOT.jar运行项目 注意:格式: java(空格)-jar(空格)jar包全名不管是打包后是jar包还是war包,都是java -jar. 5. 启动成功后,在浏览器中url栏输入http://localhost:8080/user/register?username=%22root9%22&amp;password=%22root9%22就可以实现在idea中同样的运行效果了 6. 运行结束后,关闭命令行窗口就可以了]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot-day02-3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算法网络_基础分层]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F07%2F15%2F%E8%AE%A1%E7%AE%97%E6%B3%95%E7%BD%91%E7%BB%9C_%E5%9F%BA%E7%A1%80%E5%88%86%E5%B1%82%2F</url>
    <content type="text"><![CDATA[计算机网络 1. OSI参考模型 物理层 数据链路层 网络层 传输层 会话层 表示层 应用层 1-1. 物理层 用于解决两台物理机之间的通信需求. 具体来说,就是机器A往机器B发送比特流,然后物理层保证机器B能收到这些比特流 物理层主要定义了物理设备的标准:比如网线的类型,光纤的接口类型等 其主要作用是传输比特流(就是0和1),将其与电压的高低,光的闪灭相切换,网卡就是在这一层工作的 1-2. 数据链路层 在物理层 传输比特流的过程中,会存在错传,数据传输不完整的可能,因此数据链路层就产生了. 数据链路层定义了如何格式化数据来方便传输,以及如何控制对物理介质的访问,通常它还提供错误检测和纠正功能以确保数据传输的可靠性. 交换机就工作在这一层. 总的来说:这一层的主要作用就是负责物理层面上互连的节点之间的通信传输,将0和1序列划分为具有意义的数据帧传送给对方(也就是数据帧的生成与接收). 1-3. 网络层 随着网络节点的不断增加,点对点进行通信的过程中需要经过多个节点,那么如何找到目标节点以及如何选择最佳路径便成为了首要需求,此时便有了网络层. 网络层的主要功能是将网络地址翻译成对应的物理地址并确定如何将数据由发送方路由到接收方,即本层主要负责寻址和路由选择 路由器属于这一层. 本层的数据称为 数据报. 我们需要重点关注在本层的TCP/IP协议中的 IP协议 1-4. 传输层 传输层 解决了主机间的数据传输问题,起到可靠传输的作用. 主机的传输的数据可以是不同网络的,并且传输层解决了传输质量的问题. 这层是OSI模型中最重要的一层. 这层我们需要关注 TCP/IP协议中的TCP协议和UDP协议. 1-5. 会话层 前面四层可以保证给正确的计算机发送正确的封装信息了,但是用户的体验不好,因为如果仅仅只有前面四层的话,用户还要自己去打包,然后给地址这那的. 会话层的主要功能是:建立和管理应用程序之间的通信(比如建立和断开通信连接) 1-6. 表示层 他可以帮我们解决不同系统之间通信语法的问题,比如说.exe的安装包是不能安装到linux系统下的,书面来说就是:表示层将应用处理的信息转换为适合网络传输的格式,即负责数据格式的转换 1-7. 应用层 为应用程序提供服务并规定应用程序中通信相关的细节,比如针对特定应用采用的特定协议. 也就是说,这层是给发送发和接收方的数据传输提供一些规定,使得两者可以互相正确识别出来,没有这层,你传过去传过来都只是0和1,识别不出来. 这层我们需要重点关注TCP/IP协议族中的HTTP协议 2. TCP/IP四层架构参考模型 OSI参考模型并没有提供具体的实行方法,而是描述了一些概念,而 OSI的实现,就是TCP/IP四层架构参考模型 应用层(包括了osi参考模型的应用层,表示层,会话层) 传输层 网络层 链路层 每层的内容和osi七层模型差不多,我就不再重复写了哈 ….更新中]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>计算法网络_基础分层</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot-day02_2]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F07%2F15%2Fspringboot-day02-2%2F</url>
    <content type="text"><![CDATA[springboot通过注解配置mapper整合mybatis1. 新建一个jar包的maven项目,然后添加依赖 xml中添加依赖如下:123456789101112131415161718192021222324252627282930313233343536373839&lt;!--添加父依赖--&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-parent&lt;/artifactId&gt; &lt;version&gt;2.1.6.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;!--添加web启动器的核心组件依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--添加mybatis依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--mysql的依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.46&lt;/version&gt; &lt;/dependency&gt; &lt;!--jdbc,添加这个依赖是为了写配置文件的时候有提示--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;2. 新建一个application.properties(命名只能是这个,其他的读不出来)配置文件,然后添加数据库的配置信息,如下:1234spring.datasource.url=jdbc:mysql://localhost:3306/springbootspring.datasource.username=rootspring.datasource.password=rootspring.datasource.driver-class-name=com.mysql.jdbc.Driver3. 新建一个mapper包,这个包就相当于dao层,然后添加dao相关类如下:123456public interface UserMapper &#123; //这里用注解,但是我们不建议用注解来做 @Insert(&quot;insert into user(username, password) values(#&#123;username&#125;,#&#123;password&#125;)&quot;) public abstract int addUser(@Param(&quot;username&quot;) String username, @Param(&quot;password&quot;) String password);&#125;4. 新建一个service包,然后添加相关类如下:12345678910@Servicepublic class UserService &#123; @Autowired private UserMapper userMapper; public void register(String username, String password) &#123; userMapper.addUser(username, password); &#125;&#125;5. 新建一个controller包,然后添加相关类如下:123456789101112131415@Controller@RequestMapping(&quot;user&quot;)public class UserController &#123; @Autowired private UserService userService; @RequestMapping(&quot;register&quot;) @ResponseBody public String register(String username, String password) &#123; userService.register(username, password); return &quot;success&quot;; &#125;&#125;6. 配置启动类APP.java,如下所示:12345678910@EnableAutoConfiguration@MapperScan(basePackages = &#123;&quot;springboot_mybatis.mapper&quot;&#125;)@ComponentScan(basePackages = &#123;&quot;springboot_mybatis.service&quot;,&quot;springboot_mybatis.mapper&quot;,&quot;springboot_mybatis.web.controller&quot;&#125;)public class App &#123; public static void main( String[] args ) &#123; SpringApplication.run(App.class, args); &#125;&#125;7. 启动服务器后,在浏览器输入: http://localhost:8080/user/register?username=root2&amp;password=root2之后就可以发现在数据库中多了一条记录同时页面显示success字样 springboot通过xml配置mapper整合mybatis相对于上面来说,只改了mapper包和xml的内容 1. 修改UserMapper的内容如下:123public interface UserMapper &#123; public abstract int addUser(@Param(&quot;username&quot;) String username, @Param(&quot;password&quot;) String password);&#125;2. 在mapper包下添加UserMapper.xml的内容如下:12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;&lt;mapper namespace=&quot;springboot_mybatis.mapper.UserMapper&quot;&gt;&lt;insert id=&quot;addUser&quot;&gt; insert into user(username, password) values(#&#123;username&#125;, #&#123;password&#125;);&lt;/insert&gt;&lt;/mapper&gt;3. 在pom.xml的build标签中添加的内容如下:123456789&lt;!--查找mapper的配置文件UserMapper.xml--&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;/resources&gt;4. 启动服务器后,在浏览器输入: http://localhost:8080/user/register?username=root2&amp;password=root2之后就可以发现在数据库中多了一条记录同时页面显示success字样]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot-day02_2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[递归和动态规划]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F07%2F13%2F%E9%80%92%E5%BD%92%E5%92%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[1. 介绍递归和动态规划 暴力递归: 把问题转化为规模缩小了的同类问题的子问题. 有明确的的不需要继续进行递归的条件(base case也就是递归的出口,例如当节点为空之类的). 有当得到了子问题结果之后的决策过程. 不记录每一个子问题的解. 动态规划(就是为了优化暴力递归): 从暴力递归中来. 将每一个子问题的解记录下来,避免重复计算. 把暴力递归的过程,抽象成状态表达. 并且存在化简形式表达,使其更加简洁地可能. 我们直接上题目练习,动态规划就是一个尝试的过程,不断去尝试其规律,说白了就是一种感觉哈哈哈哈,这就要自己多练习了 题目1. 求n!的结果 思路: 不递归就通过一个for循环,直接从1开始乘,一直乘到n结束. 递归的话就把求n的阶乘看作求n*(n-1的阶乘),然后一直乘到1就结束. 求n的阶乘代码2. 题目2. 汉诺塔问题 如果有n层,那么时间复杂度为O(2^n); 汉诺塔来源:相传在古印度圣庙中，有一种被称为汉诺塔(Hanoi)的游戏。该游戏是在一块铜板装置上，有三根杆(编号A、B、C)，在A杆自下而上、由大到小按顺序放置64个金盘(如下图)。 游戏的目标：把A杆上的金盘全部移到C杆上，并仍保持原有顺序叠好,在算法中就是通过最少的步骤实现这个目标,然后打印出实现步骤。操作规则：每次只能移动一个盘子，并且在移动过程中三根杆上都始终保持大盘在下，小盘在上，操作过程中盘子可以置于A、B、C任一杆上。思路:我刚开始有三个杆(left, middle, right),刚开始n个盘子都在左边杆上,目标就是把所有盘子移到右边去. 1. 把1~n-1个盘子移动到middle杆上,然后把from杆中最下面的盘子移动到right杆上去. 2. 把1~n-1个盘子从middle杆移到right杆中去.### 汉诺塔问题代码3. 题目3. 打印一个字符串的全部子序列,包括空字符串 3.1. 区分子序列和子串 例如：一个字符串 awbcdewgh 他的子串:awbc、awbcd、awbcde等 很多个子串 ，但是都是连续在一起 . 他的子序列:abc 、abcd、 abcde等 很多个子序列 ，但是 子序列中的字符在字符串中不一定是连在一起的，而是删除其中若干个， 但是子序列一定是单调的（即字符之间ASCII单调递增或单调递减，相对顺序不能改变） 所以 子串！=子序列 思路:刚开始是空字符,但是不是null哈就是每次走到一个字符,我都有两种选择:一个是我当前的字符(刚开始是空字符)去和后面的字符做拼接,还有一个是我当前的字符不去和后面的字符做拼接.(可以画个图,就跟二叉树差不多,然后结束条件就是到了叶节点) 打印字符串的子序列代码题目4.母牛每年可以生一头母牛,新出生的母牛成长三年后(也就是第四年开始)也能每年生一头母牛,假设不会死,求N年后,母牛的数量 例如:这种方法的时间复杂度为O(N) 母牛问题代码4. 题目4 题目如图:思路:暴力递归,时间复杂度比较高,因为会发生有的位置重复计算比如两次经过(1,1)这个点,如下面的代码### 最短路径递归代码5. 题目5:给你一个正数数组arr和一个正整数aim,如果可以任意选择arr中的数字,能不能累加得到aim,返回true或者false ***思路:跟求子序列的思路差不多,就是我们在遍历数组的时候,每个数都有两种选择,一种是和后面的数相加,另一种是不和后面的数相加,当遍历结束之后,比较各种情况的结果,如果存在与aim相同的结果,那么返回true,反之返回false 能否累加得到给定值代码]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>递归和动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[哈希题目]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F07%2F12%2F%E5%93%88%E5%B8%8C%E9%A2%98%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[注意: 一般哈希表的增删改查的时间复杂度默认为O(1). 题目1题目如图: 思路: 这个思路很简单,就是通过两个哈希表实现. 这两个哈希表分别为map1和map2,map1中的key,value分别作为map2中的value,key,也就是map1和map2中的数据是反的,map1中的key是map2中的value. 因为没有给定value,在map1中,我们就将数据插入的次序设置为value,比如第一个插入的是”fan”,那么map1中的数据就是fan, 1这样子,map2同步插入就成,只是说跟map1是相反的而已. 获取随机数的时候,就通过math.random或者random类都可以,这时候map1中的value就起到了作用,value的范围就是随机的范围. 删除的时候要特别注意:因为删除之后,那一条记录都会被删掉,所以map1中value表示的范围内就会有一个空的洞,所以我们取随机的时候就有可能会得到null,这不是我们想要的,所以我们选择用最后一条元素去交换要删除的元素,然后删除最后一条元素,这样就没有洞了. RandomPool代码]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>哈希题目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[哈希函数和哈希表概念]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F07%2F12%2F%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E5%92%8C%E5%93%88%E5%B8%8C%E8%A1%A8%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[哈希函数和哈希表1. 什么是哈希函数 它是一种映射关系，它可以把任意长度的输入映射到任意一个固定长度的整数值，也称为散列函数,其值是十六进制的数。 说白了,哈希函数就是用来将key-value结构中关键字值转换为数组的下标的函数(一般都是通过取模,而且这样子在数据量很大的情况下一般是均匀分布的),然后将该结构存放到数组中去,然后这个数组就叫做哈希表. 这个固定长度不是说所有长度的输入获取到的整数永远是一个长度,我觉得有两种理解: 它是说比如String str = &quot;abc&quot;和String str1 = &quot;def&quot;,那它俩这种同一类型的且长度相同的获取到的是整数的位数是一般一样的; 比如说String str= &quot;abc&quot;,当你输入参数固定的情况下,你不管运行多少回,这个字符串的哈希值是一定的,即输入一样,输出一定一样; 当然这里有个特殊的东西:那就是比如说String str = new String(&quot;abc&quot;),这个你重复运行后生成的哈希值是不一样的,因为每次重复运行生成的都是一个新的对象. 这个你可以用hashCode()方法测试,你输入多个长度相同的string类型的字符串,看看输出的是不是都是十六进制的相同长度的整数就可以了. 特殊情况: 由于输入域是无穷的,但是输出域范围是有限的(它是16位的,每个位置都有16个数,一共只有16^16个数,即范围为 - 2^64 ~ 2^64-1),所以一定会出现不同的输入域但是得到了同一个输出,这就叫哈希冲突. 2. 什么是哈希表 哈希表(hash table,也叫散列表)是根据关键码值(Key value中的key)而直接进行访问的数据结构,也就是说: 哈希表基于数组，其中每个单元都是类似于key-value的存储形式，关键字值通过哈希函数映射为数组的下标，如果一个关键字哈希化(将关键字转换为数组下标的过程)后映射到一个已占用的数组单元，这种情况就是上面的哈希冲突。 3. 如何解决哈希冲突 开发地址法: 开放地址法的思路就是: 通过系统的方法找到数组的一个空位,并把这个元素填进去,就不再用哈希函数获得的数组下标,它有三种方法: 线性探测线性探测的思路: 它会线性的查找空白单元.比如说5421是哈希函数计算出来的下标,但是它已经被占用了,那它就去使用5422,如果5422也被使用了,那它就去使用5423,以此类推,它的数组下标会一直递增,知道找到空白的位置.但是这会有一个问题: 那就是当哈希表太满的时候,我们每插入一个数据,都要频繁的探测插入位置,因为可能很多位置都被前面插入的数据占用了,这就称为聚集 二次探测(解决聚集)二次探测的思想: 探测相距较远的单元,而不是和原始位置相邻的单元.比如说: 如果哈希函数计算的原始下标是x,线性探测就是x+1,x+2,x+3这样子类推下去,而在二次探测中,探测的过程是x+1, x+4,x+9,x+16这样子,到原始位置的距离是步数的平方.这样子可以很好的解决线性探测带来的聚集问题.但是这会产生一个新的问题:这个问题叫做二次聚集,比如说184,552,336,753依次插入表中,他们通过哈希函数计算出来的下标都是7,按照上面的规律,552就放在8,336需要放在11,753需要放在17这样子,后面再有要放在下标为7的元素的话,它就要往后面移动更长的距离. 再哈希法(解决二次聚集)由于二次聚集的原因是因为每次移动的长度有规律的:1,4,9,16,25这样子,那么解决方法就是找到一种依赖于关键字的探测序列,那么就可以做到每个关键字移动的方法就都不一样了,即把关键字通过不同的哈希函数再做一遍哈希化,用这个结果作为步长,每次移动步长个距离,虽然步长对于每个关键字来说是一定的,但是不同关键字的步长是不一样的.为了实现想要的效果,第二个哈希函数必须有以下几个特点: 和第一个哈希函数不能相同. 不能输出0,输出0就永远在原地踏步,就死循环了. 2.链地址法: 链地址法的思路: 把哈希表每个单元中的存储方式都设置为链表,某个数据项的关键字值还是像之前一样通过哈希函数映射到哈希表,但是这个数据插入到哈希表指定下标单元的链表中,当有其他元素映射到同一个单元的时候,就往链表后面挂就可以了.]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>哈希函数和哈希表概念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[哈希]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F07%2F12%2F%E5%93%88%E5%B8%8C%2F</url>
    <content type="text"><![CDATA[哈希函数和哈希表1. 什么是哈希函数 它是一种映射关系，它可以把任意长度的输入映射到任意一个固定长度的整数值，也称为散列函数,其值是十六进制的数。 说白了,哈希函数就是用来将key-value结构中关键字值转换为数组的下标的函数(一般都是通过取模,而且这样子在数据量很大的情况下一般是均匀分布的),然后将该结构存放到数组中去,然后这个数组就叫做哈希表. 这个固定长度不是说所有长度的输入获取到的整数永远是一个长度,我觉得有两种理解: 它是说比如String str = &quot;abc&quot;和String str1 = &quot;def&quot;,那它俩这种同一类型的且长度相同的获取到的是整数的位数是一般一样的; 比如说String str= &quot;abc&quot;,当你输入参数固定的情况下,你不管运行多少回,这个字符串的哈希值是一定的,即输入一样,输出一定一样; 当然这里有个特殊的东西:那就是比如说String str = new String(&quot;abc&quot;),这个你重复运行后生成的哈希值是不一样的,因为每次重复运行生成的都是一个新的对象. 这个你可以用hashCode()方法测试,你输入多个长度相同的string类型的字符串,看看输出的是不是都是十六进制的相同长度的整数就可以了. 特殊情况: 由于输入域是无穷的,但是输出域范围是有限的(它是16位的,每个位置都有16个数,一共只有16^16个数,即范围为 - 2^64 ~ 2^64-1),所以一定会出现不同的输入域但是得到了同一个输出,这就叫哈希冲突. 2. 什么是哈希表 哈希表(hash table,也叫散列表)是根据关键码值(Key value中的key)而直接进行访问的数据结构,也就是说: 哈希表基于数组，其中每个单元都是类似于key-value的存储形式，关键字值通过哈希函数映射为数组的下标，如果一个关键字哈希化(将关键字转换为数组下标的过程)后映射到一个已占用的数组单元，这种情况就是上面的哈希冲突。 3. 如何解决哈希冲突 开发地址法: 开放地址法的思路就是: 通过系统的方法找到数组的一个空位,并把这个元素填进去,就不再用哈希函数获得的数组下标,它有三种方法: 线性探测线性探测的思路: 它会线性的查找空白单元.比如说5421是哈希函数计算出来的下标,但是它已经被占用了,那它就去使用5422,如果5422也被使用了,那它就去使用5423,以此类推,它的数组下标会一直递增,知道找到空白的位置.但是这会有一个问题: 那就是当哈希表太满的时候,我们每插入一个数据,都要频繁的探测插入位置,因为可能很多位置都被前面插入的数据占用了,这就称为聚集 二次探测(解决聚集)二次探测的思想: 探测相距较远的单元,而不是和原始位置相邻的单元.比如说: 如果哈希函数计算的原始下标是x,线性探测就是x+1,x+2,x+3这样子类推下去,而在二次探测中,探测的过程是x+1, x+4,x+9,x+16这样子,到原始位置的距离是步数的平方.这样子可以很好的解决线性探测带来的聚集问题.但是这会产生一个新的问题:这个问题叫做二次聚集,比如说184,552,336,753依次插入表中,他们通过哈希函数计算出来的下标都是7,按照上面的规律,552就放在8,336需要放在11,753需要放在17这样子,后面再有要放在下标为7的元素的话,它就要往后面移动更长的距离. 再哈希法(解决二次聚集)由于二次聚集的原因是因为每次移动的长度有规律的:1,4,9,16,25这样子,那么解决方法就是找到一种依赖于关键字的探测序列,那么就可以做到每个关键字移动的方法就都不一样了,即把关键字通过不同的哈希函数再做一遍哈希化,用这个结果作为步长,每次移动步长个距离,虽然步长对于每个关键字来说是一定的,但是不同关键字的步长是不一样的.为了实现想要的效果,第二个哈希函数必须有以下几个特点: 和第一个哈希函数不能相同. 不能输出0,输出0就永远在原地踏步,就死循环了. 2.链地址法: 链地址法的思路: 把哈希表每个单元中的存储方式都设置为链表,某个数据项的关键字值还是像之前一样通过哈希函数映射到哈希表,但是这个数据插入到哈希表指定下标单元的链表中,当有其他元素映射到同一个单元的时候,就往链表后面挂就可以了.]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM_2]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F07%2F09%2FJVM-2%2F</url>
    <content type="text"><![CDATA[程序计数器,虚拟机栈,本地方法栈随线程而生,随线程而灭,他们的回收就不用过多考虑,但是方法区和堆的内存分配和回收都是动态的,GC关注的就是这部分内存. jvm的基本概念堆被分成新生代和老年代,新生代被分成一个Eden区和两个Survivor区(From Survivor区和 To Survivor区) 新生代GC(又叫Minor GC):指的是新生代的垃圾收集动作,因为java对象大都具备朝生夕灭,所以Minor GC非常频繁,一般回收速度也比较快. 老年代GC(又叫Major GC/Full GC): 指发生在老年代的GC,老年代GC比新生代GC慢很多. 进入老年代的几种情况大对象直接进入老年代:大对象即需要大量连续内存空间的java对象,最典型的就是那种很长的字符串或数组,大对象堆虚拟机来说是一个坏消息,尤其是那些朝生夕灭的大对象,经常出现大对象容易导致还有不少空间就要出发垃圾收集器去找空间安置他们 *虚拟机提供了一个-XX:PertenureSizeThreshold参数,令大于这个值的对象直接在老年代分配 长期存活的对象直接进入老年代:虚拟机给每个对象都设置了一个年龄计数器,如果对象在Eden区出生并经过第一次Minor GC后仍然存在,并且能被别Survivor区容纳的话,就将被移动到Survivor中(具体怎么移动看下面的复制算法),并且对象年龄加1,当它的年龄增加到一定程度(默认15岁)之后,就将会晋升到老年代中,这个可以通过参数-XX:MaxTenuringThreshold设置. 当然为了能很好的适应不同程序的内存情况,虚拟机不是永远地要求对象的年龄达到-XX:MaxTenuringThreshold参数值才可以晋升到老年代,如果survivor空间中相同年龄所有对象大小的总和大于survivor的一半,那么年龄大于等于该年龄的对象就可以直接进入老年代. 空间分配担保进入老年代: 在进行MinorGC前, 如果老年代最大可用的连续空间大于新生代对象总大小,那么虚拟机就会认为Minor GC是安全的,那么就会进行Minor GC .反之会进行一次Full GC. 如果上面的条件不满足,那么虚拟机就会去查看HandlePromotionFailure的设置值是否是允许冒险, 如果允许冒险,那么虚拟机就会去检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小(平均大小也就是每次`新生代对象要移过来的对象的大小的平均值), 如果大于,虚拟机将尝试进行一次MinorGC,不过这样子是有风险的哈!!!, 如果小于,那么虚拟机将进行一次Full GC. 如果HandlePromotionFailure的设置值为不允许冒险,那么虚拟机将进行一次Full GC. 如何判断对象是否已经死了在堆里面存放着所有对象的实例,在GC对其回收之前就要确定哪些对象还活着不能回收,哪些对象已经嗝屁了可以回收,有以下几种算法: 引用计数算法概念: 引用计数算法是指给对象添加一个引用计数器,当有一个地方引用它的时候,计数器＋1,当引用失效时,计数器-1,当计数器为0就表示该对象不能被使用,可以被回收. 这样的话会存在一个问题:如果两个对象的某个字段互相引用,例如对象ojbA和对象objB都有字段instance,赋值令objA.instance = objB和objB.instance = objA,那么它应该不能被回收,但是实际上它是被回收了的,那么就说明虚拟机不是通过引用计数算法回收垃圾的. 可达性分析算法java就是通过这种算法来判定对象是否存活的. 这种算法的基本思想:是通过一系列的称为GC Roots的对象作为起始点,从这些节点开始向下搜索,搜索所走过的路径称为引用链,当一个对象到GC Roots没有任何引用链相连的时候,则证明对象不可用 如图中的object5,object6,object7,它们虽然互相有关联,但是到GC Roots没有任何引用链,所以它们被判定为可回收的对象.可作为GC Roots的对象(全局性引用对象和执行上下文对象,比如栈帧中的局部变量表),主要包括下面几种: 虚拟机栈中引用的对象. 方法区中类的静态属性代表的对象,也就是类的静态成员变量代表的对象. 方法区中常量引用的对象,就是final修饰的变量,字符串常量等. 本地方法栈中引用的对象,也就是native方法中的对象. 判断对象死亡的过程即使在可达性分析算法中不可达的对象,也不是非死不可的,这时候他们暂时会处于缓刑阶段,要真正宣告一个对象的死亡,至少要经历两次标记过程: 如果对象在可达性分析后发现没有和GC Roots相连的引用链,那它将会被第一次标记并且进行一次筛选:筛选的条件是此对象是否有必要执行finalize()方法. 当对象没有重写finalize()方法,或者finalize()方法已经被虚拟机调用过了,那么这个对象将会被当做没有必要执行,直接被虚拟机回收. 如果这个对象被判定为有必要执行finalize()方法,那么这个对象会被放在一个名为F-Queue的队列之中,稍后再对该对象执行finalize()方法,注意,此时虚拟机会创建一个低优先级的Finalizer线程去执行它(也就是去触发这个方法,不会等方法执行结束). 如果对象想要拯救自己,那么对象就要在finalize方法执行结束前将自己与一个仍然存活的对象所在引用链中的任意一个对象相连,比如把自己(this)赋值给某个类变量(也就是static成员变量)或者普通成员变量,那么它在第二次标记时他就会被移出即将回收的集合,如果这个对象在第二次标记后还没有成功拯救自己,那它就只能被回收了. 注意:这种自救方式只有一次,因为finalize()方法最多被系统自动调用一次,也就是说你这次把你自己救活了,下次可达性算法分析后被判定为可回收对象后就会在第一次标记的时候就被回收了. 垃圾收集算法标记-清除算法(最基础的算法) 该算法分为标记和清除两个阶段: 首先标记出所有需要回收的对象,在标记完成后统一回收所有被标记的对象,标记过程就是上面写的判断对象死亡的过程. 它的主要不足,有两个: 一个效率比较低: 这个标记和清除的效率本来都不高,我也不知道具体是为啥,可能太分散了啊,要两次标记啊之类的吧. 一个空间问题: 标记清除后会产生大量的碎片空间,空间碎片太多可能会导致以后在程序运行过程中需要分配大量对象时,无法找到足够的连续空间而不得不出发一次垃圾收集动作 复制算法(在标记-清除算法基础上解决了效率问题) 它将新生代可用的内存容量划分成大小相等的两块,每次只使用其中的一块,当这一块的内存用完了,它就将存活的对象复制到另外一块上去,然后再把已经使用过的空间一次全部清理掉,同时将存活对象复制到另一块去的时候,只需要移动堆顶指针,按照顺序放就可以了,这样既没有碎片化的空间,操作也很简单,效率就高一些,如图:理论是那样子,不过虚拟机一般没有五五分,因为新生代的对象基本都是朝生夕死的,所以一般都是将新生代的内存分为一块较大的Eden区和两块较小的Survivor区(From Survivor区和To Survivor区),比例一般是8:1:1 每次只使用Eden区和From Survivor区(对象在Eden区产生,当Eden区满了之后再往From Survivor区中放,都满了才进行GC),当回收的时候,将存活的对象都复制到To Survivor区,然后将其他两个区域直接全部清理,回收结束后将现在的From Survivor区与To Survivor区的身份互换,即让From Survivor区作为To Survivor区去存放对象. 同时,当Survivor中的区域不够用的时候,就会将对象通过分配担保机制(就相当于贷款时候的担保人)放到老年代中去哈哈哈. 标记整理算法(在复制算法基础上继续优化)当复制算法在对象存活率比较高的时候就要进行较多的复制操作,效率就会变低,而且,如果不想五五开这样浪费50%的空间的话,就需要额外空间进行担保,所以在老年代不选用复制算法 根据老年代的特点,有人提出一种标记-整理算法,过程和标记-清除算法一样,但后续步骤不是直接对可回收对象进行清理,而是让所有存活的对象都向一端移动,然后直接清理掉端边界以外的内存,如图:分代收集算法(JVM虚拟机采用的GC算法) 就是一般把java堆划分成新生代和老年代,新生代一般采用复制算法,因为新生代一般垃圾回收时都有大量对象死去,只有少量存活,而老年代中因为对象存活率高,没有额外空间对他进行担保,所以采用标记-整理算法或标记-清理算法来进行回收.]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>JVM_2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM_1]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F07%2F08%2FJVM-1%2F</url>
    <content type="text"><![CDATA[这里面加了很多我自己的看法,有啥错误的阔以给我留言一手,多谢您! JAVA虚拟机在执行java程序的时候会把它所管理的内存划分为若干个不同的数据区域,这些区域都有各自不同的用途,以及创建和销毁时间. java虚拟机所管理的内存包括以下几个运行时数据区域Method Area方法区(线程共享) VM Stack虚拟机栈(线程私有) Native Method Stack本地方法栈(线程私有) Heap堆(线程共享) Program Counter Register程序计数器(线程私有) 注意:这几个区域都是JVM管理的运行时数据区,要记住运行时数据区这几个字. 程序计数器(线程私有)它是一块较小的内存空间,可以看作是当前线程所执行的字节码的行号指示器,其中的值的数据类型为returnAddress类型 字节码解释器工作的时候就是通过改变这个计数器的值来选取下一条需要执行的字节码指令的,分支,循环,跳转,异常处理,线程恢复等都需要依赖这个计数器来完成. 为什么说它是线程私有的呢? 因为虚拟机的多线程是通过线程轮流切换并分配处理器时间的方式来实现的,在任何一个确定的时刻,一个处理器都只会执行一条线程中的指令,因此,为了保证线程切换后能恢复到正确的执行位置,每条线程都会有一个独立的程序计数器,各条线程之间的计数器互不影响,独立存储! 如果当前线程执行的时java方法,这个计数器记录的就是正在执行的虚拟机字节码指令的地址;而如果是Native方法那这个计数器则为空. native方法就是一个用java代码调用的用非java语言编写的接口(接口名就是方法名),定义一个native方法的时候,是没有实现体的,而且不能有实现体,有实现体就会报错,因为它的实现体是由非java代码例如C在外面实现的. 例子如下:1234567public class IHaveNatives &#123; native public void Native1( int x ) ; native static public long Native2() ; native synchronized private float Native3( Object o ) ; native void Native4( int[] ary ) throws Exception ; &#125; 注意:此内存区域是唯一一个不会出现OutOfMemoryError错误的区域!!! 虚拟机栈(线程私有)虚拟机栈的生命周期与线程相同,也就是说一个虚拟机栈实例只负责一个线程,当线程结束以后,这个虚拟机栈实例也就结束了,跟递归的过程中会创建多个栈一样的 虚拟机栈描述了java方法执行时的内存模型 每个方法在执行时都会创建一个东西,叫做栈帧,这个栈帧只属于这一个方法,栈帧里面放着局部变量表的信息,方法出口等方法里的信息,每一个方法调用直至执行结束的过程就对应着栈帧入栈直至出栈的过程. 栈帧里面有一个很重要的部分,叫做局部变量表,也就是我们当通常把java内存分为栈和堆时里面的栈,局部变量表部分存储着编译期可知的各种基本数据类型数据,对象引用(是对象引用哈,不是对象实例)以及returnAddress类型数据(指向了一条字节码指令的地址,这个不用管,知道就行,跟java代码没有直接关系) . 注意: long和double这两个64位类型的数据会占用2个局部变量空间,其余数据类型都只占用一个局部变量空间. 局部变量表所需的内存空间在编译期间完成分配,在运行期间不会改变其大小. 在java的虚拟机规范中,这个区域只有两种异常状况: StackOverFlowError异常：这个异常的产生是因为线程请求的深度大于虚拟机(不是虚拟机栈)所允许的深度，就会抛出这个异常。 OutOfMemory异常：这个异常产生的原因是，虽然大部分虚拟机栈可以动态扩展，但是当扩展时无法申请到足够的内存时就会抛出这个异常. 实在不理解就记住栈中放的是运行期间对象引用和基本类型数据就成哈哈哈哈,简单暴力. 本地方法栈(线程私有)本地方法栈与虚拟机栈所发挥的作用是非常相似的,他们之间的区别不过是虚拟机栈为虚拟机执行java方法(也就是字节码文件),而本地方法栈则为虚拟机中使用到的native方法服务,与虚拟机栈一样,它也会抛出StackOverFlowError异常和OutOfMemory异常. 堆(线程共享)java堆是java虚拟机管理的内存中最大的一块,在虚拟机启动时创建,它的唯一作用就是存放对象实例,就是new处理的都在堆里,即所有的对象实例以及数组都要在堆上分配内存空间. java堆是垃圾收集器管理的主要区域,因此很多时候被称为GC堆,垃圾回收算法我写在下一篇博客. java堆可以处于物理上不连续的内存空间中,只要逻辑上是连续的即可,就像我们的磁盘空间一样,在实现的时候,既可以是固定大小的,也可以是可扩展的比如加固态,书上说当前主流的虚拟机都是按照可扩展来实现的(通过-Xmx设置最大值和-Xms设置最小值). 他们博客说java的垃圾回收器在内存使用达到-Xms才开始回收. 如果在堆内存中没有完成实例分配,并且堆也不可再扩展时,将会抛出OutOfMemoryError异常. JDK1.7以后字符串常量池(String s = new String(“str”)中”str”就放在字符串常量池中)就从方法区拿到了堆里 方法区(线程共享)有的博客说方法区里面放着的都是唯一存在的东西,比如class文件和常量,静态常量这些都是唯一的嘛. 方法区用于存储已被虚拟机加载的类信息(比如全局变量的引用,(父类)类的全名称(包.类名),类的修饰符,访问权限等),常量,静态常量等数据,我觉得方法最开始也是存在于方法区中的,运行的时候才放到栈中去. 理解: 这里的常量指的是final修饰的常量和编译时期的字符串常量(即String s = “abc”中的”abc”). 这里要区别一下字符串常量池中的常量,我看他们的博客说的字符串常量池中存放的也是常量,不过只有例如String s = new String(&quot;abc&quot;),这样子创建对象时生成的常量”abc”才会放到字符串常量池中去,不过也不是没有道理啊,只有new的时候才会去堆分配空间嘛,编译期又不会去堆里搞事情对吧哈哈哈. 静态常量就是static final修饰的数据. 这里的类信息是指: 类的版本、字段、方法、接口,全局变量等信息. 在java虚拟机规范中将方法区描述为堆的一个逻辑部分,但它却有一个别名叫做Non-Heap,目的就是为了和java堆区分开了. 方法区和堆一样也不需要一定是连续的,是可扩展的. 当方法区无法满足内存分配的需求时,也会报OutOfMemoryError异常. 运行时常量池.java文件被编译后,就生成了.class字节码文件,class文件中存储了类的版本、字段、方法、接口等信息,以及常量池,这里的常量池中存放编译期生成的字面量和符号引用. 字面量和符号引用的概念 字面量可以理解为就是值本身,比如字符串的值,基本类型的值,和final常量值. 符号引用就是以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能够无歧义的定位到目标即可,类加载的时候第一次加载到这个符号时，就会将这个符号引用解析成直接引用（目标的地址). 可以这么理解: 符号引用就是一个类中（当然不仅是类，还包括类的其他部分，比如方法，字段等），引入了其他的类，可是JVM并不知道引入的其他类在哪里，所以就用唯一符号来代替，等到类加载器去解析的时候，就把符号引用找到那个引用类的地址，这个地址也就是直接引用。 运行时常量池是方法区的一部分,它的作用就是当类加载后进入方法区后,接受.class文件中的常量池中的内容,但是这并不是只放编译期的,它具有动态性,运行期间的也可以将字面量和符号引用放进去,但是这时放进去只能通过对象调用intern()方法,在JDK7及其以后(跟JDK6不一样),它只是将在字符串常量池的对象的引用放进去,注意本来对象的值是放在堆中的字符串常量池中的,这时候只是将引用放到了运行时常量池,但是字符串常量池中还在. 既然运行时常量池是方法区的一部分,当常量池无法申请到内存时就会报错OutOfMemory异常. String类的intern()方法(native方法,其设计初衷就是为了重用String对象,节省内存消耗)找到了一篇大佬的博客,看完他的博客我懂了,他里面没有细分字符串常量池和运行时常量池,大家看完我上面的博客再去看它的,注意一下区分两个常量池就可以了,博客地址: https://blog.csdn.net/seu_calvin/article/details/52291082/ 大家看完之后,再回来,我在这里用大佬的例子在这里区分一下运行时常量池和字符串常量池: 12345678910111213141516171819202122232425262728293031String str1 = new String(&quot;SEU&quot;)+ new String(&quot;Calvin&quot;);这一行代码在堆中生成了3个对象,一个值为&quot;SEU&quot;的String对象,一个值为&quot;Calvin&quot;的对象,一个值为 &quot;SEUCalvin&quot;的对象最后str1指向的是值为&quot;SEUCalvin&quot;的对象这么理解:刚开始这三个对象都在堆中,但是他们的值都在字符串常量池,是字符串常量池!!!!!!System.out.println(str1.intern() == str1);执行`str1.intern()`方法后,按照我上面说的,它先去看运行时常量池里面有没有&quot;SEUCalvin&quot;这个值没有它就去堆中的字符串常量池中去找,诶,字符串常量池里有它就把字符串常量池中&quot;SEUCalvin&quot;这个值的引用放到运行时常量池!!!!!是运行时常量池,然后返回这个引用也就是说此时`str1.intern()`返回的是str1的值在堆中的地址!!!str1本来指向的就是堆中的那个值,那他俩的地址是不是就相等了.System.out.println(str1 == &quot;SEUCalvin&quot;);这里str1指向的是堆中的&quot;SEUCalvin&quot;的地址,而直接写&quot;SEUCalvin&quot;他就会去运行时常量池中找有没有这个值,发现里面有,就直接返回其地址,就是堆中的&quot;SEUCalvin&quot;的地址,所以返回trueString str2 = &quot;SEUCalvin&quot;;//相对于上面的代码新加的一行代码，其余不变这里首先去看运行时常量池里有没有&quot;SEUCalvin&quot;这个值,发现没有,就直接在运行时常量池里创建String str1 = new String(&quot;SEU&quot;)+ new String(&quot;Calvin&quot;);这里和上面一样,他会创建三个对象在堆中,str1指向的是&quot;SEUCalvin&quot;在字符串常量池中的地址!!!!System.out.println(str1.intern() == str1); //false这里的str1.intern()它先去运行时常量池里面找有没有&quot;SEUCalvin&quot;,发现,诶,有,就直接返回了注意这里返回的是&quot;SEUCalvin&quot;在运行时常量池中的地址!!!!而str1指向的是字符串常量池中的地址,你说相等不相等嘛System.out.println(str1 == &quot;SEUCalvin&quot;); //false这里也一样,str1是字符串常量池中的地址,而&quot;SEUCalvin&quot;是运行时常量池中的地址]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>JVM_1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络面试]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F07%2F08%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%2F</url>
    <content type="text"><![CDATA[OSI七层模型和TCP/IP五层模型OSI七层模型(从上到下) 应用层 表示层 会话层 传输层 网络层 数据链路层 物理层 TCP/IP五层模型(从上到下) 应用层 传输层 网络层 数据链路层 物理层]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot-day01_2]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F07%2F07%2Fspringboot-day02%2F</url>
    <content type="text"><![CDATA[我博客里大家不懂的可以留言我嘿嘿嘿,以及这篇博客是用的war包下的maven项目,其实运行和jar包的maven项目冒的区别 springboot整合springjdbc操作数据第一步:导入依赖: &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.6.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;!--导入web启动器的依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;version&gt;2.1.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--jdbc的依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--数据库驱动依赖,我数据库是5.0版本的--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.46&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 写一个数据库配置文件application.properties放在src/main/resources目录下 #数据库配置 spring.datasource.url=jdbc:mysql://localhost:3306/springboot spring.datasource.username=root spring.datasource.password=root spring.datasource.driver-class-name=com.mysql.jdbc.Driver 写一个service层的类 @Service //表示这是一个service public class UserServiceImpl implements UserService { @Autowired //自动注入,数据源都不用自己写,它会自己创建 private JdbcTemplate template; @Override public void login(String name, String password) { String sql = &quot;insert into user(username, password) values (?,?)&quot;; template.update(sql,name, password); } } 写一个控制器 @Controller @RequestMapping(&quot;user&quot;) public class UserController { @Autowired private UserService userService; @RequestMapping(&quot;login&quot;) @ResponseBody public String add(String name, String password) { //通过userService对象调用其中的login方法 userService.login(name, password); //返回结果给客户端 return &quot;成功添加一个用户&quot;; } } 写一个专门用来启动项目的APP类,和jar包下的maven项目一样的 @EnableAutoConfiguration //扫描注解的作用,就是让注解生效 @ComponentScan({&quot;web.controller&quot;,&quot;service&quot;}) public class APP { public static void main(String[] args) { //启动项目 SpringApplication.run(APP.class, args); } } 启动之后,输入http://localhost:8080/user/login?name=usser&amp;password=999就可以在页面上输出控制器中返回的语句:成功添加一个用户,同时数据库中会新增一条记录]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot-day01_2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot-day01_2]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F07%2F07%2Fspringboot-day01_2%2F</url>
    <content type="text"><![CDATA[大家不懂得可以留言我,我尽力哈哈哈,这篇博客的所有代码都是延续的上一篇博客:springboot-day01,的代码,也都是继续jar包的maven项目继续开发的,war包的我后面再写. Web开发_静态资源的访问,这里使用springboot-day01中的代码静态资源就是指的是我们以前用servlet做web时那些放在webapp下面的什么css啊,静态html啊,js啊,图片啊之类的. 我们创建了一个jar类型和一个war类型的maven项目,这里我们要转换一下思想,就是jar类型的maven项目其实在springboot里也是可以做web开发的,就像我的上一篇博客那样子做的那样: springboot-day01. springboot默认静态资源位置应该放在classpath(classpath,类路径,也就是src目录)下,一般我们放在src/resources文件夹/自定义文件夹下面,且静态资源所在的目录名应该是以下几个: /static /public /resources /META-INF/resources 例如我们可以在src/main/resources/目录下创建static目录,并且可以在static这个目录下放一个图片alipay.png,程序启动后,输入: http://localhost/alipay.png就会看到图片了. 不过要注意哈,放静态资源的文件夹名字,只能是上面那四个当中的一个,你换名字了就找不到了,当你程序运行之后,你会发现target目录下的classes目录下会多一个你的图片文件夹名字命名的文件夹. 如图所示: web开发_全局异常捕获讲解,延续上一篇博客的代码继续写的几个有关的注解: @ExceptionHandler: 表示拦截异常. @ControllerAdvice: 这是controller的一个辅助注解,最常用的就是将声明了该注解的类作为全局异常处理的切面类,可以指定扫描范围,它约定了几种可行的返回值 如果是直接返回model类的话,需要使用@ResponseBody进行json转换(就理解为一个toString()方法的作用). 使用步骤: 先写一个处理全局异常的类,在类中写一个异常处理方法: /** * 全局异常处理类 * 用于捕获全局异常,就是他包括的地方处理异常都会跳到这里,就不用在每个出问题的地方都trycatch了 */ @ControllerAdvice //控制器切面,表示它的切入点是控制器里的方法 public class GlobalExceptionHandler { /** * 该方法用于处理出现的异常,当控制器中出现异常以后,就会跳到这里,然后将返回值以json格式输出到页面上 * */ @ExceptionHandler({RuntimeException.class, Error.class}) //表示捕获运行时异常和系统异常 @ResponseBody //表示将返回值用json格式输出到页面上 public Map&lt;String, Object&gt; exceptionHandler() { Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;errorCode&quot;, &quot;404&quot;); map.put(&quot;errorMsg&quot;, &quot;路径访问异常&quot;); return map; } } 这里写完之后,就去启动的控制器APP类中,将这个包也包含在扫描的包里面,即在@ComponentScan中添加一个springboot.exception,这样就使得app类启动的时候,会让这个异常处理类也生效,不然虚拟机不知道这个是全局异常类,它不会起到作用 @EnableAutoConfiguration @ComponentScan(basePackages = {&quot;springboot.controller&quot;,&quot;springboot.model&quot;,&quot;springboot.exception&quot;}) public class App { public static void main(String[] args) { //启动springboot项目,启动之后,HelloController和UserController都可以运行起来 SpringApplication.run(App.class, args); } } 我们现在可以在controller包下和model包下任意一个方法中故意写一个异常比如int i= 10/0,当程序运行到相应的控制器后,页面就会显示{&quot;errorCode&quot;:&quot;404&quot;, &quot;errorMsg&quot;:&quot;路径访问异常&quot;}这些字样. 渲染web页面在动态html上springboot依旧可以完美胜任,它提供了多种模板引擎的默认配置支持,主要有以下几种模板引擎: ThyMeleaf FreeMarker Velocity Groovy Mustache 注意: springboot建议使用这些模板引擎,避免使用jsp,如果一定要使用jsp将无法实现springboot的多种属性. 当使用模板引擎中的任何一个,他们的默认配置路径为: src/main/resources/templates,当然可以在模板引擎的配置属性中修改这些路径. FreeMarker的使用,这里是在jar包的maven项目下第一步:在pom.xml中导入FreeMarker的依赖包 &lt;!--导入freemarker的依赖,所有springboot的jar包的groupid都是org.springframework.boot, 即这些jar包所在的包叫org.springframework.boot--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt; &lt;/dependency&gt; 第二步,写一个控制器,然后返回一些数据 这里需要注意一下@RestController和@Controller的区别用法: @RestController是在@Controller的基础上整合了@ResponseBody注解的功能,使其可以不声明@ResponseBody也可以返回json格式,但是@RestController这个注解多用于写API,也就是给移动客户端提供接口数据的. @Controller这个注解多用于写后台,也就是web后台啦哈哈哈,他们是这么说的,我也不晓得嘿嘿,反正功能差不多,用哪个都一样. @Controller //这里就不要用RestController @RequestMapping(&quot;stu&quot;) //访问StudentController的路径为: /student public class StudentController { //增加一些数据 @RequestMapping(&quot;stuList&quot;) //访问这个方法的路径为: /list public String list(Map&lt;String, Object&gt; map) { map.put(&quot;name&quot;, &quot;student&quot;); map.put(&quot;age&quot;, 18); List&lt;Student&gt; list = new ArrayList&lt;&gt;(); list.add(new Student(&quot;stu1&quot;, 99)); list.add(new Student(&quot;stu2&quot;, 88)); map.put(&quot;list&quot;, list); //注意这里的返回值必须和上面的两个地址相同,不然访问不到 return &quot;stu/stuList&quot;;//表示调用该方法后,页面会跳转到到src/main/resources/templates/stu下的stuList这个模板页面去 } } 第三步,写一个ftl文件(先创建html文件再修改后缀为.ftl)获取数据显示 这里需要注意,这里有一个大坑 首先,所有的模板文件都要放在src/main/resources/templates文件夹下我就不用说了哈. 然后,坑的地方来了:,你看上面的控制器的返回值为“stu/stuList”,那么这里的ftl文件的访问路径就必须为stu文件夹下的stuList.ftl文件,即templates下面必须有一个文件夹名字为返回值中的stu,ftl文件名字必须为stuList.ftl且必须放在stu文件夹下,不然又会出错,会访问不到. 如果你上面控制器方法的返回值是这样的: return stuList,这就表示你应该直接创建模板文件stuList.ftl放在templates文件夹下,不能放在自定义文件夹下!!!不能放在自定义文件夹下!!!不能放在自定义文件夹下!!!不然又得出错 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 欢迎 ${name} &lt;#if age &lt; 18&gt;同学 &lt;#--这里注意要加(),因为它可能把小于符号当成完成的标志--&gt; &lt;#elseif (age &gt; 30)&gt;大叔 &lt;#else &gt;帅哥 &lt;/#if&gt; 登录 &lt;br&gt; 学生列表 &lt;br&gt; &lt;table border=&quot;1&quot;&gt; &lt;tr&gt; &lt;td&gt;名字&lt;/td&gt; &lt;td&gt;分数&lt;/td&gt; &lt;/tr&gt; &lt;#--遍历map里的list,注意排序的字段必须加双引号--&gt; &lt;#list list?sort_by(&quot;score&quot;) as stu&gt; &lt;tr&gt; &lt;#--注意这里要这么取值的话,student类中一定要有get和set方法--&gt; &lt;td&gt;${stu.name}&lt;/td&gt; &lt;td&gt;${stu.score}&lt;/td&gt; &lt;/tr&gt; &lt;/#list&gt; &lt;/table&gt; &lt;/body&gt; &lt;/html&gt; 运行后页面就会显示成这样子:]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot-day01_2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot_day01]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F07%2F06%2Fspringboot-day01%2F</url>
    <content type="text"><![CDATA[有不懂的可以留言我,我尽力帮你哈哈哈 springboot的特点轻松创建spring应用程序. 内嵌tomcat,jetty等web容器,不需要部署war文件(我们之前的项目都是要将文件打包成war包然后放到tomcat中再运行的). 简化了第三方jar包的引用,通过提供的一系列的”starter(启动器)”来简化Maven的配置,不需要添加很多依赖包. 开箱即用,尽可能自动配置spring. springboot入门案例这里创建的是maven项目,关于如何创建maven项目的话,大家看我写的这篇博客: 关于maven 我们创建两个项目 一个war结构的maven项目(就是创建maven项目的时候使用了maven骨架中的maven-web-app那个),war结构的maven项目的使用看这篇博客: [war包maven项目使用](). war包: 是指web archive,web归档文件,以.war结尾,war包代表一个web应用程序,打包放在tomcat这样的容器的webapp目录下,启动容器就可以在上面跑的. 一个jar包的maven项目(就是创建maven项目的时候使用maven骨架中的maven-quickstart那个),这篇博客都是jar包的maven项目. jar包: 是指java archive,java归档文件,以.jar结尾,就是我们平时导入的那些jar包,里面放的都是编译生成的class文件. 先以jar包的maven项目为例在pom.xml中添加spring-boot-starter-web依赖和它的父依赖,如下: &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-parent&lt;/artifactId&gt; &lt;version&gt;2.1.6.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;!--添加了web启动器依赖以后,他会自动导入web-mvc需要的依赖以及自动配置依赖等-&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; spring-boot-parent父依赖的作用: 在pom.xml中引入spring-boot-parent,它用来提供相关的默认dependency management,即相关的Maven默认依赖管理,引入以后再申明其他常用的dependency依赖的时候就不需要声明version了,上面配置文件中的spring-boot-starter-web就没有放版本,因为它默认使用父依赖中的版本,如果没有设置父依赖,就必须设置版本属性 spring-boot-starter-web的作用: 这是springweb的核心组件,支持全栈式Web开发，包括Tomcat和spring-webmvc. 写一个控制器,然后写一个main方法,把程序跑起来,如下: /** * 声明一个控制器 * RestController注解，相当于@Controller+@ResponseBody两个注解的结合， * 返回json数据不需要在方法前面加@ResponseBody注解了, * 但使用@RestController这个注解，和@Controller一样不能返回jsp,html页面，视图解析器无法解析jsp,html页面,只能直接返回return的数据 * * 声明自动配置:相当于写了spring的配置文件 */ @RestController @EnableAutoConfiguration public class HelloController { /** * 因为要通过浏览器地址栏访问,所以映射路径肯定是要有的,也就是资源路径 * @RequestMapping(path = &quot;/hello&quot;) = @RequestMapping(&quot;hello&quot;) * 有参数的话,我们把参数放在路径后面,然后写在方法中获取,如下所示 * @return */ @RequestMapping(path = &quot;/hello/{name}&quot;) @ResponseBody //把返回值转换为json,声明为@RestController,这里就可以不写了 public String hello(@PathVariable(&quot;name&quot;) String name) { return &quot;Hello Spring Boot!&quot; + name; } //启动springboot的项目 public static void main(String[] args) { SpringApplication.run(HelloController.class, args); } } 当访问`http://localhost:8080/hello/张三`的时候 界面就会输出`&quot;Hello Spring Boot!&quot;张三` springboot启动的两种方式_都是以jar方式为例这种方式的项目不用部署到tomcat中,打包后启动main方法就相当于所有的控制器都跑起来了,就可以运行了哈哈哈. 第一种: 如下面的例子,在每个控制器中都配置EnableAutoConfiguration,并使用SpringApplication启动程序. *这种方法不推荐,因为只能启动一个控制器,也就是每个类中都要写main方法,因为一个类就是一个控制器嘛. 例如下面的这个控制器 @RestController @EnableAutoConfiguration @RequestMapping(&quot;user&quot;) public class UserController { //这样配置要和上面的连起来看,相当于@RequestMapping(&quot;/user/{id}&quot;) @RequestMapping(&quot;{id}&quot;) /** * 通过id查询用户的信息 * * 启动后在地址栏输入:http://localhost:8080/user/10 * 在页面上显示:{&quot;id&quot;:10,&quot;username&quot;:&quot;user&quot;,&quot;password&quot;:&quot;123&quot;} */ public User findUserInfo(@PathVariable() int id) { //User类中有id,姓名,密码三个字段, User user = new User(id, &quot;user&quot;, &quot;123&quot;); //会将user对象转换为json对象输出,就算我User类中没有toString()方法也一样 return user; } public static void main(String[] args) { //启动springboot项目 SpringApplication.run(App.class, args); } } 启动之后,当访问`http://localhost:8080/user/10`的时候 界面就会输出: {&quot;id&quot;:18,&quot;username&quot;:&quot;user&quot;,&quot;password&quot;:&quot;123&quot;} 第二种: 自己创建一个类,假设为App类,在该类里面配置两个东西(推荐使用),如下: /** * @ComponentScan()中的参数 * basePackages={&quot;包1&quot;,&quot;包2&quot;,...},它的参数是一个数组, * 表示这个包下面的类的控制器都会被扫描 * 而且包路径是相对路径,相对于以java为名的这个包,如果为java.springboot.controller只需要写springboot.controller就可以了 */ @EnableAutoConfiguration @ComponentScan(basePackages = {&quot;springboot.controller&quot;,&quot;springboot.model&quot;}) public class App { public static void main(String[] args) { //启动springboot项目 SpringApplication.run(App.class, args); } } 此时上面两个控制器的main方法还有@EnableAutoConfiguration都可以删掉了 App类的main方法启动之后,就相当于HelloController和UserController两个控制器都运行了 输入对应的网址都可以访问到两个控制器对应的方法,得到相应的输出 与各自运行main方法效果完全一致 springboot的依赖介绍maven项目的核心就是pom.xml文件,POM( Project Object Model，项目对象模型)定义了项目的基本信息，用于描述项目如何构建，声明项目依赖等。 EnableAutoConfiguration 这个注解的作用在于让springboot根据应用所声明的依赖来对spring框架进行自动配置,减少开发人员的工作量,就相当于applicationPageContext的功能. springboot推荐采用基于java注解的配置方式而不是传统的xml,只需要在主配置java类上添加@EnableAutoConfiguration注解就可以启动自动配置. * @RestController(设置该类为控制器)和@RequestMapping(配置映射路径)由springmvc提供,用来创建rest服务,本身和springboot冒的关系. spring-boot-starter: 核心pom,包含自动配置支持,日志库以及对YAML配置文件的支持. spring-boot-starter-web: 这是springweb的核心组件,支持全栈Web开发，包括Tomcat和spring-webmvc. spring-boot-starter-amqp: 通过 spring-rabbit 支持 AMQP spring-boot-starter-aop: 包含 spring-aop 和 AspectJ 来支持面向切面编程（AOP）. spring-boot-starter-batch: 支持 Spring Batch，包含 HSQLDB。 spring-boot-starter-data-jpa: 包含 spring-data-jpa、spring-orm 和 Hibernate 来支持 JPA。 spring-boot-starter-data-mongodb: 包含 spring-data-mongodb 来支持 MongoDB。 spring-boot-starter-data-rest: 通过 spring-&gt;data-rest-webmvc 支持以 REST 方式暴露 Spring Data 仓库。 spring-boot-starter-jdbc: 支持使用 JDBC 访问数据库. spring-boot-starter-security: 包含 spring-security。 spring-boot-starter-test: 包含常用的测试所需的依赖，如 JUnit、Hamcrest、Mockito 和 spring-test 等。 spring-boot-starter-velocity: 支持使用 Velocity 作为模板引擎。 spring-boot-starter-websocket: 支持使用 Tomcat 开发 WebSocket 应用。 spring-boot-starter-ws: 支持Spring Web Services spring-boot-starter-actuator: 添加适用于生产环境的功能，如性能指标和监测等功能。 spring-boot-starter-remote-shell: 添加远程 SSH 支持 spring-boot-starter-jetty: 使用 Jetty 而不是默认的 Tomcat 作为应用服务器。 spring-boot-starter-log4j: 添加 Log4j 的支持 spring-boot-starter-logging: 使用 Spring Boot 默认的日志框架 Logback spring-boot-starter-tomcat: 使用 Spring Boot 默认的 Tomcat 作为应用服务器。]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot_day01</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring整合servlet]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F07%2F06%2Fspring%E6%95%B4%E5%90%88servlet%2F</url>
    <content type="text"><![CDATA[不懂可以给我留言,虽然我也很菜 web整合servlet+spring整合步骤: 导包,除了导入spring需要的包以外,还要新导入一个: spring-web. 我等会把包都放这里: 所有jar包,还有一个如何下载spring的jar包的博客也放在这里: 如何在官网下载jar包. 这个是要创建一个web项目了哈,web项目会创建把,idea创建的时候选择java enterprise那个选项就可以了,然后在web-inf下面新建一个lib文件夹,将jar包放在里面,然后将lib文件夹添加为库就好了. 创建servlet,service(dao层我就省了哈,做个演示) --servlet代码 @WebServlet(name = &quot;UserServlet&quot;, urlPatterns = &quot;/user&quot;) public class UserServlet extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //设置编码 response.setContentType(&quot;text/html;charset=utf-8&quot;); //获取参数 String name = request.getParameter(&quot;username&quot;); //使用web.xml监听spring容器,使得其不论点击多少次页面都只会有一个容器,然后通过spring容器管理对象 //获取容器对象 ApplicationContext context = WebApplicationContextUtils.getWebApplicationContext(this.getServletContext()); UserService userService = (UserService) context.getBean(&quot;userService&quot;); System.out.println(userService); userService.addUser(name); //做出响应 response.getWriter().write(&quot;成功添加用户&quot;); } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request, response); } } ---service代码 public class UserService { public void addUser(String username) { System.out.println(&quot;成功添加了用户:&quot; + username); } } 写spring的配置文件applicatonContext.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;userService&quot; class=&quot;UserService&quot;&gt;&lt;/bean&gt; &lt;/beans&gt; 为了防止多次访问页面会生成多个容器对象,我们需要在web.xml中配置对spring的监听,让内存中仅存一个容器对象,这时就会用到spring-web这个spring和web整合的jar包了,web.xml配置文件如下: &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;!--配置容器的属性,也就是spring文件的加载路径--&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:beans.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!--监听器,监听容器加载--&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;/web-app&gt; 在servlet中调用即可]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring整合servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring-04-3]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F07%2F05%2Fspring-04-3%2F</url>
    <content type="text"><![CDATA[大家不懂可以留言我,虽然我也很菜 事务的基本知识,我专门有一篇博客写了: 事务基础 spring事务管理spring为我们提供给了事务管理,我们就不需要手动去开启事务,关闭事务了,我们只需要配置一下就可以了,它就会帮我们把事务放在service层去. spring提供了事务jar包: spring-tx-5.0.2-RELEASE.jar,里面大部分都是接口,其中有几个接口我们需要注意一下子. SavepointManager: 保存点管理器,比如说,我这个事务里面包括四个操作,前两个如果对了就一定要提交,后两个无所谓,那么我们就可以在前两个操作后设置一个保存点savepoint对象,然后当第三个操作出错了之后,回滚到保存点对象的位置,前面的提交,这样就可以保证前两个操作一定提交了. PlatformTransactionManager:平台事务管理器, spring要管理事务,必须使用事务管理器,进行事务配置时,必须配置事务管理器. TransactionStatus:事务状态,spring用于记录当前事务运行状态,例如: 是否有保存点,事务是否完成等,spring根据状态进行相应操作. TransactionDefinition:事务详情(包括事务定义,事务属性等),spring用于确定事务具体详情,例如: 隔离级别,是否只读,超时时间等,进行事务配置时,必须配置详情,spring会将配置项封装到对象实例中. jdbc管理数据库通过spring管理事务 导入包: jdbc开发数据库的话,要导入jdbc对应的包(包里面放的是spring事务中接口的实现类): spring-jdbc-5.0.2.RELEASE.jar,以及spring事务管理的jar包. 通过spring-jdbc包下面的PlatformTransactionManager接口的实现类DataSourceTransactionManager作为事务管理器来实现事务管理 TransactionDefinition接口中的成员变量,隔离的变量在开头链接的博客里面有,这里只看传播行为的几个变量 传播行为用于解决在两个业务中如何共享事务. PROPAGATION_REQUIRED(默认值),required表示必须,即支持当前事务,A如果有事务,B将使用该事务,如果A没有事务,B将创建一个新的事务. PROPAGATION_SUPPORTS,support表示支持,即支持当前事务,A如果有事务,B将使用该事务,如果A没有事务,B将以非事务执行. PROPAGATION_MANDATORY,mandatory表示强制,即支持当前事务,A如果有事务,B将使用该事务,如果A没有事务,B将抛出异常. PROPAGATION_REQUIRES_NEW,requires_new表示必须新的,A如果有事务,将A的事务挂起,B创建一个新的事务执行,如果A没有事务,B创建一个新的事务执行. PROPAGATION_NOT_SUPPORTED,not_supported表示不支持,A如果有事务,将A的事务挂起,B以非事务执行,如果A没有事务,B以非事务执行. PROPAGATION_NEVER,never表示从不,A如果有事务,B将抛出异常,A如果没有事务,B将以非事务执行. PROPAGATION_NESTED,nested表示嵌套,A和B底层采用保存点机制,形成嵌套事务. 转账案例_手动管理事务(了解就可以了 )实现过程 创建数据库表并插入两条数据 CREATE TABLE account( id INT PRIMARY KEY AUTO_INCREMENT, username VARCHAR(15), money INT ); INSERT INTO account(username, money) VALUES(&quot;user1&quot;, 1000); INSERT INTO acCOUNT(username, money) VALUES(&quot;user2&quot;, 1000); 导入jar包:创建的spring项目的话,大部分jar包它都有,我们只需要导入c3p0连接池的jar包和数据库驱动的jar包就可以了,链接如下: jar包 Dao层 public class AccountDao extends JdbcDaoSupport { //进账 public void in(int money, String inner) { String sql = &quot;update account set money = money + ? where username = ?&quot;; super.getJdbcTemplate().update(sql,money, inner); System.out.println(&quot;已成功向&quot;+ inner + &quot;存钱&quot; + money + &quot;元&quot;); } //出账 public void out(int money, String outer) { String sql = &quot;update account set money = money - ? where username = ?&quot;; super.getJdbcTemplate().update(sql,money, outer); System.out.println(&quot;已成功从&quot;+ outer + &quot;取钱&quot; + money + &quot;元&quot;); } } service层 public class AccountService { //生成dao层对象,方便等会调用方法 private AccountDao accountDao; //提供set方法,等会通过spring注入AccountDao对象 public void setAccountDao(AccountDao accountDao) { this.accountDao = accountDao; } //spring配置事务模板 private TransactionTemplate transactionTemplate; //提供set方法,由spring注入 public void setTransactionTemplate(TransactionTemplate transactionTemplate) { this.transactionTemplate = transactionTemplate; } //转账方法 public void transfer(String inner, String outer, int money) { //执行事务,出错之后就会自动回滚 transactionTemplate.execute(new TransactionCallbackWithoutResult() { @Override protected void doInTransactionWithoutResult(TransactionStatus transactionStatus) { //进账 accountDao.in(money, inner); int i = 10 / 0; //出账 accountDao.out(money, outer); } }); } } 测试类 public class UnitClass { @Test public void test() { //获取容器对象 ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans1.xml&quot;); //获取service层对象 AccountService service = (AccountService) context.getBean(&quot;accountService&quot;); //调用方法 service.transfer(&quot;user1&quot;, &quot;user2&quot;, 500); } } xml配置文件 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!--让spring去读我们的连接数据库的配置文件--&gt; &lt;context:property-placeholder location=&quot;db.properties&quot;&gt;&lt;/context:property-placeholder&gt; &lt;!--配置数据源对象,因为jdbctemplate必须要用到数据源--&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;${driverClass}&quot;&gt;&lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;${jdbcUrl}&quot;&gt;&lt;/property&gt; &lt;property name=&quot;user&quot; value=&quot;${user}&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;${password}&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--配置事务管理器--&gt; &lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;!--通过看源码知道,它需要注入一个数据源属性--&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--配置一个事务模板对象--&gt; &lt;bean id=&quot;template&quot; class=&quot;org.springframework.transaction.support.TransactionTemplate&quot;&gt; &lt;!--通过看源码知道,我们还需要配置一个事务管理器--&gt; &lt;property name=&quot;transactionManager&quot; ref=&quot;txManager&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--创建dao层对象,同时给其注入数据源,因为jdbctemplate的创建需要数据源--&gt; &lt;bean id=&quot;dao&quot; class=&quot;transaction_example1.dao.AccountDao&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--给service层注入dao层对象--&gt; &lt;bean id=&quot;accountService&quot; class=&quot;transaction_example1.service.AccountService&quot;&gt; &lt;property name=&quot;accountDao&quot; ref=&quot;dao&quot;&gt;&lt;/property&gt; &lt;!--配置事务管理模板--&gt; &lt;property name=&quot;transactionTemplate&quot; ref=&quot;template&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/beans&gt; properties配置文件 driverClass=com.mysql.jdbc.Driver jdbcUrl=jdbc:mysql://localhost:3306/spring_day04 user=root password=root 转账案例_spring用工厂bean生成代理半自动管理事务(了解)注意: 这里的动态代理就是JDK自带的那种,必须针对接口,关于动态代理,参考这篇博客: 动态代理. xml中属性详情必须配,不能少 一个很恼火的错误:com.sun.proxy.$Proxy0 cannot be cast to ,这就是你在容器中获取service代理对象或者自己创建代理对象的时候,生成的对象不是接口类型,而是对象类型导致的,例子如下: 有一个接口User,它的实现类是UserImpl,现在要生成代理对象 1. UserImpl u1 = (UserImpl)Proxy.newProxyInstance(参数省略...); 这个就会报错--`com.sun.proxy.$Proxy0 cannot be cast to` 2. User u2 = (User)Proxy.newProxyInstance(参数省略...); 这个写法才是正确的,因为jdk的动态代理是针对接口的,记住记住!!!! spring提供了管理事务的代理工厂bean,叫TransactionProxyFactoryBean,我们通过代理工厂的话就不用配置事务模板了,代码相对于纯手动管理要简单一些哈哈哈 实现过程 service类 /** * 在service层中调用dao层的方法 */ public class AccountService implements Account{ //生成dao层对象,方便等会调用方法 private AccountDao accountDao; //提供set方法,等会通过spring注入AccountDao对象 public void setAccountDao(AccountDao accountDao) { this.accountDao = accountDao; } //转账方法 public void transfer(String inner, String outer, int money) { //进账 accountDao.in(money, inner); int i = 10 / 0; //出账 accountDao.out(money, outer); } } 测试类 public class UnitClass { @Test public void test() { //获取容器对象 ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans2.xml&quot;); //获取service层的代理对象,注意这里的Account必须是接口啊,不能是其实现类 Account service = (Account) context.getBean(&quot;proxyService&quot;); //调用方法 service.transfer(&quot;user1&quot;, &quot;user2&quot;, 500); } } xml文件 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!--让spring去读我们的连接数据库的配置文件--&gt; &lt;context:property-placeholder location=&quot;db.properties&quot;&gt;&lt;/context:property-placeholder&gt; &lt;!--配置数据源对象,因为jdbctemplate必须要用到数据源--&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;${driverClass}&quot;&gt;&lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;${jdbcUrl}&quot;&gt;&lt;/property&gt; &lt;property name=&quot;user&quot; value=&quot;${user}&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;${password}&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--配置事务管理器--&gt; &lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;!--通过看源码知道,它需要注入一个数据源属性--&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--创建dao层对象,同时给其注入数据源,因为jdbctemplate的创建需要数据源--&gt; &lt;bean id=&quot;dao&quot; class=&quot;transaction_example2.dao.AccountDao&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--配置service,给service层注入dao层对象--&gt; &lt;bean id=&quot;accountService&quot; class=&quot;transaction_example2.service.AccountService&quot;&gt; &lt;property name=&quot;accountDao&quot; ref=&quot;dao&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--配置一个工厂代理--&gt; &lt;bean id=&quot;proxyService&quot; class=&quot;org.springframework.transaction.interceptor.TransactionProxyFactoryBean&quot;&gt; &lt;!--配置接口--&gt; &lt;property name=&quot;proxyInterfaces&quot; value=&quot;transaction_example2.service.Account&quot;&gt;&lt;/property&gt; &lt;!--目标对象--&gt; &lt;property name=&quot;target&quot; ref=&quot;accountService&quot;&gt;&lt;/property&gt; &lt;!--切面对象不用写,spring帮我们做了--&gt; &lt;!--配置事务管理器--&gt; &lt;property name=&quot;transactionManager&quot; ref=&quot;txManager&quot;&gt;&lt;/property&gt; &lt;!--配置事务属性,也就是事务详情 key:哪些方法需要使用事务,写方法名 value: 写事务的详情控制 格式: propagation(传播行为),isolation(隔离级别),readonly(是否只读) -Exception(异常回滚),+Exception(异常提交) 前两个必须写,后面的可以不写 当设置了只读之后,就说明这个代理对象只能读,不能写,所以对数据库的修改会失败. 设置了+Exception之后,表示就算有异常,异常前面的语句照样提交,类似于保存点的功能 --&gt; &lt;property name=&quot;transactionAttributes&quot;&gt; &lt;props&gt; &lt;!--有多个方法就写多个prop标签就好了--&gt; &lt;prop key=&quot;transfer&quot;&gt;PROPAGATION_REQUIRED,ISOLATION_DEFAULT,+Exception&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/beans&gt; spring基于AOP的事务管理(这个要掌握)手动管理事务我们每次有新的业务方法都还要加到事务中去,还要自己手动生成对象调用,这就很麻烦,而半自动代理,还是要配置什么隔离级别一堆,还是麻烦,所以我们决定用AOP切面改进. 注意 如果我们service层中的类实现了接口,比如上面的AccountService,那么在容器内获取该对象的时候,就必须是接口类型的,因为这个就是通过代理对象完成的,只是不需要我们配置代理对象而已. 如果service层中的类没有实现接口,那么在在容器内获取该对象的时候,就直接写类类型就可以,不需要是接口类型,我的例子里实现了接口,所以只能是接口类型. 使用案例及步骤(相对于上面一个半自动管理来说,这里只修改xml文件): xml文件 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt; &lt;!--让spring去读我们的连接数据库的配置文件--&gt; &lt;context:property-placeholder location=&quot;db.properties&quot;&gt;&lt;/context:property-placeholder&gt; &lt;!--配置数据源对象,因为jdbctemplate必须要用到数据源--&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;${driverClass}&quot;&gt;&lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;${jdbcUrl}&quot;&gt;&lt;/property&gt; &lt;property name=&quot;user&quot; value=&quot;${user}&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;${password}&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--配置事务管理器--&gt; &lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;!--通过看源码知道,它需要注入一个数据源属性--&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--创建dao层对象,同时给其注入数据源,因为jdbctemplate的创建需要数据源--&gt; &lt;bean id=&quot;dao&quot; class=&quot;transaction_example3.dao.AccountDao&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--配置service,给service层注入dao层对象--&gt; &lt;bean id=&quot;accountService&quot; class=&quot;transaction_example3.service.AccountService&quot;&gt; &lt;property name=&quot;accountDao&quot; ref=&quot;dao&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--1. 配置作为通知使用的事务管理器,使用前要在头部加上标签的引用,就是xmlns那些--&gt; &lt;tx:advice transaction-manager=&quot;txManager&quot; id=&quot;myAdvice&quot;&gt; &lt;!--配置事务详情:传播行为,隔离级别等,使用aop配置时都可以省略,自动使用默认值--&gt; &lt;tx:attributes&gt; &lt;!--方法就是我们要被事务控制的方法,我们这里是转账方法--&gt; &lt;tx:method name=&quot;transfer&quot;/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!--2. 使用spring的aop标签来配置切面 这里切面中的通知就是事务,是由spring的事务管理器管理的 切入点就还是转账方法 在这里区分一下切入点和连接点,一个类中的所有方法都是连接点 但是只有要被通知进行功能增强的方法才叫切入点--&gt; &lt;aop:config&gt; &lt;!--配置一个切入点--&gt; &lt;aop:pointcut id=&quot;myPoint&quot; expression=&quot;execution(* transaction_example3.service.*.transfer(..))&quot;&gt;&lt;/aop:pointcut&gt; &lt;!--3. 将事务与切入点关联--&gt; &lt;aop:advisor advice-ref=&quot;myAdvice&quot; pointcut-ref=&quot;myPoint&quot;&gt;&lt;/aop:advisor&gt; &lt;/aop:config&gt; &lt;/beans&gt; spring基于注解的事务管理(这个也要掌握)不过事务管理的话一般还是写在xml里比较好,因为要是service很多的话,也懒得写,在xml里还一目了然些,不过没关系啦,看自己习惯,咋都行. 在xml中配置使用注解进行事务管理的时候这里有个大坑: 配置如下,其中特别注意配置事务管理器的id，这个id只能写transactionManager,不能写其他的,不能写其他的,写其他的就会报错: NoSuchBeanDefinitionException: No bean named ‘transactionManager’ available &lt;!--1. 配置事务管理器--&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;!--通过看源码知道,它需要注入一个数据源属性--&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--2. 配置事务的注解驱动,告诉虚拟机由注解来完成事务操作--&gt; &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt; 实现步骤(没写的就说明和上面的一致,这里只有service和xml变化了) service代码 /** * 在service层中调用dao层的方法 * 注解写在类名上,表示该类所有方法都会被事务控制 * 如果想事务控制只对某一个方法生效,将注解写在对应方法名上就行 */ public class AccountService{ //生成dao层对象,方便等会调用方法 private AccountDao accountDao; //提供set方法,等会通过spring注入AccountDao对象 public void setAccountDao(AccountDao accountDao) { this.accountDao = accountDao; } //转账方法,注解也可以写成@Transactional @Transactional(propagation = Propagation.REQUIRED, isolation = Isolation.DEFAULT) public void transfer(String inner, String outer, int money) { //进账 accountDao.in(money, inner); //int i = 10 / 0; //出账 accountDao.out(money, outer); } } xml配置 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt; &lt;!--让spring去读我们的连接数据库的配置文件--&gt; &lt;context:property-placeholder location=&quot;db.properties&quot;&gt;&lt;/context:property-placeholder&gt; &lt;!--配置数据源对象,因为jdbctemplate必须要用到数据源--&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;${driverClass}&quot;&gt;&lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;${jdbcUrl}&quot;&gt;&lt;/property&gt; &lt;property name=&quot;user&quot; value=&quot;${user}&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;${password}&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;tx:annotation-driven&gt;&lt;/tx:annotation-driven&gt; &lt;!--创建dao层对象,同时给其注入数据源,因为jdbctemplate的创建需要数据源--&gt; &lt;bean id=&quot;dao&quot; class=&quot;transaction_example4.dao.AccountDao&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--配置service,给service层注入dao层对象--&gt; &lt;bean id=&quot;accountService&quot; class=&quot;transaction_example4.service.AccountService&quot;&gt; &lt;property name=&quot;accountDao&quot; ref=&quot;dao&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--1. 配置事务管理器--&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;!--通过看源码知道,它需要注入一个数据源属性--&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--2. 配置事务的注解驱动,告诉虚拟机由注解来完成事务操作--&gt; &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt; &lt;/beans&gt;]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring-04-3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态代理]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F07%2F04%2F%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[有不懂的可以留言我,虽然我也很菜 动态代理概述及实现动态代理概述 代理: 本来应该自己做的事情,请了别人来做,被请来做事的人叫做代理对象. 举例: 春节回家买不到车票请人代买,找房子懒得自己跑就通过中介找. 动态代理: 在程序运行过程中产生的这个代理对象,而程序运行过程中产生对象其实就是反射的内容,所以,动态代理就是通过反射来生成的一个代理. 在java中java.lang.reflect包下提供了Proxy类和InvocationHandler接口,通过使用这个类和接口可以生成动态代理对象,JDK提供的代理只能针对接口做代理,对类生成动态代理对象可以通过cglib,在spring那里有提到,我晚点写. 创建动态代理对象流程: Proxy类中的方法: public static Object newProxyInstance（ClassLoader loader， Class &lt;？&gt; [] interfaces， InvocationHandler h）会生成动态代理对象,也就是参数中的接口的代理实例. loader表示被代理对象的类加载器,首先我们要拿到代理对象的字节码文件对象,然后通过Class的静态方法getClassLoader() 方法就可以得到类加载器了. interfaces表示被代理对象实现的接口. 最终会调用InvocationHandler(它是由代理实例的调用处理程序实现的接口,也就是上面的h实现的接口)中的Object invoke​(Object proxy, Method method, Object[] args)方法,实现在代理实例上处理方法调用并返回结果,完成动态代理. proxy这个参数是被代理对象,不是代理对象哈,比如我请人买票,我就是被代理对象,这里的proxy指的是我. method参数表示要执行的方法,比如我请人买票,这个方法就是买票. Object[] args表示method方法的参数,比如我请人买票,那么起始地址和到达地址就可以作为参数,如果method方法没有参数就不给就可以了. 我们在通过动态代理实现功能的时候,代理类要实现InvocationHandler这个接口并重写其invoke方法,这样才能作为调用处理程序来实现代理. 利用动态代理实现权限校验和日志记录代码]]></content>
      <categories>
        <category>javase</category>
      </categories>
      <tags>
        <tag>动态代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring-04-2]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F07%2F04%2Fspring-04-2%2F</url>
    <content type="text"><![CDATA[JdbcTemplate(jdbc模板)简介 JdbcTemplate是用于操作jdbc的工具类,是spring对jdbc的封装类,用于简化jdbc的操作,由spring提供,它需要依赖于连接池和DataSource(数据源,在jdbctemplate中它是一个属性). 注意区分连接池和数据源的关系: 连接池是用来管理池中的连接对象,自动分配连接对象并对闲置的连接进行回收,连接池中的连接对象是由数据源创建的. 数据源也就是数据的来源,用来连接数据库,创建连接对象,它存储了建立数据库所需要的信息,算是数据库的抽象映射,即一个数据源对应一个数据库,调用一次数据源就可以获得一个连接. 用一个例子来说就是: 一个水池,连了很多水管,这个水池就是连接池,水管就是很多连接,这些水管都是从水库(水库就是数据库)送过来,水管就是数据源. JDBC(java数据库连接)是一种用于执行sql语句的java API. ODBC(开发数据库连接),是微软公司提供的一组对数据库访问的标准API,这个功能和JDBC一样的,都是操作数据库的用来. DBCP(数据库连接池),是java数据库库连接池的一种,是阿帕奇开发的,不能回收空闲连接,它只有最大连接数没有最大空闲连接时间,当连接数超过最大连接数时，所有连接都会被断开. c3p0是一个开源的jdbc连接池,spring用它比较多一点,它可以自动回收空闲连接,它提供最大空闲时间,当连接超过最大空闲连接时间时，当前连接就会被断掉. druid德鲁伊,阿里开发的连接池,支付宝,淘宝用的,很牛逼. 关于上述三个连接池的区别超链接 使用案例: 导入c3p0jar包和数据库驱动(我会一起放到代码里的) 根据数据库的字段,配置对应JavaBean数据模型,起名为User 配置c3p0,使得数据源由spring创建,不用自己每次手动创建 使用JdbcTemplate 案例代码 jar包 使用JdbcDaoSupport这是一个spring提供的抽象类,里面包含了生成数据源和获取jdbctemplate的方法,我们的dao继承了这个类之后,我们就不用自己去定义jdbctemplate属性了,又可以简化一点开发. 使用JdbcDaoSupport+xml简化操作案例代码. 使用JdbcDaoSupport和配置文件简化操作案例代码. 这里的配置文件里面写的就是连接数据库需要的信息,比如驱动,url,登录账号密码等,配置文件记得要放在src目录下.]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>JdbcTemplate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[反射案例]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F07%2F03%2F%E5%8F%8D%E5%B0%84%E6%A1%88%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[有不懂的可以留言我,虽然我也很菜 Class.forName()读取配置文件举例以榨汁机榨汁为案例 配置文件config.properties: reflect_examples.Orange //注意将配置文件放在src下 //然后写某个类的相对路径就可以了 /** * 当我们想喝苹果汁就要注释掉喝橘子汁的代码 * 想喝哪种果汁就要注释掉其它果汁的代码,不断修改源代码,不好. * * 当我们通过反射的时候,我们可以只修改配置文件,而不需要动源码 */ public class Example_1_ForName { public static void main(String[] args) throws ClassNotFoundException, IOException, IllegalAccessException, InstantiationException { //1. 没有反射,只用到了多态的时候 /*//这就相当于买了一个榨汁机 Juicer juicer = new Juicer(); //这就相当于把苹果放进榨汁机,用榨汁机榨了一杯苹果汁 //juicer.getJuice(new Apple()); //这就相当于把橙子放进榨汁机,用榨汁机榨了一杯橙子汁 juicer.getJuice(new Orange());*/ //2. 用反射和配置文件 //先拿到apple类的字节码文件 //这样写就写死了,配置文件没有起到作用 //Class clazz = Class.forName(&quot;main.reflect_examples.Apple&quot;); /** * 正确写法应该这样子: * 1. 创建一个流文件,读取一行 * 2. 根据流文件中取到的那一行去创建字节码文件对象 * 3. 通过字节码文件对象创建该字节码文件对象所表示的类的实例,这里相当于创建一个苹果的实例对象 * 4. 我们以后想喝其它水果的果汁,直接改配置文件就可以了 */ BufferedReader reader = new BufferedReader(new FileReader(&quot;src/config.properties&quot;)); Class clazz = Class.forName(reader.readLine()); Fruit fruit = (Fruit) clazz.newInstance(); //榨汁机榨汁 Juicer juicer = new Juicer(); juicer.getJuice(fruit); } } //利用多态把苹果向上抽取为水果 interface Fruit{ public abstract void squeeze(); } class Apple implements Fruit{ //榨汁功能 @Override public void squeeze() { System.out.println(&quot;榨了一杯苹果汁!&quot;); } } class Orange implements Fruit{ //榨汁功能 @Override public void squeeze() { System.out.println(&quot;榨了一杯橙子汁!&quot;); } } //通过榨汁机榨汁 class Juicer { /*//把苹果放到榨汁机里通过榨汁机榨苹果汁 public void getJuice(Apple apple) { apple.squeeze(); } //把苹果放到榨汁机里通过榨汁机榨苹果汁 public void getJuice(Orange orange) { orange.squeeze(); }*/ //利用多态后的写法 public void getJuice(Fruit fruit) { fruit.squeeze(); } } 通过反射获取带参构造函数并使用我们上面榨汁机例子中使用到了newInstance()这个方法来获取字节码文件所表示的类的实例对象,此时使用的是无参构造函数,当我们想通过带参构造函数创建时,就不能这样子用了,就要用到其他方法. 使用案例及步骤: /** * 根据带参构造创建实例举例: * 1. 可以先通过调用Class类的getConstructor(String.class, int.class)获取一个指定的构造函数 * 2. 然后再调用Constructor类的newInstance(&quot;张三&quot;, 18)方法来创建实例对象 */ public class Example_1_ForName2 { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException { //注意这里的路径是相对路径,idea右键会直接有赋值相对路径的选项 Class clazz = Class.forName(&quot;reflect_examples.Person&quot;); //获取该字节码文件对象中所有公共构造方法 Constructor[] constructors = clazz.getConstructors(); for (int i = 0; i &lt; constructors.length; i++) { System.out.println(constructors[i]); } //获取对应构造函数的Constructor对象 Constructor constructor = clazz.getConstructor(String.class, int.class, double.class); Person person = (Person) constructor.newInstance(&quot;李四&quot;, 18, 99); System.out.println(person); } } //创建一个person类 class Person { private String name; private int age; private double score; public Person(String name, int age, double score) { this.name = name; this.age = age; this.score = score; } @Override public String toString() { return &quot;Person{&quot; + &quot;name=&apos;&quot; + name + &apos;\&apos;&apos; + &quot;, age=&quot; + age + &quot;, score=&quot; + score + &apos;}&apos;; } } 通过反射获取成员变量并使用使用案例及步骤: /** * 获取成员变量并使用举例: * 1. 可以先通过调用Class类的getConstructor(String.class, int.class)获取一个指定的构造函数 * 2. 然后再调用Constructor类的newInstance(&quot;张三&quot;, 18)方法来创建实例对象 * 3. 通过getFields()获取Class对象所表示的类的所有公共字段 * 千万注意这里是公共字段哈,只能是public的,private,默认,propected的它是访问不到的 * 如果我们字段是private修饰的,我们可以用getDeclaredFields(),它不管什么修饰符修饰都可以访问到 * 4. 通过getField(string name)返回一个Field对象,表示name这个公共字段的对象. * 也要注意这个修改的属性也得是public的哈 * 如果不是public修饰的,我们就要去除它的权限 * 在反射面前,一切都是赤果果的哈哈哈哈 */ public class Example_1_ForName3 { public static void main(String[] args) throws Exception{ //注意这里的路径是相对路径,idea右键会直接有赋值相对路径的选项 Class clazz = Class.forName(&quot;reflect_examples.Person&quot;); //获取该字节码文件对象中所有公共构造方法 Constructor[] constructors = clazz.getConstructors(); for (int i = 0; i &lt; constructors.length; i++) { System.out.println(constructors[i]); } //获取对应构造函数的Constructor对象 Constructor constructor = clazz.getConstructor(String.class, int.class, double.class); Person person = (Person) constructor.newInstance(&quot;zhannsan&quot;, 18, 99); System.out.println(person); System.out.println(&quot;------------&quot;); //获取所有属性字段 Field[] fields = clazz.getDeclaredFields(); for (int i = 0; i &lt; fields.length; i++) { System.out.println(fields[i]); } //获取name属性表示的field对象 Field field = clazz.getDeclaredField(&quot;name&quot;); //去除私有权限 field.setAccessible(true); //修改person对象的属性name的值 field.set(person,&quot;李四&quot;); System.out.println(person); } } //创建一个person类 class Person { private String name; int age; protected double score; public Person(String name, int age, double score) { this.name = name; this.age = age; this.score = score; } @Override public String toString() { return &quot;Person{&quot; + &quot;name=&apos;&quot; + name + &apos;\&apos;&apos; + &quot;, age=&quot; + age + &quot;, score=&quot; + score + &apos;}&apos;; } } 通过反射获取方法并使用使用案例及步骤: /** * 获取方法并使用举例: * 1. 可以通过getDeclaredMethods()获取所有方法 * 2. 通过Class.getMethod(String.class...) * Class.getDeclaredMethod(Srting.class...)方法可以获取类中的指定方法. * 3. 调用method.invoke(Object, Object...)可以调用该方法,表示对象obj调用参数为object的方法method */ public class Example_1_ForName4 { public static void main(String[] args) throws Exception{ //获取Class对象 Class clazz = Class.forName(&quot;reflect_examples.Person&quot;); //通过无参构造方法创建实例对象 Person person = (Person) clazz.newInstance(); System.out.println(&quot;------------&quot;); //查看所有方法 Method[] methods = clazz.getDeclaredMethods(); for (int i = 0; i &lt; methods.length; i++) { System.out.println(methods[i]); } //生成eat方法对象 Method eat = clazz.getDeclaredMethod(&quot;eat&quot;); //调用方法,即person对象调用方法无参方法eat eat.invoke(person); } } //创建一个person类 class Person { public Person() { } public void eat() { System.out.println(&quot;今天吃了大龙虾!&quot;); } } 通过反射越过泛型检查要求: ArrayList的一个对象,想在这个集合中添加一个字符串数据,怎么整? 这里我们就要知道泛型起作用是在编译期,在运行期泛型会被擦除掉,也就是说,我们生成.class文件后,泛型就没了. 使用案例及步骤: /** * 要求: ArrayList&lt;Integer&gt;的一个对象想在这个集合中添加一个字符串数据 */ public class Example_1_ForName5 { public static void main(String[] args) throws Exception { ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(1); list.add(2); list.add(3); //获取字节码文件对象 Class clazz = Class.forName(&quot;java.util.ArrayList&quot;); //拿到add方法对象 Method method = clazz.getDeclaredMethod(&quot;add&quot;, Object.class); //执行add方法,表示list调用add方法,且add方法参数为&quot;樊磊&quot; method.invoke(list,&quot;樊磊&quot;); System.out.println(list); } } 通过反射写一个通用的设置某个对象的某个属性为指定的值要求: public void setProperty(Object obj, String propertyName, Object value){},此方法可将obj对象中名为propertyName的属性值设置为value 使用案例及步骤: public class Example_1_ForName6 { public static void main(String[] args) throws Exception { User user = new User(); System.out.println(user); Example_1_ForName6 e = new Example_1_ForName6(); e.setProperty(user, &quot;name&quot;, &quot;fan&quot;); System.out.println(user); } public void setProperty(Object obj, String propertyName, Object value) throws Exception { //获取字节码文件对象 Class clazz = obj.getClass(); //获取对应的字段对象 Field field = clazz.getDeclaredField(propertyName); //擦除其权限 field.setAccessible(true); //修改值 field.set(obj, value); } } class User { private String name; @Override public String toString() { return &quot;User{&quot; + &quot;name=&apos;&quot; + name + &apos;\&apos;&apos; + &apos;}&apos;; } } 一个练习 /** * 要求: * 1. 给定一个类Student,要求自己新建一个property的配置文件写入类的完整名称 * (就是包名.类名,idea选中类然后复制引用就是的) * 2. 然后写一个程序,读取这个properties配置文件,获取类的完整名称并加载这个类,用反射的方式运行run方法 */ public class Example_1_ForName7 { public static void main(String[] args) throws Exception { //读取配置文件 BufferedReader br = new BufferedReader(new FileReader(&quot;src/Student.properties&quot;)); String s = br.readLine(); //获取类的字节码文件对象 Class clazz = Class.forName(s); //获取方法对象 Method run = clazz.getDeclaredMethod(&quot;run&quot;); //获取该类的构造方法对象 Constructor constructor = clazz.getConstructor(String.class); //通过构造方法创建对象 Student student = (Student) constructor.newInstance(&quot;pipi&quot;); //调用方法 run.invoke(student); } } class Student{ private String name; public Student(String name) { this.name = name; } public void run() { System.out.println(&quot;学生&quot; + name + &quot;在晨跑!&quot;); } } main方法还可以这么写,就是不需要生成method对象,直接调用 public static void main(String[] args) throws Exception { //读取配置文件 BufferedReader br = new BufferedReader(new FileReader(&quot;src/Student.properties&quot;)); String s = br.readLine(); //获取类的字节码文件对象 Class clazz = Class.forName(s); //获取该类的构造方法对象 Constructor constructor = clazz.getConstructor(String.class); //通过构造方法创建对象 Student student = (Student) constructor.newInstance(&quot;pipi&quot;); //调用方法 student.run(); }]]></content>
      <categories>
        <category>javase</category>
      </categories>
      <tags>
        <tag>反射案例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树题目_1]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F07%2F03%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E9%A2%98%E7%9B%AE-1%2F</url>
    <content type="text"><![CDATA[不懂可以给我留言,虽然我也很菜,也可以看我在二叉树基础最后面给的视频,都有 题目1题目如图: . 这个题目的规律(记住就行) 如果一个节点node,如果它有右子树(也就是右节点),那么node节点的后继结点一定是它右子树中最左的节点. 如果一个节点node,如果它没有右子树(也就是右节点),那么node节点的后继结点就要通过node节点找到它的父指针,如果该节点node是它父节点的右孩子,就继续往上找,直到某个节点是其父节点的左孩子,那么这个父节点就是node节点的后继结点. 举例 . 题目1_找后继结点代码 题目2其实也就是题目1的扩展,其余条件和题目1都一样,不过这里是找给定节点的先驱节点 思路(跟题目1的思路刚好相反): 思路1: 如果有左子树的话,找到左子树的最右边的节点. 思路2: 如果没有左子树的话,一直往父节点找,直到找到某个节点是其父节点的右节点,那么这个父节点就是要找的节点. 题目2代码 题目3二叉树的序列化(持久化)和反序列化 意思就是我们建立二叉树这些操作都是在内存里进行的,但是当我们一关机,这些记录就没了,我们怎么才能将它保存到文件中持久化存储呢?这就需要用到序列化和反序列化了,我写过一篇博客专门介绍序列化和反序列化: 序列化和反序列化 二叉树的序列化可以把它遍历后变成字符串然后保存到文件中,为空就用特殊符号表示就好了. 通过先序遍历 先序遍历按遍历节点顺序实现序列化 就是当我每次遍历到一个节点的时候,我就用节点值+”“保存到字符串中,不断遍历,然后做一个字符串的拼接,null就用”#“表示. 先序遍历实现反序列化 就是我们怎么序列化的就怎么反序列化,将字符串通过_分割可以形成一个数组,然后在遍历数组的过程中重建二叉树. 先序遍历序列化和反序列化代码 按层实现序列化和反序列化代码 题目4题目: 判断一棵树是否是平衡二叉树 啥叫平衡二叉树? 平衡二叉树是指对于该二叉树的的任意节点,它的左子树和右子树的高度差不超过1. 注意: 这里需要区分一下高度和深度,高度是从下往上数,深度是从上往下数,我在这里引用一下别人的博客:二叉树高度和深度的区别. 还有就是二叉树的层,是从1开始的,比如满二叉树有3个节点,那么就是两层. 思路: 如果把每个节点都作为根节点的树都是平衡的,那这棵树就是平衡的,我们先去判断根节点的左子树和右子树是否是平衡二叉树,有任意一个不是平衡二叉树,就直接返回false,如果左右子树都是平衡二叉树,返回true,不是就返回false. 对于这类二叉树问题有套路思路,就是在这里学会用递归函数来写代码,递归函数就是不断压栈弹栈的过程嘛,而且递归会回到每个节点三次(来到node,去node的左子树和右子树转一圈再回来node),那么我们可以收集其左右子树的信息,然后回到其父节点的时候加以判断,拿这道题来说,我们可以通过判断左右子树是否是平衡二叉树来判断整棵树是否是平衡二叉树. 平衡二叉树举例如图: 判断是否是平衡二叉树代码 我写的可能不清楚,不懂的话就去看我给的视频: 二叉树基础中给的左神的视频,很牛逼 题目5判断一棵树是否是搜索二叉树、判断一棵树是否是完全二叉树 搜索二叉树 什么是搜索二叉树? 二叉搜索树是指对于二叉树的任意一个节点作为头节点的子树来说,它的左子树的左右节点都比它小,右子树的所有节点都比它大. 怎么判断是否是搜索二叉树呢? 一般来说搜索二叉树是不会出现重复节点的(重复节点可以压缩到一个节点里),所以我们对该二叉树进行遍历,当它的中序遍历结果是升序的,那么这棵树就是搜索二叉树.我们这里用非递归方法写,递归版的写不出来 判断是否是搜索二叉树代码 题目6完全二叉树 什么是完全二叉树? 完全二叉树这个概念我在二叉树基础那里有写:二叉树基础,它是相对于满二叉树来说的,只有倒数两层不满,而且都是从左开始往右放. 如何判断一棵树是否是完全二叉树呢? 我们通过二叉树按层遍历 如果一个节点有右孩子没有左孩子,一定不是完全二叉树! 第一种情况通过了的话,再看如果一个节点不是有两个孩子(即有左没右或者左右都没有,有右没左的情况在情况1就判断了),那么它后面的节点一定都是叶子节点,否则一定不是完全二叉树. 第一种和第二种情况都通过了,那这棵树一定是完全二叉树. 我们可以通过一个布尔类型的变量来控制是否已经到了情况2,比如说没到情况2的时候,让布尔值为false,当通过了情况2之后,跑后面的节点的时候,让布尔值为true,告诉虚拟机后面的节点都必须是叶子节点了,都不能有孩子了! 完全二叉树代码. 完全二叉树举例 题目7已知一棵完全二叉树,求其节点的个数,要求时间复杂度低于O(N),N为这棵树的节点个数 一个满二叉树有n层(n从1开始,即根节点就是第一层),那么它的节点数为2^n - 1. 思路(这个思路时间复杂度为O(logN^2)): 整棵树先遍历到根节点最左边的叶子节点,就是跟中序遍历一样先左边跑完,因为完全二叉树肯定是先左边堆满才开始往右边堆,所以,左边的深度就是整棵树的深度h,此时时间复杂度为O(logN). 然后再跑根节点的右子节点的左边界,跑完看它有没有到最后一层,此时时间复杂度也为O(logN) 如果到了最后一层,那说明根节点的左子树是满的,左子树的深度自然也就出来了,那就是根节点的深度-1,其总共的节点是2^(h-1) - 1,此时因为右子树也同样是一个完全二叉树,让它去递归这个过程. 如果没有到最后一层,那说明右子树肯定比左子树少一层,而且是满的,那这样它的节点数就可以求了,为2^(h-1-1) - 1,此时我们再对左树递归这个过程. 例子如图: 完全二叉树节点代码_人家这思路绝了.]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二叉树题目_1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring-04-1]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F06%2F30%2Fspring-04-1%2F</url>
    <content type="text"><![CDATA[有问题可以留言我,虽然我也很菜 AspectJ基于xml使用见AspectJ基于xml使用案例AspectJ基于注解使用对比着上一面链接的博客的xml文件看使用步骤: 在xml文件中声明使用注解 通过注解配置service对象和切面的对象 在xml通过标签+切面类中通过注解一起配置aop 自己写一个方法作为声明公共切入点,相当于xml中的声明切入点 在切面类中通过注解配置切入点 AspectJ基于注解使用代码 一个搞了我好久错误(结合我给的代码的MyAspect类看我写的文字,也可以自己跑一下) 错误描述是这样子的: org.springframework.aop.AopInvocationException: Null return value from advice does not match primitive return type for: public int example3.service.User.addUser(int) 为什么会报这个错(注解和xml配置都会发生)? 我是准备用后置通知的返回值输出一下service中方法的返回值,然后因为我同时写了前置通知,后置通知以及环绕通知并且都执行了,此时,注意,当我同时写了这三个并且都起作用的时候,后置通知接收到的返回值是环绕通知返回的,两个返回值都是void,默认都是null,引用类型,他俩类型是兼容的不会报错,同时也要知道,环绕通知执行放行语句Object o = pjp.proceed();的时候,这个o就是service方法的返回值, 也就是说,后置通知想获取service方法的返回值的话,就要通过环绕通知返回service方法的返回值o给后置通知,而这个就是错误的源头了我的service方法的返回值是int,而刚开始环绕通知返回值是void,表示返回值是null,是引用类型,而int是基本类型,这个不兼容,所以报这个错. 解决办法: 直接去掉环绕通知只留下前置通知和后置通知,此时就算后置通知返回值是void也没关系,因为这个void是针对环绕通知的,不是service方法,所以是可以正确获得返回值的. 去掉前置通知和后置通知,只留下环绕通知,通过Object o = pjp.proceed();获取service的返回值,然后直接输出就成,此时环绕通知是void也没所谓,因为这个void是针对后置通知的,不是service方法,所以也是可以正确获得返回值的. 如果不动通知的话,那就将环绕通知返回类型改成和service返回类型一致,返回将o强转为该类型再返回给后置通知,就也是正确的了. 如果只是想让service方法有返回值,但是暂时不用的话,把返回值从基本类型比如int改成integer也可以. AspectJ基于注解和基于xml时通知顺序的区别最直接的就是直接写个例子跑一下哈哈哈哈,我觉得会不会电脑不同不一样啊你们可以试一下,例子就是上面两个例子. service方法有/无返回值+无异常+xml时通知的顺序 1. 前置通知 2. 环绕通知 3. 最终通知 4. 环绕通知 5. 后置通知(有异常时不会执行) service方法有/无返回值+无异常+注解时通知的顺序 1. 环绕通知-@Around 2. 前置通知-@Before 3. 环绕通知-@Around 4. 最终通知-@After 5. 后置通知(有异常时不会执行)-@AfterReturning]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>AspectJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring03-3]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F06%2F29%2Fspring-03-3%2F</url>
    <content type="text"><![CDATA[不懂的话可以留言我,虽然我也很菜 AspectJ通知类型AspectJ简介 AspectJ是一个基于java的aop框架. spring2.0以后新增了对AspectJ切点表达式(就是expression后面的那个)的指出. @AspectJ是AspectJ1.5新增功能,通过JDK5的注解技术,允许直接在Bean类中定义切面 新版本spring框架,建议使用AspectJ来开发AOP,方便哈哈哈. expression表达式 格式: execution(修饰符 返回值 包.类.方法名(参数) throws 异常) 修饰符,一般省略,比如: public表示公共,*表示任意. 返回值,不能省略,比如: void表示没有返回值,String表示返回任意字符串,*表示任意. 包,可省略,一般不省略,比如: com.fan.service表示service包下面的所有类,com.fan..表示fan这个包及其子包的所有类 类,可省略,一般不省略,比如: User表示只拦截User类,*Impl表示拦截以Impl结尾的所有类,User*表示拦截所有以User开头的类,*表示任意类. 方法名,不能省略,比如: addUser表示只拦截addUser()这个方法,add*表示拦截以add开头的所有方法,*add表示拦截以add结尾的方法,*表示任意 *throws,可省略,一般不写 对比AOP联盟通知类型 aop联盟定义通知advice类型,aop联盟的jar包里面都是接口,必须要有实现类(在spring-aop那个jar包里)(回想我们的切面类必须实现某个接口比如环绕通知接口,不然在测试的时候会报一系列错,不知道的话,看我spring-03-2这篇博客). 而AspectJ通知类型,只定义类型名称以及方法格式,一共有6种,在xml中有对应的标签配置. before: 前置通知,应用于各种校验,在方法执行前执行,如果通知出现异常,前置通知的语句会正常运行. afterReturning: 后置通知,应用于常规的数据处理,方法正常返回(即有返回值)后执行,如果方法中出现异常,通知无法执行,由于它必须在方法执行后执行,所有可以获得方法的返回值. around: 环绕通知,这个就很牛逼,可以做很多事情,方法执行前后分别执行,可以阻止方法的执行,而且,不论方法是否出现异常,他在方法前执行的语句比如开启事务一定会执行,它必须手动执行目标方法,具体见例子. afterThrowing: 抛出异常,应用于包装异常信息,方法抛出异常后执行,如果没有抛出异常则无法执行 after: 最终通知,应用于清理现场,方法执行完毕后执行,无论方法是否出现异常. AspectJ基于xml使用 第一步: 导包:(idea创建spring项目的话它自己就有) aopalience.jar--aop联盟规范 spring-aop.jar--aop实现 aspectj.weaver.jar--aspectj规范 spring-aspects.jar--aspectj的实现 第二步: 目标类: public class User { public void addUser() { System.out.println(&quot;没有参数添加用户!&quot;); } public void addUser(int i) { System.out.println(&quot;一个参数添加用户!&quot;); } public void addUser(int i,int j) { System.out.println(&quot;两个参数添加用户!&quot;); } } 第三步: 切面类 import org.aspectj.lang.ProceedingJoinPoint; public class MyAspect { /** * 前置通知 */ public void myBefore() { System.out.println(&quot;前置通知!&quot;); } /** * 后置通知获取业务方法(这里就是service方法)执行后的返回值 * @param jp */ public void afterReturning(JoinPoint jp, Object retVal) { System.out.println(&quot;后置通知!,其返回值为&quot; + retVal); } /** * * @param pjp 手动执行的目标对象的连接点,也就是切入点,起名字就是切入的方法名 */ public Object myAround(ProceedingJoinPoint pjp) throws Throwable { System.out.println(&quot;环绕通知!&quot; + pjp);//pjp其实就是expression表达式中execution那一串 System.out.println(&quot;开启事务&quot;); //放行 Object obj = pjp.proceed(); System.out.println(&quot;提交事务&quot;); return obj; } /** *jp 调用方法的时候,都会传过来一个连接点 * 也是expression后面的式子,名称就是切入的方法名 * 可写可不写 * @param jp 对比环绕通知的pjp,他们的区别就是,jp没有放行功能 * @param e */ public void afterThrowing(JoinPoint jp, Throwable e) { System.out.println(&quot;抛出异常通知&quot; + e.getMessage()); } /** * 最终通知 * @param jp 这个所有通知方法都可以写也可以不写 */ public void after(JoinPoint jp) { System.out.println(&quot;最终通知&quot; + jp.getSignature().getName()); } } 第四步: 配置文件 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;!--配置目标类对象--&gt; &lt;bean id=&quot;user&quot; class=&quot;example2.service.User&quot;&gt;&lt;/bean&gt; &lt;!--配置切面类对象--&gt; &lt;bean id=&quot;myAspect&quot; class=&quot;example2.MyAspect&quot;&gt;&lt;/bean&gt; &lt;!--aop配置--&gt; &lt;aop:config&gt; &lt;!--配置切面--&gt; &lt;aop:aspect ref=&quot;myAspect&quot;&gt; &lt;!--配置切入点,只切入service包下面User类中以add开头的方法,参数为任意--&gt; &lt;aop:pointcut id=&quot;myPointCut&quot; expression=&quot;execution(* example2.service.User.add*(..))&quot;&gt;&lt;/aop:pointcut&gt; &lt;!--配置前置通知--&gt; &lt;!--&lt;aop:before method=&quot;myBefore&quot; pointcut-ref=&quot;myPointCut&quot;&gt;&lt;/aop:before&gt;--&gt; &lt;!--配置后置通知 retVal表示接收业务方法的返回值,然后作为参数带给后置通知方法--&gt; &lt;aop:after-returning method=&quot;afterReturning&quot; pointcut-ref=&quot;myPointCut&quot; returning=&quot;retVal&quot;&gt;&lt;/aop:after-returning&gt; &lt;!--配置环绕通知,注意这里必须手动执行目标对象--&gt; &lt;aop:around method=&quot;myAround&quot; pointcut-ref=&quot;myPointCut&quot;&gt;&lt;/aop:around&gt; &lt;!--配置异常通知, 这里面的e就是切面类中异常通知方法的参数,代码出错时e会带着错误信息传给异常通知方法--&gt; &lt;aop:after-throwing method=&quot;afterThrowing&quot; pointcut-ref=&quot;myPointCut&quot; throwing=&quot;e&quot;&gt;&lt;/aop:after-throwing&gt; &lt;!--配置最终通知--&gt; &lt;aop:after method=&quot;after&quot; pointcut-ref=&quot;myPointCut&quot;&gt;&lt;/aop:after&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; &lt;/beans&gt; 第五步: 测试类 import example2.service.User; import org.junit.Test; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; public class UnitClass { @Test public void test() { ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans2.xml&quot;); User user = (User) context.getBean(&quot;user&quot;); user.addUser(); System.out.println(&quot;--------&quot;); user.addUser(1); System.out.println(&quot;--------&quot;); user.addUser(1,2); } }]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>AspectJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring-03-2]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F06%2F28%2Fspring-03-2%2F</url>
    <content type="text"><![CDATA[有问题可以问我,spring前面的几篇文章不清不楚,我整体过一遍再重新写 AOP联盟通知类型advice 回忆一下什么是advice? 要是不记得的话可以看看我spring-03-1里面例子的那个图片,说白了,advice里面就是指向的增强功能的代码内容 AOP联盟为通知Advice定义了org.aopalliance.aop.Advice这个类,且Spring按照通知Advice在目标类方法的连接点位置,可以分为5类: 前置通知 org.springframework.aop.MethodBeforeAdvice 在目标方法执行前实施增强 后置通知 org.springframework.aop.AfterReturningAdvice 在目标方法执行后实施增强 环绕通知 org.springframework.aop.MethodIntercepter 在目标方法执行前后实施增强 异常抛出通知 org.springframework.aop.ThrowsAdvice 在方法抛出异常后实施增强 引介通知 org.springframework.aop.IntroductionInterceptor 在目标类中添加一些新的方法和属性 spring AOP采用半自动代理什么是代理半自动呢? 代理半自动是指,我们不用手动去创建代理对象,我们直接在xml中配置代理对象,然后从容器中获取就好了 配置代理的注意事项: 必须有两个属性,一个切面类对象,一个目标类对象,接口有就写没有就不写. 半自动代理默认使用的是jdk的动态代理方式,有接口一定是jdk的动态代理,没有接口就使用cglib的代理方式. 可以通过在配置文件中强制使用cglib增强代理,在spring配置的bean中添加这样一行: ,这样,就会只使用cglib增强代理了 当你想使用jdk的动态代理的时候,那就写上接口,并且不要强制使用cglib增强代理,在源码中,接口和切面类(准确的说是增强代码所在的类的对象)那个属性的定义其实是一个list集合,但是只有一个的时候我们可以直接写的value,多个接口的时候就要写成集合了案例: 第一步: 导入jar包(idea创建spring项目都会自动导入不用管): 四个核心包(beans,context,core,expression) 一个日志包(logging) AOP联盟包(定义了规范,里面都是接口,com.springsource.org.aopalliance.jar) spring-aop包(aop联盟的实现,spring-aop-3.2.0.RELEASE.jar) 第二步: 创建目标类 public class UserService { public void addUser() { System.out.println(&quot;添加了一个用户!&quot;); } } 第三步: 创建切面类 public class MyAspect implements MethodInterceptor { @Override public Object invoke(MethodInvocation methodInvocation) throws Throwable { //拦截方法 System.out.println(&quot;开启事务&quot;); //放行 Object obj = methodInvocation.proceed(); System.out.println(&quot;结束事务&quot;); System.out.println(&quot;已成功拦截,切入点前开启事务,切入点后提交事务&quot;); return obj; } } 第四步: spring配置 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!--配置userservice--&gt; &lt;bean id=&quot;userService&quot; class=&quot;UserService&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;樊磊&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--配置一个切面类对象--&gt; &lt;bean id=&quot;myAspect&quot; class=&quot;MyAspect&quot;&gt; &lt;/bean&gt; &lt;!--配置代理,有接口就采用jdk动态代理,没有就采用cglib代理,默认使用jdk动态代理--&gt; &lt;bean id=&quot;serviceProxy&quot; class=&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;&gt; &lt;!--接口--&gt; &lt;!--&lt;property name=&quot;interfaces&quot; value=&quot;接口全路径&quot;&gt;&lt;/property&gt;--&gt; &lt;!--目标对象--&gt; &lt;property name=&quot;target&quot; ref=&quot;userService&quot;&gt;&lt;/property&gt; &lt;!--切面类对象 注意这里是value,不是ref,和目标对象区分一下子--&gt; &lt;property name=&quot;interceptorNames&quot; value=&quot;myAspect&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/beans&gt; 第五步: 测试类 public class Test { public static void main(String[] args) { //获取spring容器中的代理对象 ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); UserService userService = (UserService) context.getBean(&quot;serviceProxy&quot;); //调用方法 //此处的userService为代理对象 userService.addUser(); } } spring AOP采用全自动代理这个就是说,我们本来是需要通过代理实现目标类获取功能增强,但是现在直接让增强的功能和目标类相连接,直接跳过代理这个东西,但是切面类这些的还是要自己整哈. 什么是全自动织入 结合我spring-03-1那篇博客里的图,织入(weaving)就是将advice通过代理类添加到目标类中的过程. 全自动织入,emm,可以理解为我们相对于半自动代理来说不需要配置代理类,直接让切面里的通知送到切入点进行结合. 结合案例说明xml配置中expression表达式的写法 &lt;aop:config proxy-target-class=”true”&gt;这表示使用的是cglib代理,值为false或者不写表示使用的是jdk的代理(基于接口的时候使用). execution中参数的意义:以execution(* example1.service.*.*(..))为例. 括号里第一个*,表示任意返回值,即不管方法的返回值是int还是String或者其它类型都会被过滤,也可以指定为int或者其他类型. 括号中的example1.service表示包名,表示切入点在这个包下,同时注意这里的包名是src下面的报名,即如果是src.package1.package2.targetClass的话,就写成package1.package2. 括号里的第二个*,也就是example1.service.*的这个*号表示该包下面的所有类都会被过滤,被当作切入点,也可以指定类名,例如: example1.service.fan,这就表示只有该包下的fan的这个类会被过滤和增强. example1.service..fan,就只是多了一个.,这表示service这个包及其子包下的fan这个类都会被过滤 括号里的第三个*,也就是example1.service.*.*中的第二个*,它表示类下面的所有方法都会被过滤,被当作切入点,也可以指定某个方法或者以某个单词开头的方法作为切入点,例如: example1.service.fan.test表示只有fan这个类下面的test()方法会被过滤. example1.service.fan.user*表示fan这个类下面所有以user开头的方法都会被过滤 example1.service..fan.user*表示service及其子包下面的fan这个类下面的user开头的方法都会被过滤 example1.service..fan.*user表示service及其子包下面的fan这个类下面的user结尾的方法都会被过滤 括号中的(..),表示方法的参数为任意个数,任意类型参数都会被过滤,也可以自己指定,例如: ()什么都不写表示只过滤空参的方法. (*)表示只过滤一个参数的方法,参数可以为任意类型 (*,*)表示只过滤两个参数的方法,多个参数用,隔开即可 (*,int)表示只过滤两个参数且第二个参数为int类型的方法,多个参数用,隔开即可 案例: 第一步: 导入jar包: aspectjweaverjar.版本尽量高一点吧 第二步: 切面类: 注意此时一定要继承接口而且我们这里继承的是aop联盟的接口不是cglib的接口 import org.aopalliance.intercept.MethodInterceptor; import org.aopalliance.intercept.MethodInvocation; public class MyAspect implements MethodInterceptor { @Override public Object invoke(MethodInvocation methodInvocation) throws Throwable { System.out.println(&quot;开启事务&quot;); //放行 Object obj = methodInvocation.proceed(); System.out.println(&quot;结束事务&quot;); return obj; } } 第三步: 目标类 public class UserService { public void addUser() { System.out.println(&quot;添加了一个用户!&quot;); } } 第四步: beans.xml配置: &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;!--配置目标类对象--&gt; &lt;bean id=&quot;user&quot; class=&quot;example1.service.User&quot;&gt;&lt;/bean&gt; &lt;!--配置切面类对象--&gt; &lt;bean id=&quot;myAspect&quot; class=&quot;example1.MyAspect&quot;&gt;&lt;/bean&gt; &lt;!--配置aop 1. 在bean中配置aop约束 2. 配置aop:config,把切入点和通知相结合--&gt; &lt;aop:config proxy-target-class=&quot;true&quot;&gt; &lt;!--切入点 expression-表达式 要求每个service的方法前后分别开启事务和关闭事务--&gt; &lt;aop:pointcut id=&quot;myPointCut&quot; expression=&quot;execution(* example1.service.*.*(..))&quot;&gt;&lt;/aop:pointcut&gt; &lt;!--通知 要关联切入点--&gt; &lt;aop:advisor advice-ref=&quot;myAspect&quot; pointcut-ref=&quot;myPointCut&quot;&gt;&lt;/aop:advisor&gt; &lt;/aop:config&gt; &lt;/beans&gt; 第五步: 测试类: public class UnitClass { @Test public void test() { ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); User user = (User) context.getBean(&quot;user&quot;); user.addUser(); } }]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring-03-2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring-03]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F06%2F26%2Fspring-03-1%2F</url>
    <content type="text"><![CDATA[AOP巨重要,不过我也是第一次看,一脸懵逼,得摸索一会儿,有问题可以留言我,虽然我也很菜 AOP基本概念AOP概述 AOP–Aspect Oriented Programming,即面向切面编程,通过预编译方式和运行期动态代理实现程序功能的统一维护. AOP是OOP(面向对象编程)的一个延续,是spring的一个重要内容,是函数式编程的一种衍生泛型. 利用AOP可以对业务逻辑的各个部分进行隔离,从而使得业务逻辑各部分的耦合度降低,提高程序的可重用性,同时提高了开发的效率 AOP采用横向抽取机制,取代了传统纵向继承体系(比如我们继承父类抽象类等)解决重复性代码问题. 传统我们通过继承来实现代码重用的时候,因为要继承父类/抽象类,所以导致耦合度很高,开发效率蛮低. 而AOP采用横向抽取机制解决重复性代码问题时候,它不需要继承,它写一个切面类,将重复性代码放在里面,然后通过像过滤器这样子的方法拦截所有的需要用到这段代码的类及方法,在相关方法前面或者后面执行这段重复代码进行相关处理,就相当于添加了一个额外的功能,这样子耦合性就会比继承体系低很多. 经典应用场景: 事务管理,缓存,日志等. Spring AOP使用java实现,不需要专门的编译过程和类加载器,在运行期通过代理方式向目标类织入增强代码. AspectJ是一个基于java语言的AOP框架,有jar包. AOP实现原理 aop底层采用代理机制实现,有以下两种方式: 采用jdk的动态代理Proxy,通过接口 + 实现类做到. 采用cglib字节码增强,只需要通过实现类就能做到,不管有没有接口都可用这个来实现代理. AOP术语 用这样一个图片做例子 target: 目标类,即需要被代理的类, 例如图片中的业务类UserService. Joinpoint(连接点): 指的是那些可能被拦截到的方法, 例如图片中所有的方法. PointCut(切入点): 已经被增强(添加了额外功能)的连接点, 例如图片中的addUser()方法. advice 理解为通知/增强, 里面写着增强代码的方法,主要用于增强代码.例如: 图片中的after,before方法. Weaving(织入): 是指把增强advice应用到目标对象target来创建新的代理对象proxy的过程,简单理解就是把增强的功能通过代理实现到目标对象中. proxy: 代理类 Aspect(切面): 是切入点pointCut和通知advice的结合. 其中,一条线是一个特殊的面. 一个切入点和一个通知,组成一个特殊的面. JDK动态代理实现AOP 没听懂,没整明白,我还得去找点其他视频再看两遍,视频放这里: 链接：https://pan.baidu.com/s/13i7F9FPo-L3WPChjy0tj0w 提取码：k3rj cglib增强字节码实现AOP 不需要用到接口,只需要实现类 采用字节码增强框架cglib,在运行时,创建目标类的子类,从而对目标类进行增强. 其jar包在spring-core中已经整合了. 没整明白,视频放这里: 链接：https://pan.baidu.com/s/1lP8QjIK5b_dzSPkyEhuBeA 提取码：t6i6]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树基础]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F06%2F26%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[不懂可以给我留言,虽然我也很菜 二叉树的基本概念什么是二叉树 二叉树简单来讲就是一棵树嘛,树大家都知道的吧,有树枝,二叉树只不过是一种每个节点都只有两个树枝的树,其实就是链表,只不过这个链表只有三个部分–一个数值部分和两个节点(左子结点和右子节点),如果你前面链表还可以的话,你就可以把二叉树理解为有两个指针的链表,这就是一个公理类型的东东,记住就行,多用就懂了,跟链表差不多的. 如图:什么是满二叉树 满二叉树: 就是很满嘛,满就完事儿了,就说明它的所有节点,除了最后一层节点没有任何子节点以外,上面的所有层每个节点都是两个子节点 一个科普的点:那种没有任何子节点的节点叫做叶子节点. 如图: 什么是完全二叉树 完全二叉树就是除了最后一层和倒数第二层,其余层都是满的,而且最后两层的节点都是先左节点再右节点,即左子节点排了才会排右子节点,完全二叉树是相对于满二叉树而言的,它相对于满二叉树,在后两层,从没有子节点开始,之前的和满二叉树一样的就是对的. 看图吧还是,我语文不好 我找了一个博客,还蛮详细,可以看一眼,我写的马大三粗的: 二叉树基础详解 二叉树的遍历二叉树的先序遍历 什么是二叉树的先序遍历? 先序遍历的遍历顺序: 先父节点–&gt;再左子节点–&gt;最后右子节点,总体顺序: 先根节点–&gt;再左子树–&gt;最后右子树 二叉树的中序遍历 什么是二叉树的中序遍历? 中序遍历的遍历顺序: 先左子节点–&gt;再父节点–&gt;最后右子节点,总体顺序: 先左子树–&gt;再根节点–&gt;最后右子树 二叉树的后序遍历 什么是二叉树的后序遍历? 后序遍历的遍历顺序: 先左子节点–&gt;再右子节点–&gt;最后父节点,总体顺序: 先左子树–&gt;再右子树–&gt;最后根节点 二叉树遍历案例如图(把每个三角形都当作一个父节点和左右节点来看就成): . 二叉树的遍历代码 那个那个,父节点就是头结点,一样的东西,说法不同而已,不过头节点好像听起来叼一点,那我后面就用头节点代替吧哈哈 二叉树的遍历递归版 递归的话,就是不断压栈弹栈的过程,要特别注意每次压栈然后满足if条件后又弹栈返回上一层的思想,其实二叉树的遍历递归很好搞,反正就那么几行代码,记下来也行,反正你就父节点第几个输出,就跟输出语句和左右节点递归的代码调整好位置就行,你看代码就懂了. 二叉树的遍历非递归版 我给你们二叉树这一节的视频吧,好好理解下,这个东西不好表达: 链接: https://pan.baidu.com/s/1BkvysdWpNeBFH5GpbBk-Jg 提取码: 66a0 如何直观地打印一颗二叉树,我直接扒过来的 直观地打印二叉树]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二叉树基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[反射概念]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F06%2F25%2F%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[类的加载概述和加载时机类的加载概述 类的加载是指: 当程序要使用某个类时,如果该类还未被加载到内存中,则系统会通过加载,连接,初始化三步来实现对这个类的初始化. 加载: 指的是将Javac创建的class文件读入内存,并为之创建一个Class对象,任何类被使用时系统都会建立一个Class对象 连接: 包括三个步骤: 验证 是否有正确的内部结构,并和其它类协调一致. 准备 负责为类的静态成员分配内存,并设置默认初始化值. 解析 将类的二进制数据中的符号引用替换为直接引用,比如把常量的引用直接变成值. 初始化: 就是给成员变量赋值: 先默认值(比如int默认值为0)—-&gt;然后显式赋值(比如public inta = 10,这个=就是显式初始化)—-&gt;最后构造方法初始化(带参构造会给成员变量赋值这个都知道哈). 类的加载时机 创建类的实例时,例: Preson p = new Person(). 访问类的静态变量,或者为静态变量赋值时 调用类的静态方法 使用反射方式来强制创建某个类或接口对应的java.lang.Class对象. 初始化某个类的子类 直接使用java.exe命令来运行某个主类 类加载器的概述和分类类加载器的概述 负责将.class文件加载到内存中,并为之生成对应的Class对象. 类加载器的分类 Bootstrap ClassLoader: 根类加载器 Extension ClassLoader: 扩展类加载器 System ClassLoader: 系统类加载器 类加载器的作用 根类加载器负责java核心类的加载,比如System,String等,在jre的lib目录下的rt.jar文件中. 扩展类加载器负责jre扩展目录中jar包的加载,在jre的lib目录下的ext目录下. 系统类加载器负责jvm启动时加载来自java命令的class文件比如自定义类,以及classpath环境变量所指定的jar包和类路径 类初始化顺序 只有一个类的话,他的初始化顺序是这样子的 静态成员变量 静态代码块,例如: static{System.out.println(“静态代码块”)} 普通成员变量 普通代码块(就是静态代码块没有static关键字,直接就是{内容}) main方法 构造方法 反射反射概述 java反射机制是指在运行状态中,对于任意一个类,都能够知道这个类的任意属性和方法,对于任意一个对象,都能够调用它的属性和方法 这种动态获取信息以及动态调用对象的方法和属性的功能称为java的反射机制 要想解剖一个类,必须先要获取到该类的字节码文件(字节码文件就是.class文件)对象,而解剖类使用的就是Class类中的方法,所以先要获取到每一个字节码文件对应的Class类型的对象 获取Class文件对象的三种方式 Object类的getClass()方法,用于判断两个对象是否是同一个字节码文件,重写equals()方法时就有这么一个判断条件,调用格式: 对象名.getClass(). 静态属性.class,即Person.class,用于当作静态方法的锁对象,调用格式: 类名.class 注意: 用.class创建Class对象时,不会自动初始化该Class对象(即不会加载静态代码块这些东西),Class的初始化在调用方法或者属性时候才会被执行 Class类中静态方法forName(“全类名即包名.类名”),用于读取配置文件,例如我们读取jdbc的配置文件的时候,调用格式: 全类名.forName() 注意: 用这种方法创建成功Class对象后,就会立即对该对象进行初始化,即会马上执行静态代码块这些东西. 注意: 如果一个字段被static final修饰,,我们称为’编译时常量’,在编译期就把它的值放到常量池里了,那么如果通过.class创建Class对象的话,由于没有立即对Class对象进行初始化,然后该对象去调用常量也是不会对Class对象进行初始化的,也就是说不会调用static静态代码块这些东西. 三种创建Class对象的方式,如果是针对同一个字节码文件的话,三个对象是相等的,因为一个字节码文件在内存中只会存在一个Class对象 我们写代码经历的不同的阶段以及在不同的阶段获取Class对象的方法如图: . 案例演示获取Class对象的三种方式以及初始化顺序 public class Test4 { public static final int a =10; static int b = 20; public static void main(String[] args) { System.out.println(&quot;main函数加载了&quot;); Test4 t = new Test4(); } public static void get() { System.out.println(&quot;这是静态方法&quot;); } static { System.out.println(&quot;静态代码块被加载了&quot;); } public Test4() { System.out.println(&quot;构造方法被加载了&quot;); } public int c = 30; { System.out.println(&quot;代码块加载了!&quot;); } } class Test{ public static void main(String[] args) throws ClassNotFoundException { Class c = Test4.class; Test4 t = new Test4(); Class c1 = t.getClass(); Class c2 = Class.forName(&quot;Test4&quot;); System.out.println(&quot;--------- &quot;); System.out.println(c == c2);//true System.out.println(c1 == c);//true System.out.println(c1 == c2);//true } }]]></content>
      <categories>
        <category>javase</category>
      </categories>
      <tags>
        <tag>反射概念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring-02_3]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F06%2F25%2Fspring-02-3%2F</url>
    <content type="text"><![CDATA[有问题可以留言我,虽然我也很菜 注解注入注解: 就是一个类,使用格式: @注解名称,开发中常常使用注解替代xml文件. 注意: Spring默认情况下,注解是不生效的,我们需要手动开启注解功能. 使用注解给对象赋值不需要set方法,但是xml配置对象属性的话,对应属性必须要有set方法. 如何开启spring的注解功能呢? 在xml中配置修改内容如下图: xml启动注解图示 开启了注解之后,我们使用注解,是在要声明的对象所在的类,比如我要创建user对象,我就应该在User类里声明注解,不是在测试类中. Component注解的使用 @Component用于取代&lt;bean class=&#39;&#39;&gt;. @Component(id)用于取代&lt;bean id=&#39;&#39; class=&#39;&#39;&gt;. 案例: 1. beans.xml配置 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!--suppress ALL --&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!--开启注解--&gt; &lt;context:annotation-config&gt; &lt;/context:annotation-config&gt; &lt;!--设置注解的位置,设置之后该包下面的所有注解spring都会扫描--&gt; &lt;context:component-scan base-package=&quot;service&quot;&gt; &lt;/context:component-scan&gt; &lt;/beans&gt; 2. User接口实现类UserImpl @Component(&quot;user&quot;) public class UserImpl implements User { private String name; public UserImpl(){ System.out.println(&quot;初始化userimpl&quot;); } public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public void add() { System.out.println(&quot;UserImpl实现自User接口&quot;); } @Override public void add(User user) { System.out.println(&quot;添加用户!&quot; + user); } } 3. 测试类: /** * 注解案例1: `@Component`用于取代`&lt;bean class=&apos;&apos;&gt;`. * 在UserImpl类中写了`@Component`注解后 * 相当于配置了&lt;bean class=&quot;service.impls.UserImpl&quot;&gt;&lt;/bean&gt; * * @Test 这个注解是用于单元测试的,就是不用main函数也可以运行 * 对于这个注解有几个注意的点: * 1.这个注解所在的方法必须是public * 2.这个注解所在的方法不能是static */ public class Test10 { @Test public void test() { ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans10.xml&quot;); /** * 如果`@Component`没有配置id * 那我们可以通过class类型获取bean对象,方法不变,参数类型变了而已 * 其中参数可以为接口类型,也可以为接口的实现类类型 * 如果参数声明的是接口类型,会自动转变为子实现类类型 */ User user = context.getBean(User.class); System.out.println(user.getClass());//class service.impls.UserImpl user.add(); //如果`@Component`配置了id,就跟以前一样就好了 //UserImpl user = (UserImpl) context.getBean(&quot;user&quot;); } } web开发中,spring提供了3个@Component注解的衍生注解(功能一样的)来取代&lt;bean class=&#39;&#39;&gt;,分别是: @Repository(“名称”): dao层(数据访问层) @Service(“名称”): service层(业务逻辑层) @Controller(“名称”): web层(界面层) 这里有一个问题:为什么不都用@Component注解来实现三层架构呢? 其实是因为这样子,因为三层架构中,我们在web需要创建service层的对象,在service层需要创建dao层的对象 如果都用component注解,可能会出现如果web层对象最先创建,然后web层是最先调用方法的,这时候service对象不存在,就会报错,我们用那三个衍生注解后,它会自动先创建dao的对象,然后service的对象,最后再web层对象,这样就不会出现这种问题,不懂可以看我下面我自己写的例子,也可以看看我给的视频再看我写的例子 还有一些常用注解: Autowired: 自动根据类型(也就是类名/接口名.class生成的Class对象,接口名.class生成的是其实现类的对象)注入 Qualifier(“名称”): 根据指定的名称自动找到对应的bean对象然后注入给属性(一般不用,用上面的那一个让系统自动注入挺好) Resource(name=”名称”): 等于上面两个的作用合起来,用的也不多. PostConstruct: 自定义初始化,相当于xml文件中配置&lt;bean init-method=&quot;&quot;&gt; PreDestroy: 自定义销毁,相当于xml文件中配置&lt;bean destroy-method=&quot;&quot;&gt; Scope(“prototype/singleton”): 设置该对类是单例还是多例模式,这个注解直接写在其它注解的下一行就可以了,不冲突. 例1–不使用注解模拟三层架构web-&gt;service-&gt;dao,东西有点多,我就直接放代码吧: 不使用注解模拟三层架构代码. 例2–使用注解模拟三层架构web-&gt;service-&gt;dao,直接放代码: 使用注解模拟三层架构代码. 模拟三层架构视频讲解:链接: https://pan.baidu.com/s/1alOFci0QZGCoxfcneKLd9Q 提取码: iwd4.]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring-02_3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表部分经典题目]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F06%2F25%2F%E9%93%BE%E8%A1%A8%E9%83%A8%E5%88%86%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[不懂的话就给我留言吧,虽然我也菜 题目一: 如何判断一个单链表是否有环?有环的话返回进入环的第一个节点,无环的话返回空 要求: 如果链表长度为N,请做到时间复杂度为O(N),额外空间复杂度为O(1),注意这个题目的隐含条件是没有重复元素 思路1: 如果没有额外空间复杂度的限制的话,我们可以用哈希表或者hashset实现,即我们去遍历整个链表,将节点不断添加到哈希表/hashset中,当其put()/add()方法返回false时,该元素就是环形的入口,此时停止遍历,返回结果即可. 思路1代码,额外空间复杂度为O(N) 思路2: 我们给定一个快指针和慢指针,快指针一次走两步,慢指针一次走一步, 如果没有环,快指针会很快到达节点末尾的空节点位置,直接返回空. 如果有环,那么快指针和慢指针一定会在环中的某个地方相遇,然后让快指针从头结点重新开始走,不过这时候快指针一次也只走一步,他们再次相遇的点一定是环的入口,这是一个结论,记住就行,反正我也不会证明哈哈 思路2代码 题目二: 如何判断两个无环单链表是否相交?相交返回第一个相交的节点,不相交返回空 要求: 如果两个链表长度分别为M,N,那么请做到时间复杂度为O(M+N),额外空间复杂度为O(1). 注意: 两个单链表相交之后肯定是走一条线,不可能形成X形状的相交的哈,因为单链表只有一个next指针,不可能同时指向两个节点. 思路一: 如果没有额外空间复杂度的限制的话,我们还是可以通过哈希表或者hashset来做,先遍历其中一条单链表 思路1代码,额外空间复杂度大于O(1) 思路二: 先遍历两个链表获得他们的长度,然后让长的先走比短的多出来的部分,当剩余长度相同时,再一起走,碰到的第一个相等的节点就是交点,如果任意一个走到末尾了还没有相等的节点,那就说明不相交,返回空即可 例: 链表1长度为6,具体为:1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;null, 链表2长度为4,具体为: 2-&gt;4-&gt;5-&gt;6-&gt;null,其中4号节点为他们的交点,我们让链表1先走6-4=2步,然后一起走,他们在4号节点一定相交. 思路2代码 题目三: 如何判断两个有环单链表是否相交?相交返回第一个相交的节点,不相交返回空 要求: 如果两个链表长度分别为M,N,那么请做到时间复杂度为O(M+N),额外空间复杂度为O(1) 注意(这个题有点麻烦): 如果两个有环链表相交的话,那么相交之后肯定走的是一个环,切记切记单链表是不可能形成X形的,它只有一个next指针,请收起你们天花乱坠的想象哈哈哈 这里有个隐含条件,就是两个有环链表来说,每个环中元素都是不重复的 思路: 我们可以先找到两个有环链表的入环节点,就是上面的题目一,然后根据入环节点判断他们是否相交,有三种情况: 第一种情况, 两个链表在同一个节点入环(就是两个节点是同一个对象,不仅仅是值相等哈),这时候我们需要找到的是入环前的相交节点,如果入环前没有相交,就返回入环的节点(做法和找到两个无环单链表相交节点类似了,不过这里的结束条件是到达入环节点而不是某一个链表为空). 第一种情况如图 第二种情况, 两个入环节点不在同一个,而且各自成环,没有相交,直接返回null,怎么判断呢?从其中一个单链表的入环开始,遍历环直到回到了入环节点,看之间能否找到另一个节点的入环节点,有就返回任意一个入环节点,没有就说明没有相交,返回null. 第二种情况如图 第三种情况, 两个单链表相交,但是入环节点不是同一个,返回随便哪一个都行,如何判断相交了呢,和第二种情况判断一样,从其中一个单链表的入环开始,遍历环直到回到了入环节点,看之间能否找到另一个节点的入环节点,有就返回任意一个入环节点. 第三种情况如图 有环链表相交代码 题目四: 给定两个单链表的头结点head1,head2,如何判断两个单链表是否相交?相交返回第一个相交的节点,不相交返回空 这个题就是上面几个题的综合,我懒得写了哈哈哈,上面几个写了这个肯定就会了,思路图片我放这里吧 思路图:]]></content>
      <categories>
        <category>链表</category>
      </categories>
      <tags>
        <tag>链表部分经典题目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[序列化和反序列化]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F06%2F24%2F%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%2F</url>
    <content type="text"><![CDATA[序列化流 序列化 java.io.ObjectOutputStream类,将java对象的原始数据类型写入到文件,实现对对象的持久存储,通俗来说,就是把对象以流的方式写入到文件中叫序列化. 构造方法: public ObjectOutputStream(OutputStream out), 其中,参数为字节输出流. 序列化流特有的成员方法: void writeObject(Object obj): 将指定的对象写入到流中 使用步骤: 创建一个ObjectOutputStream对象,在构造方法中传递字节输出流. 创建要写入到文件的对象,但是,注意这个对象所在的类一定要实现Serializable序列化接口,不然会报错没有序列化异常. 用ObjectOutputStream对象中的writeObject方法把对象写入到文件中. 释放资源 案例(将person对象存放到项目目录下的指定文件中): public class ObjectOutputStreamDemo1{ public static void main(String[] args) throws IOException { //这里构造函数中的true是为了多次运行能把对象数据依次添加到上一条数据的后面而不是覆盖之前的数据 ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(&quot;person序列化文件.txt&quot;, true)); Person person = new Person(&quot;fanlei&quot;, 18); outputStream.writeObject(person); outputStream.close(); } } //程序运行后,person就会写入到文件&quot;person序列化文件.txt&quot;中,不过我们打开是乱码,因为我们是二进制字节存储的,我们看不懂的,所以要想知道是啥,就得反序列化回去 注意: Serializable接口也叫标记性接口,它没有任何实现,只是一个空接口,但是要进行序列化或反序列化的类必须实现该接口,实现这个接口后它就会给类添加一个标记,当我们进行序列化和反序列化的时候,系统会检测这个即将被保存到文件中的对象所在的类是否有这个接口标记,有就正常序列化和反序列化,没有就报错–没有序列化异常. 你可以理解为去菜场买肉,肉上一般都有一个蓝色的章,写在检测合格,盖了章就说明能吃,没盖章的我反正不敢吃哈哈 反序列化流 反序列化 java.io.ObjectInputStream类,将之前使用ObjectOutputStream类序列化的原始数据恢复为对象,通俗来说,就是把原来存放到文件的对象数据以流的方式读取出来,并转换为对象. 构造方法: public ObjectInputStream(InputStream in), 其中,参数为字节输入流. 反序列化流特有的成员方法: Object readObject(): 从ObjectInputStream中读取对象 使用步骤: 创建一个ObjectInputStream对象,在构造方法中传递字节输入流. 使用ObjectInputStream对象中的readObject方法读取保存对象的文件. 释放资源. 使用读取出来的对象. 案例(还是要注意person类要实现serializable接口): public class ObjectInputStreamDemo1 { public static void main(String[] args) throws IOException, ClassNotFoundException { FileInputStream fileInputStream = new FileInputStream(&quot;person序列化文件.txt&quot;); ObjectInputStream inputStream = new ObjectInputStream(fileInputStream); Person person = (Person) inputStream.readObject(); inputStream.close(); System.out.println(person); } } 注意: readObject()这个方法声明了两个异常:IOException(io异常)和ClassNotFoundException(class文件找不到异常),当不存在对象的class文件时,比如person对象对应的Person类不存在,就会抛出ClassNotFoundException. 所以反序列化的前提有两个: 类必须要实现Serializable序列化标记接口 必须存在对象对应的class文件 transient(瞬态)关键字 static关键字–静态关键字: 静态随着类加载,被类的成员共享,优先于非静态加载到内存中(静态优先于对象进入到内存中) 注意: 被static修饰的成员变量不能被序列化,因为序列化的都是对象,静态成员不属于对象. 但是这个是不会报错的,如果你序列化的时候有静态成员变量,那么你反序列化之后,你会发现那个被静态修饰的成员变量为默认值,比如int类型就为0,不是你设置的值. transient关键字: 又叫瞬态关键字, 它就是拿来让成员变量不被序列化的,即被它修饰的成员变量不能被序列化,效果跟static一样,不会报错,但是也不会按照你的想法被赋值,它只会是初值,int就是0,string就是null. InvalidClassException 当序列化对象之后,该对象对应的class文件进行了修改,比如添加了一个属性啊之类的,然后我们再反序列化对象就会失败,同时报错InvalidClassException(无效类异常,也叫序列号冲突异常) 产生该异常的原因: 当我们修改类之后,该类的序列化版本号系统会自动更新,然后与从流中读取的版本号不匹配,导致反序列化失败. 解决办法: 手动生成一个固定的序列号,不让系统自动更新就好了,具体的看下面的图吧. idea可以自动生成序列号,我网上找了个博客,反正就那么几步,很简单的: idea自动生成序列号. 序列化和反序列化的过程 一个小练习 /** * 序列化练习: 序列化集合 * 当我们想在文件中保存多个对象的时候, * 我们就可以把多个对象存储到一个集合中, * 对集合进行序列化和反序列化 */ public class SerializableTest { public static void main(String[] args) throws IOException, ClassNotFoundException { output(); input(); } /** * 序列化方法 */ private static void output() throws IOException { List&lt;Person&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 5; i++) { list.add(new Person(&quot;fanlei&quot; + i, i)); } ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(&quot;list.txt&quot;)); outputStream.writeObject(list); System.out.println(&quot;序列化完成!&quot;); System.out.println(&quot;---------------&quot;); } /** * 反序列化方法 */ private static void input() throws IOException, ClassNotFoundException { ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(&quot;list.txt&quot;)); List&lt;Person&gt; list = (List&lt;Person&gt;) inputStream.readObject(); for (Person p : list) { System.out.println(p); } } }]]></content>
      <categories>
        <category>javase</category>
      </categories>
      <tags>
        <tag>序列化和反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring-02_2]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F06%2F24%2Fspring-02_2%2F</url>
    <content type="text"><![CDATA[有问题可以留言我,虽然我也很菜 依赖注入Bean属性(xml) 说白了其实就是给对象的属性赋值 手动装配,使用xml配置 通过构造方法赋值 例1(通过参数名赋值): 1. 学生类部分代码: private String name; private int age; private String address; public Student() { } public Student(String name, int age, String address) { this.name = name; this.age = age; this.address = address; } 2. xml配置文件(对属性的设置相当于调用了其传三个参的构造方法) &lt;bean id=&quot;student1&quot; class=&quot;service.models.Student&quot;&gt; &lt;!--name是指构造方法中参数的名字--&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;zhangsan&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=&quot;address&quot; value=&quot;wuhan&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=&quot;age&quot; value=&quot;16&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; 3. 测试类 private static void test() { ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans2.xml&quot;); Student student = (Student) context.getBean(&quot;student1&quot;); System.out.println(student); } 例2,其实跟上面一样,只是在xml配置文件注入依赖对象的时候通过索引注入: xml配置 &lt;constructor-arg index=&quot;0&quot; value=&quot;zhangsan&quot; type=&quot;java.lang.String&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg index=&quot;2&quot; value=&quot;wuhan&quot; type=&quot;java.lang.String&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg index=&quot;1&quot; value=&quot;16&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; 通过setter方式赋值 例1(和上面的只有xml中的不同): &lt;bean id=&quot;student2&quot; class=&quot;service.models.Student&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;fanlei&quot;&gt;&lt;/property&gt; &lt;property name=&quot;address&quot; value=&quot;lichuan&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;18&quot;&gt;&lt;/property&gt; &lt;/bean&gt; 通过P 命名空间赋值(赋值的属性必须要有set方法) 例(xmlns xml namespace 即xml命名空间): 1. 在beans.xml最上面(就是在beans标签的开始)导入p标签的命名空间 xmlns:p=&quot;http://www.springframework.org/schema/p&quot; 2. 然后在bean标签内部写上**p:属性=值**就好了 &lt;bean id=&quot;student2_1&quot; class=&quot;service.models.Student&quot; p:name=&quot;lisi&quot; p:address=&quot;sichuan&quot; p:age=&quot;20&quot;&gt;&lt;/bean&gt; SpEL表达式,即spring的el表达式 对进行统一编程,所有的内容都是用value. 格式: 模板: &lt;property name = &quot;&quot; value = #{表达式}&gt; #{123}, #{&apos;abc&apos;}---数字,字符串 #{beanid}---另一个bean的引用 #{beanid.propName}---操作对象的某个属性的值 #{beanid.toString()}---执行方法 #{T(类).字段|方法}---静态方法或字段 例(用student类为例): 1. Student类中的属性(都有get和set方法) private String name; private int age; private String address; private Color color; 2. Color类 public class Color { private String color; public String getColor() { return color; } public void setColor(String color) { this.color = color; } @Override public String toString() { return color; } } 3. xml配置文件 &lt;!--声明一个color类的对象--&gt; &lt;bean id=&quot;colorObject&quot; class=&quot;service.models.Color&quot; p:color=&quot;黄色&quot;&gt; &lt;/bean&gt; &lt;!--SpEL表达式--&gt; &lt;bean id=&quot;student&quot; class=&quot;service.models.Student&quot;&gt; &lt;!--&lt;property name=&quot;name&quot; value=&quot;#{&apos;fanlei&apos;}&quot;&gt;&lt;/property&gt;--&gt; &lt;!--在这里字符串就是一个对象,可以调用方法,快速更改内容赋值--&gt; &lt;property name=&quot;name&quot; value=&quot;#{&apos;fanlei&apos;.toUpperCase()}&quot;&gt;&lt;/property&gt; &lt;!--调用静态方法/字段给属性赋值--&gt; &lt;property name=&quot;age&quot; value=&quot;#{T(Math).PI}&quot;&gt;&lt;/property&gt; &lt;!--调用另一个bean的引用,本例是在student类中调用color类的属性color并将其赋值给student类中的color, ref就是引用的意思--&gt; &lt;!--该行代码表示将colorObject这个对象赋值给student的color属性--&gt; &lt;!--&lt;property name=&quot;color&quot; ref=&quot;colorObject&quot;&gt;&lt;/property&gt;--&gt; &lt;!--上面的代码等于下面这一句代码--&gt; &lt;property name=&quot;color&quot; value=&quot;#{colorObject}&quot;&gt;&lt;/property&gt; &lt;!--修改对象student的address属性为颜色类的属性color--&gt; &lt;property name=&quot;address&quot; value=&quot;#{colorObject.color}&quot;&gt;&lt;/property&gt; &lt;/bean&gt; 4. 测试类 private static void test() { ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans3.xml&quot;); Student student = (Student) context.getBean(&quot;student&quot;); System.out.println(student); } 集合注入 因为我们对象里的属性有可能是集合类型的,所以我们需要知道集合怎么注入的,集合的注入都是给添加子标签 数组: &lt;array&gt; List: &lt;list&gt; Set: &lt;set&gt; Map: &lt;map&gt;, map存放k/v键值对,使用&lt;entry描述&gt; Properties: &lt;props&gt; &lt;prop key = &quot;&quot;&gt;&lt;/prop&gt; 例1–List(数组,set类似的): 1. student类(都有get和set方法) private String name; private int age; private String address; private Color color; private List&lt;String&gt; books; 2. xml配置文件 &lt;bean id=&quot;student&quot; class=&quot;service.models.Student&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;#{&apos;樊磊&apos;}&quot;&gt;&lt;/property&gt; &lt;property name=&quot;books&quot;&gt; &lt;list&gt; &lt;value&gt;语文&lt;/value&gt; &lt;value&gt;数学&lt;/value&gt; &lt;value&gt;英语&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; 3. 测试类 private static void test() { ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans4.xml&quot;); Student student = (Student) context.getBean(&quot;student&quot;); System.out.println(student); 输出: Student{name=&apos;樊磊&apos;, age=0, address=&apos;null&apos;, color=null, books=[语文, 数学, 英语]} } 例2–Map(前面的和上面差不多,我就只给配置文件的了) 配置文件 &lt;bean id=&quot;student&quot; class=&quot;service.models.Student&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;#{&apos;樊磊&apos;}&quot;&gt;&lt;/property&gt; &lt;property name=&quot;books&quot;&gt; &lt;map&gt; &lt;entry key=&quot;语文&quot; value=&quot;必修&quot;&gt;&lt;/entry&gt; &lt;entry key=&quot;数学&quot; value=&quot;必修&quot;&gt;&lt;/entry&gt; &lt;entry key=&quot;英语&quot; value=&quot;必修&quot;&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;/bean&gt; 例3–Properties(也只写配置文件) &lt;bean id=&quot;student&quot; class=&quot;service.models.Student&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;#{&apos;樊磊&apos;}&quot;&gt;&lt;/property&gt; &lt;property name=&quot;books&quot;&gt; &lt;props&gt; &lt;prop key=&quot;语文&quot;&gt;最容易&lt;/prop&gt; &lt;prop key=&quot;数学&quot;&gt;最难&lt;/prop&gt; &lt;prop key=&quot;英语&quot;&gt;还可以&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt;]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring-02_2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[策略模式和单例模式]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F06%2F23%2F%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[策略模式 策略模式即将可变的部分(例如支付的时候选择不同的支付银行)从程序中抽离出来分离成算法接口,在该接口下分别封装一系列算法实现这个这个,这个我看了下慕课的,视频链接我放这里吧: 策略模式视频讲解 组合: 在类中增加一个私有域,引用另一个已有的类的实例,通过调用引用实例的方法从而获得新功能,这种设计被称作组合 鸭子的飞行行为是不变的,但是鸭子的飞行方式是千变万化的,所以我们将飞行接口抽象成一个FlyStragety接口 面向接口编程,而不是面向实现编程,接口为我们提供了一个契约,在总体上提供了一个框架,再通过多态的特性,通过实现类展示同一个方法不同的实现 鸭子发出叫声–通用行为,由父类实现 显示鸭子的外观,鸭子的外观各不相同,声明为abstract,由子类实现 组合为一个策略对象,将飞行行为代理给该对象的实现.private flyStrategy strategy; public void setFlyStrategy flyStrategy(flyStrategy strategy){ this.strategy = strategy;} 设计原则,多用组合,少用继承 策略模式的实现1.通过分离变化得出策略接口strategypublic interface flyStrategy{public abstract void performFly();}2.strategy的实现类public cladd flywithwin implements flystrategy{public void performFly(){System.out.println(“fly”);}}public cladd flynoway implements flystrategy{public void performFly(){System.out.println(“nofly”);}}3.鸭子类要有一个strategy,父类鸭中要有接口引用4.在不同的鸭子中选择正确的strategy实现类,例如橡胶鸭不会飞等 策略模式的优点:1.使用了组合,使得架构更加灵活2.富有弹性,可以较好的应对变化3.相对于继承,有更好的代码复用性4.消除大量的条件语句策略模式的缺点:1.客户代码需要了解每个策略实现的细节2.增加了对象的数目策略模式的使用场景1.许多相关类仅仅是行为差异2.运行时选取不同的算法变体3.通过条件语句在多个分支中选取一个]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>策略模式和单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring-02_1]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F06%2F23%2Fspring-02_1%2F</url>
    <content type="text"><![CDATA[创建spring容器的三种方式创建spring容器的案例代码(只有测试类部分) /** * 创建spring容器的三种方式 */ public class TestUser { public static void main(String[] args) { test(); test2(); test3(); } /** * 第一种: 通过类路径加载 */ private static void test() { /** * 1.加载配置文件创建spring容器,生成user(配置文件中id声明的名字为user)对象 * 其中参数为类路径(class路径),就是src下的路径,可以理解为相对src的相对路径,idea选中xml文件右键会有复制相对路径,那个就是对的 */ System.out.println(&quot;test()&quot;); ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); //2.获取context容器中的user对象 System.out.println(&quot;----------&quot;); UserImpl user = (UserImpl) context.getBean(&quot;user&quot;); //3.1调用方法,也可以通过property设置属性 user.add(); System.out.println(user.getName()); } /** * 第二种: 通过文件系统路径加载配置文件,就是绝对路径 * 选中beans.xml右键单击复制路径就是的 */ private static void test2() { System.out.println(&quot;test2()&quot;); ApplicationContext context = new FileSystemXmlApplicationContext(&quot;D:\\IDEA_Codes\\spring\\day02\\src\\beans.xml&quot;); UserImpl user = (UserImpl) context.getBean(&quot;user&quot;); user.add(); System.out.println(user.getName()); } /** * 第三种: 使用BeanFactory */ private static void test3() { System.out.println(&quot;test3()&quot;); //这种方法加载配置文件是即时加载,对比ApplicationContext源码就知道了 BeanFactory factory = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); System.out.println(&quot;----------&quot;); UserImpl user = (UserImpl) factory.getBean(&quot;user&quot;); user.add(); System.out.println(user.getName()); /** * 当BeanFactory使用下面这种方法时才是延时加载 * BeanFactory context = new XmlBeanFactory(new FileSystemResource(&quot;D:\\IDEA_Codes\\spring\\day02\\src\\beans.xml&quot;)); */ } } 第一种(最常用): 利用ApplicationContext接口通过类路径加载配置文件生成spring容器同时在容器中生成以bean中的id属性值为名的对象 例: 1. 下面就是创建spring容器加载配置文件的方式,就是下面这一行代码 ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); 2. 下面的就是beans.xml配置文件中加载spring容器第一种方式的对UserImpl类的配置内容 &lt;bean id=&quot;user&quot; class=&quot;service.impls.UserImpl&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;licunli&quot;&gt;&lt;/property&gt; &lt;/bean&gt; 1. 过程: 加载配置文件生成spring容器并生成-[service.impls]-包下-[UserImpl类]-的对象-[user],同时给user对象的[name]属性赋值为[&quot;licunli&quot;] 2. 不过要注意的是: 1. name属性在UserImpl类中已经声明好了 2. name属性必须要有set方法,不然赋值不会成功,会报错. 第二种: 通过文件系统路径创建spring容器,并加载配置文件,其中系统路径也就是绝对路径 第三种: 使用BeanFactory,跟第一种差不多,不过用BeanFactory的时候只能用相对路径,用绝对路径会报错 BeanFactory和ApplicationContext对比(这两个都是spring容器,用于去加载配置文件) BeanFactory采用延迟加载(已过时,现在也不延时加载了),第一次getBean时才会初始化Bean(也就是通过构造初始化对象) ApplicationContext是即时加载,是对BeanFactory的扩展,在它的基础上提供了更多的功能,包括以下几个方面: 国际化处理 事件传递 Bean自动装配 各种不同应用层的Context实现 关于BeanFactory和ApplicationContext两个容器加载配置文件时机的说明,如下: 1. 下面这种方法是即时记载无可非议,也就是一装载配置文件就初始化对象,跟单例模式里的饿汉式差不多 ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); 2. 对于BeanFactory,它现在也是即时加载,延时加载的方法过时了 1. 下面这样加载配置文件是延时加载,但是XmlBeanFactory()这个构造方法过时了已经 BeanFactory context = new XmlBeanFactory(new FileSystemResource(&quot;D:\\IDEA_Codes\\spring\\day02\\src\\beans.xml&quot;)); 2. 而这一种方法是即时加载,没过时,同时只能使用相对路径 BeanFactory factory = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); 那么,spring内部创建对象的原理是什么呢? 原理其实就是反射(这东西很多地方用,我要去补习一下),过程如下: 解析xml文件,获取类名,id,属性等 通过反射,用类名创建对象 给创建的对象赋值 装配bean的三种方式 装配bean可以理解为把bean对象放在spring容器中,和创建spring容器连起来看就知道了,反正那一句话既创建了spring容器,还装配了bean对象 下面就表示装配了一个bean: &lt;bean id=&quot;user&quot; class=&quot;service.impls.UserImpl&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;licunli&quot;&gt;&lt;/property&gt; &lt;/bean&gt; 第一种: 就和上面的例子一样直接写就完事了,就相当于new了一个实现类,在java文件中加载配置文件创建了spring容器对象后直接通过getBean()方法获取这个对象就可以使用了 例子: 1. 装配bean对象 &lt;bean id=&quot;user&quot; class=&quot;service.impls.UserImpl&quot;&gt;&lt;/bean&gt; 2. 获取bean对象并使用 ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); UserImpl user = (UserImpl)context.getBean(&quot;user&quot;); user.add(); 第二种: 通过静态工厂方法,就是把生成对象的代码放在静态工厂类中 例子: 1. 静态工厂类 public class UserFactory1 { public static UserImpl createUserImpl() { return new UserImpl(); } } 2. xml文件中装配bean对象 &lt;bean id=&quot;user1&quot; class=&quot;service.UserFactory1&quot; factory-method=&quot;createUserImpl&quot;&gt; &lt;/bean&gt; 3. 获取bean对象并使用 ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); UserImpl user = (UserImpl) context.getBean(&quot;user1&quot;); user.add(); 第三种: 通过实例工厂方法: 就是上面的静态工厂方法去掉了static 例子: 1. 实例工厂类 public class UserFactory2 { public UserImpl createUserImpl() { return new UserImpl(); } } 2. xml中配置 &lt;!--创建实例工厂类对象--&gt; &lt;bean id=&quot;user2&quot; class=&quot;service.UserFactory2&quot; &gt;&lt;/bean&gt; &lt;!--创建bean对象--&gt; &lt;bean id=&quot;user3&quot; factory-bean=&quot;user2&quot; factory-method=&quot;createUserImpl&quot;&gt;&lt;/bean&gt; 3. 获取bean对象并调用 ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); UserImpl user3 = (UserImpl) context.getBean(&quot;user3&quot;); user3.add(); Bean的作用域 singleton(单例,默认,只有一个对象) 例子: 1. beans.xml配置文件 &lt;bean id=&quot;user1&quot; class=&quot;service.impls.UserImpl&quot; scope=&quot;singleton&quot;&gt;&lt;/bean&gt; 2. 测试类 private static void test() { ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans1.xml&quot;); UserImpl user = (UserImpl) context.getBean(&quot;user1&quot;); user.add(); UserImpl user1 = (UserImpl) context.getBean(&quot;user1&quot;); user.add(); System.out.println(user == user1);//true } prototype(中文翻译是原型,可以理解为多例,多次调用getBean生成不同的对象,跟普通new差不多) 1. beans.xml配置文件 &lt;bean id=&quot;user2&quot; class=&quot;service.impls.UserImpl&quot; scope=&quot;prototype&quot;&gt;&lt;/bean&gt; 2. 测试类 private static void test2() { ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans1.xml&quot;); UserImpl user = (UserImpl) context.getBean(&quot;user2&quot;); user.add(); UserImpl user1 = (UserImpl) context.getBean(&quot;user2&quot;); user.add(); System.out.println(user == user1);//false }]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring-02_1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[properties集合]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F06%2F21%2Fproperties%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[Properties属性集 它继承自hashtable类,所以也是键值对形式存储数据的双列集合,且键和值都是一个字符串,我们要注意哈,hashmap和hashtable也继承自map接口,但是hashmap是用来取代hashtable的,因为hashtabl线程不安全,键值对都不能为null之类的 它是唯一一个和io流结合的集合 我们可以使用propperties集合中的store()方法把集合中的临时数据持久化写入到硬盘存储. 我们也可以使用properties集合中的load()方法把硬盘中保存的文件(内容必须是键值对的哈),读取到集合中使用 对于store()方法的举例: /** * 将properties集合中存储的临时数据保存到硬盘中 * public void store（OutputStream out， String comments） * public void store（Writer writer， String comments） * 参数: * OutputStream out:字节输出流,不能写入中文 * Writer writer: 字符输出流,随便写啥都行 * String comments: 注释,用于解释说明我保存的文件是干啥的 * 注意这个注释不能使用中文,会产生乱码,因为它默认是unicode编码,一般使用空字符串 * 使用步骤: * 1. 创建properties集合对象,添加数据 * 2. 创建字节/字符输出流对象,构造方法中绑定要输出的目的地 * 3. 使用properties集合中的store方法把集合中的临时数据持久化写入到硬盘中 * 4. 关闭流 */ private static void show1() { //1. 创建properties集合对象,添加数据 Properties prop = new Properties(); prop.setProperty(&quot;fan1&quot;, &quot;18&quot;); prop.setProperty(&quot;fan2&quot;, &quot;19&quot;); prop.setProperty(&quot;fan3&quot;, &quot;20&quot;); prop.setProperty(&quot;fan4&quot;, &quot;21&quot;); //创建字节/字符输出流对象,构造方法中绑定要输出的目的地,我就放在项目中 FileWriter fw = null; try { fw = new FileWriter(&quot;prop.txt&quot;); //3. 使用properties集合中的store方法把集合中的临时数据持久化写入到硬盘中 prop.store(fw,&quot;save_data&quot;); } catch (IOException e) { e.printStackTrace(); }finally { try { fw.close(); } catch (IOException e) { e.printStackTrace(); } } } 对于load()方法的举例: /** * public void load（InputStream inStream）: 不能读取含有中文的键值对 * public void load​(Reader reader):能读取含有中文的键值对 * 注意: * 1. 键值对之间的连接符一般都是= * 2. 我们可以用#进行注释,#修饰的内容不会被读取 * 3. 键值对都默认是字符串,不用加引号 * */ private static void show2() { //1.创建properties对象 Properties prop = new Properties(); //2.创建输入流对象 FileReader fr = null; try { fr = new FileReader(&quot;prop.txt&quot;); //读取数据到集合对象中 prop.load(fr); //遍历集合 Set&lt;String&gt; names = prop.stringPropertyNames(); for (String s : names) { String value = prop.getProperty(s); System.out.println(s + &quot;: &quot; + value); } } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); }finally { //关闭流 try { fr.close(); } catch (IOException e) { e.printStackTrace(); } } } 因为properties的键值对都是字符串类型的,所以它其中会有一些操作字符串的特殊的方法 public Object setProperty​(String key, String value), 调用Hashtable方法put存储数据到集合中. public String getProperty（String key， String defaultValue, 通过键获取值,就相当于map集合中的get(key)方法. public Set stringPropertyNames(), 从此属性列表返回一组不可修改的键,就相当于map集合中的keyset()方法. 对于操作字符串方法的举例: private static void show() { //创建properties集合对象 Properties prop = new Properties(); //向集合中添加数据 prop.setProperty(&quot;fan1&quot;, &quot;18&quot;); prop.setProperty(&quot;fan2&quot;, &quot;19&quot;); prop.setProperty(&quot;fan3&quot;, &quot;20&quot;); prop.setProperty(&quot;fan4&quot;, &quot;21&quot;); //遍历集合 Set&lt;String&gt; names = prop.stringPropertyNames(); for (String s : names) { System.out.println(s + &quot;: &quot; + prop.getProperty(s)); } }]]></content>
      <categories>
        <category>javase</category>
      </categories>
      <tags>
        <tag>properties集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring-01]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F06%2F21%2Fspring-01%2F</url>
    <content type="text"><![CDATA[Spring概述 Spring是一个开源框架,肯定也是为了提高效率,简化开发啥啥的啦哈哈哈,简单来说,Spring就是一个轻量级的控制反转(IOC–Inversion of Control)和面向切面(AOP–Aspect Oriented Programming,区别于redies中持久化的AOF以及RDB)的容器框架(容器可以理解为来装对象的东西). Spring的好处: 方便解耦,简化开发: Spring就是一个大工厂,专门负责生成和保存Bean对象,可以将所有对象创建和依赖关系维护由spring管理. AOP编程的支持: Spring提供面向切图编程,key方便地实现对程序进行权限拦截,运行监控等. 声明式事务的支持: 只需要通过配置就可以完成对事务的管理,不需要手动码代码. 方便集成各种框架: 其内部提供了对例如struts,mybaties等框架的支持. 方便程序测试: 对Junit4支持,可以通过注解测试. 降低了javaee api的使用难度: 例如对javaee中的java_mail组件,jdbc(说明spring也可以作为dao层),远程调用(webservice)等都提供了封装. 一个科普的点 我们下载spring包的时候,会有三种包: 第一种是以dist.zip结尾的,这表示是编译过的压缩包,里面放着jar什么的,也是我们一般下载的东西,在里面的libs下又有三种格式的jar包: 分别是javadoc.jar结尾(表示是开发文档的jar包),sources.jar结尾(表示源码,就是里面是java文件)以及.jar结尾(表示里面是.class文件) 第二种是以docs.zip结尾的,这是开发文档的包,放着api啊,开发文档啥的. 第三种是以schema.zip结尾的,这是放spring的配置头文件xsd(xml schema definition)的压缩包 Spring的依赖注入讲解 IOC的概念 Inverse Of Control, 反转控制的概念,就是将原本在程序中手动创建的UserService对象的控制权,交由Spring框架管理,简单来说,就是创建UserService对象控制权被反转到了Spring框架. DI概念 Dependency Injection 依赖注入,在Spring框架中负责创建Bean对象时,动态地将依赖对象注入到Bean组件,例如:我们在UserService类中提供了一个name属性以及对应的get/set方法,以前我们要赋值就要自己调用其set方法,但是我们通过Spring的话,我们可以在beans.xml中通过Spring去注入,即通过spring去自动调用set方法,这就叫依赖注入 关于如何创建Spring项目的视频我放百度云,有需要自己下吧: 链接: https://pan.baidu.com/s/1McskKX0BqguszjvXRDvOyA 提取码: 1d87]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jedis_java客户端操作redis工具]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F06%2F20%2Fjedis-java%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%93%8D%E4%BD%9Credis%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[1. Jedis 概念: 一款java操作redis数据库的工具 使用步骤: 下载jedis相关jar包: jedis的jar包. 快速入门使用: 创建一个java项目,导入jar包(maven项目就写好配置文件) 在启动redis服务器的前提下输入这么几行代码: @Test public void test1() { //1.获取连接,如果使用无参构造,其默认值为: localhost 和 6379端口 Jedis jedis = new Jedis(&quot;localhost&quot;, 6379); //2.操作 jedis.set(&quot;name&quot;, &quot;fanlei&quot;); //3.关闭连接 jedis.close(); } 运行之后,打开redis客户端,在黑窗口输入keys *,会发现只有一个name的键存在,输入get name得到我们代码中的值樊磊,这就表示我们已经成功存到redis数据库中了 2. Jedis操作各种redis的数据结构 字符串类型: String(set get del) public void test1() { //1.获取连接,如果使用无参构造,其默认值为: localhost 和 6379端口 Jedis jedis = new Jedis(&quot;localhost&quot;, 6379); //2.操作 //1. 操作string类型的数据 jedis.set(&quot;stringset&quot;, &quot;stringtest&quot;); jedis.set(&quot;stringset1&quot;, &quot;stringtest1&quot;); System.out.println(jedis.get(&quot;stringset&quot;)); //3.关闭连接 jedis.close(); } 哈希类型: hash,也就是map格式–key,value(map的key不重,重复会覆盖其value,hset hget hdel) public void test1() { //1.获取连接,如果使用无参构造,其默认值为: localhost 和 6379端口 Jedis jedis = new Jedis(&quot;localhost&quot;, 6379); //2.操作 //操作哈希类型的数据 jedis.hset(&quot;key&quot;,&quot;field&quot;,&quot;value&quot;); String s = jedis.hget(&quot;key&quot;, &quot;field&quot;); System.out.println(s); //设置其过期时间,效果就是将activecode-value存入redis,10秒后自动删除(可以在客户端用keys *观察效果) String s1 = jedis.setex(&quot;activecode&quot;, 10, &quot;value&quot;); System.out.println(s1); //3.关闭连接 jedis.close(); } 列表类型: list,例如linkedlist(l/rpush lrange l/rpop) public void test1() { //1.获取连接,如果使用无参构造,其默认值为: localhost 和 6379端口 Jedis jedis = new Jedis(&quot;localhost&quot;, 6379); //2.操作 //操作list类型的数据 /*这里有一个点需要注意一下,就是因为list是可重复的 所以当服务器不关闭的时候下面这行语句重复运行后,这些value会不断地往对应的key里面存 所以会导致key对应的list越来越大*/ jedis.lpush(&quot;listl&quot;, &quot;string1&quot;,&quot;string2&quot;); //listl中顺序:&quot;string1&quot;,&quot;string2&quot; jedis.lpush(&quot;listr&quot;, &quot;string3&quot;,&quot;string4&quot;); //listr中顺序:&quot;string3&quot;,&quot;string4&quot; /*List&lt;String&gt; list = jedis.lrange(&quot;listr&quot;, 0, -1); for (String s : list) { System.out.println(s); }*/ System.out.println(jedis.lpop(&quot;listr&quot;)); //获取长度 System.out.println(jedis.llen(&quot;listr&quot;)); //3.关闭连接 jedis.close(); } 集合类型: set,例如hashset(sadd smembers srem) public void test1() { //1.获取连接,如果使用无参构造,其默认值为: localhost 和 6379端口 Jedis jedis = new Jedis(&quot;localhost&quot;, 6379); //2.操作 //操作set集合类型的数据 jedis.sadd(&quot;set&quot;, &quot;member1&quot;, &quot;member2&quot;); jedis.sadd(&quot;set1&quot;, &quot;member3&quot;, &quot;member4&quot;); Set&lt;String&gt; set = jedis.smembers(&quot;set&quot;); Iterator&lt;String&gt; iterator = set.iterator(); while (iterator.hasNext()) { System.out.println(iterator.next()); } System.out.println(&quot;------------------&quot;); //删除set1中的元素 jedis.srem(&quot;set&quot;, &quot;member2&quot;); Set&lt;String&gt; set1 = jedis.smembers(&quot;set&quot;); for (String s : set1) { System.out.println(s); } //3.关闭连接 jedis.close(); } 有序集合类型: sortedset(不重复,有序, zadd zrem zrange) public void test1() { //1.获取连接,如果使用无参构造,其默认值为: localhost 和 6379端口 Jedis jedis = new Jedis(&quot;localhost&quot;, 6379); //2.操作 //操作有序集合类型的数据 jedis.zadd(&quot;key&quot;, 1, &quot;member1&quot;); jedis.zadd(&quot;key&quot;, 2, &quot;member2&quot;); jedis.zadd(&quot;key&quot;, 3, &quot;member3&quot;); Set&lt;String&gt; key = jedis.zrange(&quot;key&quot;, 0, -1); for (String s : key) { System.out.println(s); } System.out.println(&quot;--------------&quot;); jedis.zrem(&quot;key&quot;, &quot;member2&quot;); Set&lt;String&gt; key2 = jedis.zrange(&quot;key&quot;, 0, -1); for (String s : key2) { System.out.println(s); } //3.关闭连接 jedis.close(); } Jedis连接池: JedisPool 使用: 创建连接池对象, 调用方法getResource()获取jedis的连接 public void test1() { //创建jedispoolconfig对象 JedisPoolConfig config = new JedisPoolConfig(); //设置最大连接数 config.setMaxTotal(50); //设置最大空闲数 config.setMaxIdle(10); //1.创建jedis连接池对象,可以使用空参,也可以自己配置 JedisPool jedisPool = new JedisPool(config,&quot;localhost&quot;); //2. 获取连接,返回一个jedis对象 Jedis resource = jedisPool.getResource(); //3. 使用 resource.set(&quot;pool&quot;, &quot;haha&quot;); //4.关闭,将其归还到连接池中 resource.close(); System.out.println(resource.get(&quot;pool&quot;)); }]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>jedis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F06%2F20%2FRedis%2F</url>
    <content type="text"><![CDATA[概念 redis: 它是一款高性能的NOSQL(Not Only SQL)系列的非关系型数据库 注意: 1.Mysql是关系型数据库,Redis是非关系型数据库 2.对于关系型数据库,数据之间有关联关系,而且数据存储在表中(也就是硬盘的文件中) 3.对于非关系型数据库,没有表的概念,数据之间没有关联关系(即没有耦合),存储的是以key-value键值对的形式且数据存在内存中(读取内存数据比文件数据快很多) 4.一般我们都是将数据存储在关系型数据库,然后在非关系型数据库中做备份 下载安装 百度直接搜索redis中文网然后下载解压就好,我把我的放上去: 链接: https://pan.baidu.com/s/1uMJSb7p4NG0Yt59mqo8ioA 提取码: p9c8 分析: 1.redis.windows.conf里面放的是配置文件 2.redis-cli.exe,这是redis的客户端(启动服务器以后再点击客户端就启动了,在黑窗口敲命令就可以了.例如:set name fan–&gt;get name) 3.redis-server.exe, 这是redis的服务端(点一下这个服务器就启动了) Redis数据结构介绍 redis存储的是key,value键值对格式的数据,其中key都是字符串,value值可以有5种不同的数据结构 value的数据结构 不论value是什么类型,它里面的数据都是字符串类型 1.字符串类型: String 2.哈希类型: hash,也就是map格式–key,value 3.列表类型: list,例如linkedlist 4.集合类型: set,例如hashset 5.有序集合类型: sortedset(不重复,有序) 常用命令操作(点那个客户端的exe就可以打开黑窗口了) redis完整教程. 再次强调,redis中的key都是字符串类型的 1.value为字符串类型 1.存储: set key value,例如: set name fan 2.获取: get key,例如: get name 3.删除: del key,例如: del name 2.value为哈希类型 1.存储: hset key field value,例: hset test name fan || hset test age 18 2.获取: hget key field,例: hget test name 3.获取给定key中的所有value: hgetall key,例: hgetall test 4.删除: hdel key field,例: hdel test name 3.value为列表list类型(可重复) Redis列表是简单的字符串列表，按照插入顺序排序,你可以添加一个元素到列表的头部（左边）或者尾部（右边),不能在中间添加 1.添加 1.将元素从列表左边添加: lpush key value 2.将元素从列表右边加入: rpush key value 2.获取: 1.lrange key start end: 范围获取 2.获取指定key中的所有元素: lrange key 0 -1 3.删除 1.lpop: 删除列表最左边的元素并将元素返回 2.rpop: 删除列表最右边的元素并将元素返回 4.value为集合set类型(不重) 当添加的元素是重复的的时候,它就不会添加进去 1.存储: sadd key value 2.获取: smembers key,获取set集合中某个给定key下面的所有元素 3.删除: srem key value,删除set集合中某个key中的某个元素 5.value为有序集合(不重复且有序) Redis 有序集合和集合一样也是string类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个double类型的分数,redis正是通过分数来为集合中的成员进行从小到大的排序 1.存储: zadd key score(这个表示排序顺序) value 例: zadd test 1 a 例: zadd test 1 b–使得a字符和b字符是同样的分数这个是可以的,如果是元素重复的话,它就不会添加进去 例: zadd test 3 a–修改a的分数以改变其顺序 2.获取: zrange key start end 例: 获取指定key下的所有元素及其对应分数: zrank test 0 -1 withscores 3.删除: zrem key value 例: zrem sort a– 删除sort中的a元素 6.通用命令 1.keys : 查询所有的键,其中的表示一个正则表达式 2.type key: 获取对应key的value的类型 3.del key: 删除指定的key及其value redis持久化 持久化: 由于redis是一个内存数据库,也就是说我们的操作都是在内存中进行的,数据都是临时的,当我们服务器一重启,数据就没了,我们可以将redis内存中的数据持久化保存到硬盘的文件中,数据就不会丢失了 持久化机制 1.RDB: 默认方式,不需要进行配置,默认使用的就是这个配置(存放在后缀名为.rdb的文件中) 在一定的间隔时间中,我们去检测key的变化情况,当key达到一定数量后,然后持久化数据 编辑redis.windows.conf这个配置文件中的这样一段内容 save 900 1 表示如果只改变了几条数据,最少一条,在900秒后持久化 save 300 10 表示如果只改变了大于10条,但是小于10000,在300秒之后持久化 save 60 10000 表示如果改变了10000条及以上数据,在60秒之后持久化 当我们修改了配置文件之后,我们需要重新启动redis服务器并指定配置文件名称: 1.在配置文件所在目录打开cmd黑窗口 2.输入redis-server.exe redis.windows.conf服务器就会重启 3.然后再点击客户端的exe文件重启客户端就可以了 2.AOF(存放在一个后缀名为.aof的文件中) 日志记录的方式,可以记录每一条命令的操作,可以每一次命令操作后都持久化数据 步骤: 1.编辑redis.windows.conf这个配置文件中的appendonly no改为appendonly yes就表示开启了AOF持久化存储方式 2.AOF的三个内容: appendfsync always 表示每间隔一次操作都进行持久化 appendfsync everysec(默认) 表示每间隔一秒都进行持久化 appendfsync no 表示不进行持久化 3.当我们修改了配置文件之后,我们也需要重新启动redis服务器并指定配置文件名称,跟RDB一样的,我就不重复写了]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随便写的但是我不太清楚的知识点1]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F06%2F13%2F%E9%9A%8F%E4%BE%BF%E5%86%99%E7%9A%84%E4%BD%86%E6%98%AF%E6%88%91%E4%B8%8D%E5%A4%AA%E6%B8%85%E6%A5%9A%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[位运算 科普一个位运算符的点: &lt;&lt;读作左移,丢弃最高位,右边补0,就相当于乘以2^n &gt;&gt;读作右移,最高位是0,左边补齐0,最高位是1,左边补齐1,相当于除以2^n,当除不尽的时候就要自己算了 &gt;&gt;&gt;读作无符号右移,无论最高位是0还是1,左边都补0,相当于除以2^n. 题目1: 请用最快的方式实现两个整数变量的交换 位运算速度是最快的 当进行异或运算时,出现奇数次的数就是最后的结果,例如a ^ b ^ a其结果为a. int a = 5, b = 15; a = b ^ a ^ a; 此时a = 15; 题目2: 编写一个函数讲一个十六进制的字符串转换为整数返回 public static void main(String[] args) { String str = &quot;ab&quot;; int len = str.length(); int sum = 0; //方法1 for (int i = 0; i &lt; len; i++) { //获取字符 char c = str.charAt(len - 1 - i); System.out.println(c); //获取对应的十进制数 int num = Character.digit(c, 16); sum += num * (1 &lt;&lt; 4 * i); System.out.println(&quot;sum : &quot; + sum); } //方法2 int num = Integer.parseInt(str, 16); System.out.println(&quot;num : &quot; + num); } 集合的遍历方式 List有三种:普通for, 迭代器, 增强for(本质上也是迭代器) Set有两种: 迭代器, 增强for Map有两种: 获取键值对对象集合然后对set集合遍历, 获取键的set集合然后对集合遍历 import java.util.*; public class Test { public static void main(String[] args) { /** * 集合基本都重写了toString()方法,所以查看集合中的元素可以直接打印 * * List 基于数组和链表,可重,存放有序(即放进去的顺序和出来的顺序是一致的),可存放null * set 不可重(你写了多个重复的元素也只会出现一个),通过hashcode和equals判断是否重复 * 注意set存储自定义对象时,自定义类中需要重写这两个方法,不然就会出现可以存放重复元素的情况 * 因为不重写这两个方法就用object的,object中hashcode比较的是地址,两个对象的地址不可能一样 * hashset 底层是哈希表,存放无序(即放进去的顺序和出来的顺序不一定一致的),可存放null * linkedhashset 底层是链表加哈希表 它存放有序且唯一,可存放null * treeset 底层是红黑树,不能放null,通过比较器保证顺序,存放有序,比根节点小的都在左边,大的都在右边,采用中序遍历,先小后大 * map存储键值对,键唯一不重复,当有多个键重复时,取最晚加进来的键的value值 * hashmap,key和value都可以为null,用来替代hashtable的 * hashtable,key和value不可以为null * */ //list遍历方式 List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(1); list.add(2); list.add(3); list.add(null); //list专用遍历方式:普通for for (int i = 0; i &lt; list.size(); i++) { System.out.print(list.get(i) + &quot; &quot;); } System.out.println(); System.out.println(&quot;-----------------&quot;); //迭代器 Iterator&lt;Integer&gt; it = list.iterator(); while (it.hasNext()) { System.out.print(it.next() + &quot; &quot;); } System.out.println(); System.out.println(&quot;-----------------&quot;); //增强for for (Integer i : list) { System.out.print(i + &quot; &quot;); } System.out.println(); System.out.println(&quot;-----------------&quot;); //set遍历方式,没有普通for HashSet&lt;Integer&gt; hashSet = new HashSet&lt;&gt;(); hashSet.add(1); hashSet.add(2); hashSet.add(3); hashSet.add(3); hashSet.add(null); System.out.println(hashSet); //迭代器 Iterator&lt;Integer&gt; setIterator = hashSet.iterator(); while (setIterator.hasNext()) { System.out.print(setIterator.next() + &quot; &quot;); } System.out.println(); System.out.println(&quot;-----------------&quot;); //增强for for (Integer i : hashSet) { System.out.print(i + &quot; &quot;); } System.out.println(); System.out.println(&quot;-----------------&quot;); //map遍历方式 Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); map.put(&quot;a&quot;, 1); map.put(&quot;b&quot;, 2); map.put(&quot;c&quot;, 3); //1.获取所有键值对的集合,entry表示键值对对象,然后按照set方式遍历 Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entries = map.entrySet(); //1.1增强for for (Map.Entry&lt;String, Integer&gt; m : entries) { System.out.print(m + &quot; &quot;); } System.out.println(); System.out.println(&quot;-----------------&quot;); //1.2 迭代器 Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; iterator = entries.iterator(); while (iterator.hasNext()) { System.out.print(iterator.next() + &quot; &quot;); } System.out.println(); System.out.println(&quot;-----------------&quot;); //2.根据键找值,然后根据set遍历方式遍历 //2.1 增强for Set&lt;String&gt; strings = map.keySet(); for (String s : strings) { System.out.print(s + map.get(s) + &quot; &quot;); } System.out.println(); System.out.println(&quot;-----------------&quot;); //2.2 迭代器 Iterator&lt;String&gt; iterator1 = strings.iterator(); while (iterator1.hasNext()) { String s = iterator1.next(); System.out.print(s + map.get(s)+ &quot; &quot;); } System.out.println(); System.out.println(&quot;-----------------&quot;); } } Set接口,继承自Collection接口 Set特点: 1.元素不重复 1.哈希值:一个十进制的整数,没有重写hashCode()的话就由系统给出,反映对象的逻辑地址值(不是物理地址值,所以说哈希值相等不一定两个对象是同一个),通过object中的hashcode()方法可以得到 public native int hashCode(); 其中native表示该方法调用的是本地操作系统的方法 public String toString() { return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode()); } tostring()方法中@后面跟的就是哈希值的十六进制形式 String重写了hashCode()方法,所以就根据其自己的方法来计算哈希值 String str = new String(); System.out.println(str.hashCode());//输出0 &quot;重地&quot;.hashCode() == &quot;通话&quot;.hashCode() == 1179395,这叫哈希冲突,即两个元素不同但是哈希值相同 这也再次证明了hashCode()值相等不代表两个对象相同 2.哈希表(查找速度快)相关 1.jdk1.8以前: 哈希表 = 数组 + 链表 2.jdk1.8以后: 哈希表 = 数组 + 链表,也等于数组 + 红黑树(为了提高查询速度,当链表长度超过8位,这时太大了就把链表转换为红黑树) 3.哈希表 = 数组 + 链表时: 数组中每个位置存放着哈希值相同的元素,在每个位置中,由链表将哈希值相同的元素连接起来,当链表长度大于8位了,就把链表转换成红黑树 set元素不存储重复元素的原理 set集合调用add()方法添加元素的时候,add()方法会调用元素的hashCode()方法和equals()方法判断元素是否重复(先hashCode()再equals()方法),不重复就放到数组中去. 要使得元素不重复,元素所属的类必须重写hashCode()方法和equals()方法. 2.没有索引(collection也没有索引),不能用所有跟索引有关的方法,也就不能用普通for Set的实现类 HashSet TreeSet LinkedHashSet HashSet 特点 元素不重复 没有索引 底层是哈希表(键值对结构,哈希表查询速度极快) 存放无序,即存储元素和取出元素的顺序有可能不一致 TreeSet(基于红黑树的NavigableMap实现) 1.特点: 1.能够对元素按照某种规则进行排序,可以使用元素的自然顺序进行排序,也可以根据创建set时提供的comparator接口进行排序,具体取决于使用的构造方法 2.和set一样,元素唯一 3.注意: 看treeset源码要去看treemap的,因为treeset是基于treemap实现的,直接看treeset的源码看不出来什么东西(写一个treeset然后按住ctrl+鼠标点一下就过去了) 4.treeset底层是红黑树(一种自平衡的二叉树),第二个元素从根节点开始比较,小就往左边放(return 负数),大就往右边放(return 正数),相等就不添加,一直比较到没有子节点,取的时候采用中序遍历 5.String,Integer都实现了comparable接口 2.排序(有两种方式): 1.自然排序(实现Comparable接口,重写compareTo方法) 1.例(自然排序,使用无参构造): public static void main(String[] args) { TreeSet&lt;Integer&gt; treeSet = new TreeSet&lt;Integer&gt;(); treeSet.add(1); treeSet.add(0); treeSet.add(-1); treeSet.add(6); Iterator&lt;Integer&gt; iterator = treeSet.iterator(); while (iterator.hasNext()) { System.out.println(iterator.next()); } } 输出: -1,0,1,6 2.上面的例子中,排序真正的比较是依赖于元素所在类的compareTo方法,而这个compareTo方法是定义在comparable接口中的,所以你要重写该方法就必须实现comparable接口,而Integer类中重写了该方法,所以可以对元素进行自然排序 2.比较器排序(实现Comparator接口) 1.例(比较器排序,让treeset创建对象时使用有参构造) //TreeMap​(Comparator&lt;? super K&gt; comparator) 继承comparator接口,实现其compare方法 public class MyComparator implements Comparator&lt;Student&gt;{ public int compare(Student o1, Student o2) { //先判断年龄 int num = o1.age - o2.age; //年龄相同再判断名字,名字为string类型,实现了自然排序接口 int num2 = num == 0? o1.name.compareTo(o2.name) : num; return num2; } } //测试类 public class Test { public static void main(String[] args) { TreeSet&lt;Student&gt; treeSet = new TreeSet&lt;Student&gt;(new MyComparator()); treeSet.add(new Student(12, &quot;fan&quot;)); treeSet.add(new Student(13, &quot;li&quot;)); treeSet.add(new Student(13, &quot;lei&quot;)); treeSet.add(new Student(14, &quot;li&quot;)); treeSet.add(new Student(14, &quot;li&quot;)); for (Student s:treeSet) { System.out.println(s.name + &quot;:&quot; + s.age); } } } //学生类 public class Student { public int age; public String name; public Student(int age, String name) { this.age = age; this.name = name; } } //当只用一次时候,用匿名内部类实现 public class Test { public static void main(String[] args) { TreeSet&lt;Student&gt; treeSet = new TreeSet&lt;Student&gt;(new Comparator&lt;Student&gt;() { public int compare(Student o1, Student o2) { //先判断年龄 int num = o1.age - o2.age; //年龄相同再判断名字,名字为string类型,实现了自然排序接口 int num2 = num == 0? o1.name.compareTo(o2.name) : num; return num2; } }); treeSet.add(new Student(12, &quot;fan&quot;)); treeSet.add(new Student(13, &quot;li&quot;)); treeSet.add(new Student(13, &quot;lei&quot;)); treeSet.add(new Student(14, &quot;li&quot;)); treeSet.add(new Student(14, &quot;li&quot;)); for (Student s:treeSet) { System.out.println(s.name + &quot;:&quot; + s.age); } } } 3.treeset集合保证元素排序和唯一性原理: 1.唯一性: 是根据添加元素的过程中返回值是否为0决定的. 2.排序: 1.自然排序(集合使用无参构造, 元素具备比较性): 让元素所属的类实现comparable接口,并重写compareTo方法 2.比较器排序(集合使用有参构造, 集合具备比较性): 让treeset集合的构造方法接收一个comparator比较器接口的实现类对象,可以使用匿名类,也可以自己单独写一个类实现该接口,再重写其compare方法. 4.注意:比较器在哪里都可以用,只是以treeset为例子说明比较器的用法]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>我不太清楚的知识点1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F06%2F12%2F%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[链表和数组都是一种数据结构 数组是一段连续的存储空间 链表空间不一定保证连续,只能通过上一个节点的指针找到下一个节点 链表的分类 按照连接方向 单链表: 只有一个数值域和一个指针,而且只能通过next指针指向下一个节点,所以两条单链表是不可能形成X形结构的. 双链表: 有两个指针和一个数值域,pre指针指向上一个节点,next指针指向下一个节点 按照有环无环分类 普通链表: 就是一条线,可以想象为贪吃蛇. 循环链表: 对于单链表来说,首尾相接,最后一个节点的next指针指向头节点. 对于双链表而言,最后一个节点的next指针指向头结点,而头节点的pre指针指向最后一个节点. 单链表插入和删除的注意事项 特殊处理: 链表为空和链表长度为1的情况. 注意插入操作的调整过程. 在中间位置插入节点前要找到插入节点的前一个节点和后一个节点,然后让前一个节点的指针指向要插入的节点,让插入的节点的指针指向后一个节点. 注意删除操作的调整过程 在中间位置删除时,要找到删除节点前一个位置的节点,然后将前一个位置的节点指向删除节点的下一个节点就可以了 注意考虑头尾节点的插入和空节点的情况 单链表的翻转操作 当链表为空或者链表长度为1时,特殊处理 思路就是定义一个两个节点,一个前节点pre,一个后节点next,next不断指向头结点下一个节点,头结点指向pre节点实现逆序,然后pre,head,next依次向后移 废话不多说,上代码: 单链表反转代码 给定一个整数num,如何在节点值有序的环形链表中插入一个节点值为num的节点,并且保证这个环形单链表依然有序,要求时间复杂度为O(N),额外空间复杂度为O(1) 插入指定数到环形链表代码 给定一个头结点head,再给定一个数num,请把链表调整成节点值小于num的节点都放在链表的左边,等于num的节点都放在链表的中间,大于num的都放在链表的右边 思路1: 我们可以借助辅助空间,将链表放在数组中,然后按照荷兰国旗的思路去做 借助数组在链表中插入值代码. 思路2:可以不借助数组,就把整个链表分成三个小链表,分别是小于num的,等于num的,大于num的,最后把三个链表穿起来就可以了 不借助辅助空间在链表中插入值代码. 给定两个有序链表的头结点head1和head2,打印两个有序链表的公共部分 首先我们要判断两个链表任何一个为空,直接返回即可 就类似于归并排序的归并过程,两个链表依次比较,同时移动,相同的话就打印这个数,然后两个都移动,任何一个为空就停止. 打印链表公共部分代码 给定一个单链表的头结点,实现一个调整单链表的函数,使得每K个节点之间逆序,如果最后不够K个节点,则不调整最后几个点 例:1-&gt;2-&gt;3-&gt;4-&gt;null, k = 3 调整后为: 3-&gt;2-&gt;1-&gt;4-&gt;null 思路1: 借助栈来实现,不断压栈,栈的大小达到k的时候就弹栈,再连接上就好了,不过这个有很多细节,差点搞死我,不懂的话看着代码举个例子一步一步来,或者给我留言吧 思路1代码. 思路2: 通过一个变量来计数,当这个变量为3的倍数的时候就逆序,时间复杂度为O(N),额外空间复杂度为O(1),不过这个很绕,第一种方法没懂的话,这个就很难写 思路2代码. 给定一个链表的头结点head,节点中值是整数,给定一个整数val,把节点值等于val的节点都删掉 这个就很简单了,注意如果删除头节点的话,他的前一个节点是null就可以了 删除指定值节点代码 判断一个单链表是否是回文序列 例: 1-&gt;2-&gt;2-&gt;1为回文序列 方法1: 时间复杂度为O(N),额外空间复杂度为O(N) 思路: 把链表都放入栈中,然后弹栈和原来的链表依次比较,如果一直到栈内元素全部弹出都一样,说明是回文结构 判断是否为回文结构方法1代码. 方法2: 时间复杂度为O(N),额外空间复杂度为O(N/2) 思路: 画个图对比着看,也是申请一个栈结构,然后用一个快指针和一个慢指针去遍历链表,快指针一次走两步,慢指针一次走一步,当快指针的next以及next.next都为null时,说明慢指针到中间了(偶数到中间的前一个,奇数个刚好是中间),然后弹栈去和慢指针比较,都一样就返回true 判断是否为回文结构方法2代码. 方法3: 时间复杂度为O(N),额外空间复杂度为O(1) 思路: 同样也是申请快慢指针,只是这次不借助辅助空间栈了,我们让慢指针直接走到下半部分的第一个,然后把下半部分逆序,然后让上半部分和逆序后的下半部分比较就完事了 判断是否为回文结构方法3代码. 两张图给你们看看理解一下,实在不懂再问我吧]]></content>
      <categories>
        <category>链表</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql学习-事务]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F06%2F12%2Fmysql%E5%AD%A6%E4%B9%A0-%E4%BA%8B%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[大家有问题可以给我留言,我看到了会第一时间回复大家 数据库的备份和还原 命令行方式(cmd黑窗口下): 备份语法: mysqldump -u用户名 -p密码 数据库名称&gt; 保存的路径(要包括保存的数据库名称). 例子: mysqldump -uroot -proot db1 &gt; D:\MySQL\mysqldata\db1.sql 还原语法(cmd黑窗口下,数据也在): 登录数据库: mysql -uroot -proot 创建一个空数据库: create database db1; 使用数据库: use db1; 执行文件: source 文件路径: source D:\MySQL\mysqldata\db1.sql 图形化界面都有直接导入导出的按钮. 事务 事务的基本介绍 概念: 如果一个包含多个步骤的业务操作,被事务管理,那么这些操作要么同时成功,要么同时失败. 操作 开启事务: start transaction. 回滚: rollback. 提交: commit. 例子(转账): 张三和李四初始账户金额都为1000元. 张三给李四转账500元. 步骤: 1. 张三账户金额 -500. 2. 李四账户金额 +500. 但是如果张三金额减少之后出错了,李四账户就不会增加500元 那么这500就不翼而飞了,这是我们不希望看到的. -- 张三给李四转账500 -- 开启事务 START TRANSACTION; -- 张三账户金额-500 UPDATE account SET balance = balance - 500 WHERE NAME = &apos;张三&apos;; -- 李四账户金额+500 -- 出错了... UPDATE account SET balance = balance + 500 WHERE NAME = &apos;李四&apos;; -- 出现了问题我们就回滚事务 ROLLBACK; 这两部分要分开运行. 因为不是java代码,它只会顺序执行,所以只能分开运行展示效果. 还要注意当我们写了start trancation,表示手动提交事务后 在事务没有运行到提交语句或回滚语句前,事务就一直处于开启状态 所以在当前图形化界面下他的金额还是会减少 这是一个临时数据,为了更直观 我们可以新开一个图形化界面专门用来查询该表数据 因为临时数据就不会再另一个图形化界面去 -- 开启事务 START TRANSACTION; -- 张三账户金额-500 UPDATE account SET balance = balance - 500 WHERE NAME = &apos;张三&apos;; -- 李四账户金额+500 -- 出错了... UPDATE account SET balance = balance + 500 WHERE NAME = &apos;李四&apos;; -- 没有问题我们就提交事务 COMMIT; 事务提交方式: 自动提交(直接执行DML语句): mysql数据库中事务默认自动提交(在没有执行开启事务语句时),即一条DML语句会自动提交一次事务,将数据持久化存储. 手动提交(oracle就是默认手动提交的): 执行了start transaction后,就表明事务时手动提交的了,没有执行回滚或提交语句时,它会默认回滚,数据不会持久化存储. 修改事务默认提交方式: 查看事务默认提交方式(在mysql图形化界面中中执行语句): select @@autocommit—1代表自动提交,0代表手动提交; 修改默认事务提交方式为手动: set @@autocommit = 0; 事务的四大特征 原子性: 即不可分割的最小操作单位,要么同时成功,要么同时失败. 持久性: 事务一旦提交或者回滚,它就会持久更新数据库表中的数据. 隔离性: 多个事物之间,相互独立,但其实实际使用过程中,有可能会存在关系的,所以我们需要了解隔离级别嘛. 一致性: 事务操作前后数据总量不变(例如张三和李四都有1000,张三给李四转了500,他俩加起来还是2000). 事务的隔离级别(了解) 概念: 多个事务之间是隔离的,即相互独立的,但是如果多个事务操作同一批数据,则会引发一些问题,设置不同的隔离级别就可以解决这些问题. 存在的问题: 脏读: 一个事务读取到另一个事务中没有提交的数据. 不可重复读(虚读): 在同一个事务中,两次读取到的数据不一样. 幻读: 一个事务操作(DML)数据表中所有数据,另一个事务添加了一条数据,但第一个事务查询不到自己的修改(这个在mysql里面演示不出来,因为mysql执行了DML语句后,本事务中会按照dml语句产生临时数据,也就是说本事务会临时修改数据,其它事务中数据没有提交前不会改变,提交之后就会改变) 隔离级别: 1.read uncommitted: 读未提交,即表示当前事务或其他事务能读取到未提交的数据. 会产生的问题: 脏读, 不可重复读, 幻读. 2.read committed: 读已提交,即表示当前事务或其他事务只能读取到已提交的数据.(oracle默认) 会产生的问题: 不可重复读, 幻读. 3.repeatable read: 可重复读.(mysql默认) 会产生的问题: 幻读. 4.serializable: 串行化. 可以解决上述产生的全部问题,也就是说这个隔离级别不会产生任何问题 注意: 隔离级别从小到大安全性越来越高,但是效率越来越低. 数据库查询隔离级别: select @@tx_isolation; 数据库设置隔离级别: set global transaction isolation level 级别字符串, 如: set global transaction isolation level serializable. DCL语句(了解) 概念: 数据控制语句,管理用户并对用户进行授权等相关操作. 管理用户 安装好数据库之后,都会有一个默认的数据库mysql,里面有一个表user,用户的信息都在里面. 1.添加用户 语法: CREATE USER ‘用户名‘@’主机名’ IDENTIFIED BY ‘密码’ -- 创建用户只在本地访问 CREATE USER &apos;fan&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;123&apos;; -- 创建用户可以在任意主机访问 CREATE USER &apos;fan&apos;@&apos;%&apos; IDENTIFIED BY &apos;123&apos;; 2.删除用户 语法: DROP USER ‘用户名‘@’主机名’. -- 删除用户 DROP USER &apos;fan&apos;@&apos;localhost&apos;; 3.修改用户密码 语法: UPDATE USER SET PASSWORD = PASSWORD(‘新密码’) WHERE USER = ‘用户名’; SET PASSWORD FOR ‘用户名‘@’主机名’ = PASSWORD(‘新密码’); 在mysql中,忘记了root用户的密码怎么办? 1. 以管理员身份运行cmd,然后在cmd黑窗口下敲: `net stop mysql`停止mysql服务. 2. 使用无验证方式启动mysql服务: `mysqld -- skip-grant-tables`. 3. 然后这个管理员方式运行的cmd就会停在那里闪光标不动,我们不关闭它,新打开一个cmd黑窗口(不用以管理员身份运行),直接输入`mysql`,不需要账号密码,敲回车就可以进去mysql服务了. 4. 然后在新打开的cmd窗口中改密码就可以了,改完之后关闭全部窗口. 5. 然后打开任务管理器,手动关闭mysqld.exe进程. 6. 最后以管理员身份重新开一个cmd黑窗口,先输入`mysql -start mysql`启动mysql服务, 然后用刚才修改后的密码登录mysql即可. 4.查询用户 -- 切换到mysql数据库 USE mysql; -- 查询user表,有两条记录 SELECT * FROM USER; -- 第一条记录表示当前主机可以登录,第二条记录表示可以远程访问当前数据库 -- %是通配符,表示可以在任意主机使用用户登录数据库(包含了当前主机) 授权管理 1.查询权限 语法: SHOW GRANTS FOR &#39;用户名&#39;@&#39;主机名&#39;; -- 查询权限 SHOW GRANTS FOR &apos;fan&apos;@&apos;localhost&apos;; 查询结果为: `grant usage...`,这个usage表示只能用于登录 SHOW GRANTS FOR &apos;root&apos;@&apos;localhost&apos;; 查询结果为: `grant all privileges...`,这个all privileges表示拥有所有权限 2.授予权限 语法: grant 权限列表 on 数据库名.表名 to &#39;用户名&#39;@&#39;主机名&#39; -- 除了已有的权限外,授予fan查询和删除db1数据库的emp表的权限 GRANT SELECT,DELETE ON db1.emp TO &apos;fan&apos;@&apos;localhost&apos;; 此时在cmd黑窗口,用fan登录后,敲`use db1`就不会报错了 但是当你敲`show tables`的时候,你只能看到emp这一张表 而且,fan这个用户只能查询和删除db1的emp表,不能增删改. 因为给予的是select和delete权限. -- 给fan授予所有权限,在任意数据库任意表上 GRANT ALL ON *.* TO &apos;fan&apos;@&apos;localhost&apos;; 3.撤销权限 语法: REVOKE 权限列表 ON 数据库名.表名 FROM &#39;用户名&#39;@&#39;主机名&#39;; -- 撤销fan的登录权限 REVOKE USAGE ON db2.emp FROM &apos;fan&apos;@&apos;localhost&apos;]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql学习-事务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql学习-多表查询和子查询]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F06%2F11%2Fmysql%E5%AD%A6%E4%B9%A0-%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2%E5%92%8C%E5%AD%90%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[#多表查询 其查询所有集合的结果集又被称为笛卡尔积. 笛卡尔积是指有两个集合,我们取这两个集合的所有组成情况,集合1有两行数据,集合2有三行数据,则笛卡尔积一共有2*3=6条数据. 要完成多表查询,我们就需要消除无用的数据. 查询语法: select 列名列表 from 表名列表 where…… 创建员工表和部门表 – 创建部门表 CREATE TABLE department( id INT PRIMARY KEY AUTO_INCREMENT, dep_name VARCHAR(20),-- 部门名称 dep_location VARCHAR(20) );– 创建员工表 CREATE TABLE employee( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(30) NOT NULL, age INT NOT NULL, dep_id INT,-- 对应部门表的主键id constraint emp_dep foreign key(dep_id) reference department(id)-- 将部门表的id作为员工表dep_id的外键约束 ); 多表查询的分类: 内连接查询: 隐式内连接查询:使用where条件来消除无用数据 例如: 查询所有员工信息及其对应的部门信息 SELECT * FROM employee, department WHERE dep_id = department.id; 例如: 查询员工表的id,姓名,年龄,部门表的id,姓名,位置(注意这里要区分id是哪个表的id,不然会报错) SELECT employee.id,NAME,age,department.id,dep_name,dep_location FROM employee,department WHERE dep_id = department.id; 给表起别名(最正规的写法) SELECT t1.id,t1.name,t1.age,t2.id,t2.dep_name,t2.dep_location FROM employee t1,department t2 WHERE t1.dep_id = t2.id; 显式内连接查询: 语法: select 字段列表 from 表名1(只写一张表) [inner] join 表名2 on 条件. 其中inner可以省略. 例如: 查询所有员工信息及其对应的部门信息 SELECT * FROM employee INNER JOIN department ON dep_id = department.id; 例如: 查询查询员工表的id,姓名,年龄,部门表姓名,位置 SELECT t1.id, t1.NAME, t1.age, t2.dep_name, t2.dep_location FROM employee t1 JOIN department t2 ON t1.dep_id = t2.id; 内连接查询注意事项: 1. 要确定从哪些表中查询数据. 2. 确定查询条件. 3. 确定好查询的字段,一般都不用`*`. 外连接查询: 左外连接查询 查询的是左表所有数据以及其与右表交集部门,内连接查询的就只有两者交集部分 语法 select 字段列表 from 表1 left [outer] join 表2 on 条件; 其中outer也可省略 例如:查询所有员工信息,有部门则显示部门信息,没有部门则显示null 因为如果用内连接查询,没有部门的信息不会显示出来的. SELECT * FROM employee t1 LEFT JOIN department t2 ON t1.dep_id = t2.id; 右外连接查询 查询的是右表的所有记录和与左表的交集部分. 语法 select 字段列表 from 表1 right [outer] join 表2 on 条件; 其中outer也可省略 例子: 查询所有部门信息,有员工则显示员工信息,没有员工则显示null 因为如果用内连接查询,没有员工的信息不会显示出来的. SELECT * FROM employee t1 RIGHT JOIN department t2 ON t1.dep_id = t2.id; 子查询: 概念: 即查询中嵌套查询,称嵌套的查询为子查询,比如下面第一个例子中的SELECT MAX(age) FROM employee;. 子查询的不同情况 子查询的结果是单行单列的: 子查询可以作为条件,使用运算符(&gt;,&lt;,=,&gt;=,&lt;=等)去判断 例子: 查询年龄最大的员工信息 -- 1. 查询年龄的最大值 SELECT MAX(age) FROM employee; -- 2. 查询员工信息,并且年龄等于21的 SELECT MAX(age) FROM employee; -- 3. 一条sql完成,**子查询为括号中的查询语句** SELECT * FROM employee t1 WHERE t1.age = (SELECT MAX(age) FROM employee); 例子: 查询年龄小于平均年龄的人 SELECT * FROM employee WHERE age &lt; (SELECT AVG(age) FROM employee); 子查询的结果是多行单列的: 子查询也可以作为条件,使用运算符in来判断 例子: 查询`研发部`和`运营部`的所有员工信息 -- 1. 查询研发部和运营部的id SELECT id FROM department WHERE dep_name = &apos;研发部&apos; OR dep_name = &apos;运营部&apos;; -- 2. 查询dep_id为1的员工信息 SELECT * FROM employee WHERE dep_id = 1 OR dep_id = 2; -- 3. 一条sql,子查询 SELECT * FROM employee WHERE dep_id IN (SELECT id FROM department WHERE dep_name = &apos;研发部&apos; OR dep_name = &apos;运营部&apos;); 精简过后是这样: SELECT * FROM employee WHERE dep_id IN (SELECT id FROM department WHERE dep_name in (&apos;研发部&apos;,&apos;运营部&apos;)); 子查询的结果是多行多列的: 子查询可以作为一张虚拟表加以运用. 例子: 查询年龄为18的员工的所有信息,包括部门信息 SELECT * FROM department t1, (SELECT * FROM employee WHERE age = 18) t2 -- 查询年龄为18的员工信息 WHERE t1.id = t2.dep_id; 用普通内连接查询就这样写 SELECT * FROM employee t1, department t2 WHERE t1.age = 18 AND t2.id = t1.dep_id; #练习 -- 部门表 CREATE TABLE dept ( id INT PRIMARY KEY PRIMARY KEY, -- 部门id dname VARCHAR(50), -- 部门名称 loc VARCHAR(50) -- 部门所在地 ); -- 添加4个部门 INSERT INTO dept(id,dname,loc) VALUES (10,&apos;教研部&apos;,&apos;北京&apos;), (20,&apos;学工部&apos;,&apos;上海&apos;), (30,&apos;销售部&apos;,&apos;广州&apos;), (40,&apos;财务部&apos;,&apos;深圳&apos;); -- 职务表，职务名称，职务描述 CREATE TABLE job ( id INT PRIMARY KEY, jname VARCHAR(20), description VARCHAR(50) ); -- 添加4个职务 INSERT INTO job (id, jname, description) VALUES (1, &apos;董事长&apos;, &apos;管理整个公司，接单&apos;), (2, &apos;经理&apos;, &apos;管理部门员工&apos;), (3, &apos;销售员&apos;, &apos;向客人推销产品&apos;), (4, &apos;文员&apos;, &apos;使用办公软件&apos;); -- 员工表 CREATE TABLE emp ( id INT PRIMARY KEY, -- 员工id ename VARCHAR(50), -- 员工姓名 job_id INT, -- 职务id mgr INT , -- 上级领导 joindate DATE, -- 入职日期 salary DECIMAL(7,2), -- 工资 bonus DECIMAL(7,2), -- 奖金 dept_id INT, -- 所在部门编号 CONSTRAINT emp_jobid_ref_job_id_fk FOREIGN KEY (job_id) REFERENCES job (id), CONSTRAINT emp_deptid_ref_dept_id_fk FOREIGN KEY (dept_id) REFERENCES dept (id) ); -- 添加员工 INSERT INTO emp(id,ename,job_id,mgr,joindate,salary,bonus,dept_id) VALUES (1001,&apos;孙悟空&apos;,4,1004,&apos;2000-12-17&apos;,&apos;8000.00&apos;,NULL,20), (1002,&apos;卢俊义&apos;,3,1006,&apos;2001-02-20&apos;,&apos;16000.00&apos;,&apos;3000.00&apos;,30), (1003,&apos;林冲&apos;,3,1006,&apos;2001-02-22&apos;,&apos;12500.00&apos;,&apos;5000.00&apos;,30), (1004,&apos;唐僧&apos;,2,1009,&apos;2001-04-02&apos;,&apos;29750.00&apos;,NULL,20), (1005,&apos;李逵&apos;,4,1006,&apos;2001-09-28&apos;,&apos;12500.00&apos;,&apos;14000.00&apos;,30), (1006,&apos;宋江&apos;,2,1009,&apos;2001-05-01&apos;,&apos;28500.00&apos;,NULL,30), (1007,&apos;刘备&apos;,2,1009,&apos;2001-09-01&apos;,&apos;24500.00&apos;,NULL,10), (1008,&apos;猪八戒&apos;,4,1004,&apos;2007-04-19&apos;,&apos;30000.00&apos;,NULL,20), (1009,&apos;罗贯中&apos;,1,NULL,&apos;2001-11-17&apos;,&apos;50000.00&apos;,NULL,10), (1010,&apos;吴用&apos;,3,1006,&apos;2001-09-08&apos;,&apos;15000.00&apos;,&apos;0.00&apos;,30), (1011,&apos;沙僧&apos;,4,1004,&apos;2007-05-23&apos;,&apos;11000.00&apos;,NULL,20), (1012,&apos;李逵&apos;,4,1006,&apos;2001-12-03&apos;,&apos;9500.00&apos;,NULL,30), (1013,&apos;小白龙&apos;,4,1004,&apos;2001-12-03&apos;,&apos;30000.00&apos;,NULL,20), (1014,&apos;关羽&apos;,4,1007,&apos;2002-01-23&apos;,&apos;13000.00&apos;,NULL,10); -- 工资等级表 CREATE TABLE salarygrade ( grade INT PRIMARY KEY, -- 级别 losalary INT, -- 最低工资 hisalary INT -- 最高工资 ); -- 添加5个工资等级 INSERT INTO salarygrade(grade,losalary,hisalary) VALUES (1,7000,12000), (2,12010,14000), (3,14010,20000), (4,20010,30000), (5,30010,99990); -- 需求： -- 1.查询所有员工信息。查询员工编号，员工姓名，工资，职务名称，职务描述 SELECT t1.id, t1.ename, t1.salary, t2.jname, t2.description FROM emp t1, job t2 WHERE t1.job_id = t2.id; -- 2.查询员工编号，员工姓名，工资，职务名称，职务描述，部门名称，部门位置 SELECT t1.id, t1.ename, t1.salary, t2.jname, t2.description, t3.dname, t3.loc FROM emp t1, job t2, dept t3 WHERE t1.job_id = t2.id AND t1.dept_id = t3.id; -- 3.查询员工姓名，工资，工资等级 SELECT t1.ename, t1.salary, t2.grade FROM emp t1, salarygrade t2 WHERE t1.salary &gt;= t2.losalary AND t1.salary &lt;= t2.hisalary; 也可以写成这样 SELECT t1.ename, t1.salary, t2.grade FROM emp t1, salarygrade t2 WHERE t1.salary BETWEEN t2.losalary AND t2.hisalary; -- 4.查询员工姓名，工资，职务名称，职务描述，部门名称，部门位置，工资等级 SELECT t1.ename, t1.salary, t2.jname, t2.description, t3.dname, t3.loc, t4.grade FROM emp t1, job t2, dept t3, salarygrade t4 WHERE t1.job_id = t2.id AND t1.dept_id = t3.id AND t1.salary BETWEEN t4.losalary AND t4.hisalary; -- 5.查询出部门编号、部门名称、部门位置、部门人数 SELECT t1.id, t1.dname, t1.loc, (SELECT COUNT(*) FROM emp WHERE emp.dept_id = t1.id) num FROM dept t1; 也可以这样写 -- 使用分组查询和子查询 SELECT t1.id, t1.dname, t1.loc, t2.num FROM dept t1, (SELECT dept_id, COUNT(id) num FROM emp GROUP BY dept_id) t2 WHERE t1.id = t2.dept_id; -- 6.查询所有员工的姓名及其直接上级的姓名,没有领导的员工也需要查询 SELECT t1.id, t1.ename, t1.mgr, t2.ename FROM emp t1, LEFT JOIN emp t2 ON t1.mgr = t2.id;]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql学习-多表查询和子查询</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql学习-多表操作和三大范式]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F06%2F11%2Fmysql%E5%AD%A6%E4%B9%A0-%E5%A4%9A%E8%A1%A8%E6%93%8D%E4%BD%9C%E5%92%8C%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[数据库的设计多表之间的关系 一对一的关系(了解) 例如: 人和身份证之间的关系 分析: 这么读: 一个人只有一个身份证,一个身份证只对应一个人 如果两句话都没有问题,那就是一对一的关系. 一对多(多对一)的关系 例如: 部门和员工 分析: 一个部门有多个员工, 一个员工只能对应一个部门. 多对多的关系 例如: 学生和课程 分析: 一个学生可以选择多门课程,而一个课程也可以被很多学生选择. 一对多(多对一)关系实现 例如: 部门和员工 在多的地方建立外键,指向为一的另一方的主键 在本例中就是在员工表中建立外键,指向部门表的主键id 多对多关系实现 例如: 学生和课程 我们需要借助一张中间表,中间表至少包含两个字段,这两个字段作为中间表的外键,分别指向两张表的主键 这里还可以有一个联合主键的知识点,即某一个学生的id对应于某一门课程的id只能出现一次 例如id为1的学生只能选一门id为1的课,不能选多门id为1的课. create table test( cid int,-- 课程id sid int,-- 学生id primary key(rid, uid), -- 联合主键 foreign key(cid) reference course(id), foreign key(sid) reference student(id), ); 这里省略了添加外键约束时的constraint关键字,使用系统给的名字 一对一关系实现 例如: 人和身份证 在任意一张表中添加外键,指向另一张表的主键 同时还需要让外键唯一,防止重复. 多表关系案例 有三个实体: 旅游路线分类, 旅游路线, 用户 有三张表: 旅游路线分类(cid,name), 旅游路线(rid, name, price), 用户(uid, name, password) 分析: 一个分类对应多条线路,而一条线路只对应一个分类. 所以分类和线路之间是一对多的关系,我们在线路中添加一列作为外键,指向分类的主键就可以了 一个用户可以收藏多条线路,而一个线路可以有多个用户选择 所以线路和用户之间是多对多的关系 我们需要一张中间表,包含rid和uid,分别作为外键指向两张表的主键. 数据库设计的范式(只学前三个) 概念: 范式即设计数据库时需要遵循的一些规范,要遵循后面的范式,就必须先遵循前面的所有范式. 设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小. 目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）. 第一范式(1NF) 定义: 即数据库表的每一列都是不可分割的原子数据项，而不能是集合，数组，记录等非原子数据项。 第二范式(2NF) 定义: 在1NF的基础上，非码属性必须完全依赖于码（在1NF基础上消除非主属性对主码的部分函数依赖） 函数依赖: A—&gt;B,如果A属性(属性组)的值可以确定唯一B属性的值,则称B依赖于A 例如: 学号—&gt;姓名.例如: (学号, 课程名称)这个属性组—&gt;分数. 完全函数依赖: A—&gt;B,如果A是一个属性组,则B属性值的确定需要依赖于A属性组中所有的属性值,即B列完全函数依赖A列. 例如: (学号, 课程名称)这个属性组—&gt;分数,单单靠学号或者课程名称是无法唯一确定分数的. 部分函数依赖: A—&gt;B,如果A是一个属性组,则B属性值的确定只需要A属性组中某一些值即可,这就表示B属性部分函数依赖于A. 例如: (学号, 课程名称)—&gt;姓名. 传递函数依赖: A—&gt;B, B—&gt;C,如果通过A属性(属性组)可以唯一确定B属性(属性组)的值,然后再通过B属性(属性组)的值,可以唯一确定C属性(属性组)的值,则称C传递函数依赖于A. 例如: 学号—&gt;姓名, 姓名 —&gt;系主任. 码: 在一张表中,如果一个属性或属性组被其它所有属性完全函数依赖,则称这个属性(属性值)为该表的码 主属性: 即码属性组中的所有属性.非主属性: 即除码属性组的其它属性.例如: 在给定图片中,码为(学号, 课程名称) 第三范式(3NF) 定义: 在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖） . 分析: 1. 该图片中,系这一列包含两列,则表明该表不满足第一范式. 2. 要解决该问题,就要把系名和系主任两列拆开来作为两列,就变成了下面这样. . 分析: 1. 存在非常严重的冗余: 学号,姓名,系名,系主任等重复的很高. 2. 数据添加存在问题. 1. 比如添加一个新开设的系时,数据不合法,因为根本没有学生. 3. 数据删除存在问题. 1. 比如张无忌毕业了,删除张无忌的数据会删除它所在的系和系主任 2. 要是只有他一个学生的话,那这个系就不存在了,这是不合理的. 4. 该表中,(学号,课程名称)为码,只有分数是完全函数依赖于码的,姓名,系名,系主任都是部分依赖,我们消除部分依赖将其升级为第二范式,如下图: . 分析: 1. 解决了数据冗余的问题,但是数据添加和数据删除的问题仍然没有解决. 2. 我们的第二张表中,系名依赖于学号,而系主任依赖于系名,所以系主任传递依赖于学号. 3. 我们消除传递依赖将其升级为第三范式,如图: . 分析: 1. 解决了数据添加和数据删除存在的问题. 2. 这就是我们设计出来的可以用的数据库表.]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql学习-多表操作和三大范式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql学习-表的约束]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F06%2F06%2Fmysql%E5%AD%A6%E4%B9%A0-%E8%A1%A8%E7%9A%84%E7%BA%A6%E6%9D%9F%2F</url>
    <content type="text"><![CDATA[约束 概念: 对表中的数据进行限定,从而保证数据的正确性,有效性和完整性. 分类: 主键约束: primary key. 非空约束: not null. 唯一约束: unique. 外键约束: foreign key. 非空约束: not null,值不能为空 添加约束方法1—在db1数据库创建表时添加约束: USE db1; CREATE TABLE IF NOT EXISTS stu( id INT, NAME VARCHAR(20) NOT NULL -- 表示name不能为空 添加约束方法2—创建表结束后,添加非空约束 alter table stu change name name varchar(20) not null; 删除name的非空约束: alter table stu change name name varchar(20); 唯一约束: unique,值不能重复 注意: 在mysql中,当列添加了唯一约束时,我们添加该列的值为null时,是不会报错的,即唯一约束的列可以有多个null. 创建表时添加唯一约束 CREATE TABLE IF NOT EXISTS stu( id INT UNIQUE, NAME VARCHAR(20) NOT NULL, phone VARCHAR(20) UNIQUE ); 创建表后添加唯一约束 ALTER TABLE stu MODIFY phone VARCHAR(20) UNIQUE; ALTER TABLE stu CHANGE phone phone VARCHAR(20) UNIQUE; 删除唯一约束,这个和删除非空约束不一样 ALTER TABLE stu DROP INDEX phone; 主键约束 注意: 主键约束表示该字段非空且唯一. 一张表只能有一个字段为主键. 其实主键就是表中每条记录的唯一标示,例如每个人的身份证号. 创建stu表时给id添加主键约束 CREATE TABLE IF NOT EXISTS stu( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(20)); 创建表以后添加主键同时设置自动增长 ALTER TABLE stu CHANGE id id INT PRIMARY KEY AUTO_INCREMENT; 删除stu表中的id主键约束,不是删除这一列哈,只是删除它的约束(这个和唯一约束一样,删除方式和其它不大一样). -- 先删除自动增长 ALTER TABLE stu MODIFY id INT; -- 再删除主键约束 ALTER TABLE stu DROP PRIMARY KEY; 但是这里需要注意: 设置了自动增长的主键约束的列或者字段都是不能直接进行修改操作的,我们只能删除主键那一列的所有数据不能只删除主键约束,或者我们可以先删除自动增长,再删除主键约束,再进行修改操作. 自动增长 注意: 自动增长要和主键一起用. 如果主键是数值类型的,使用auto_increment可以完成值的自动增长. 自动增长只跟上一行的值有关系,比如上一行我添加一个元素,给定id为525,则下一行id自动增长为526. 创建stu表时给id添加主键约束同时使得id自增长 CREATE TABLE IF NOT EXISTS stu( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(20)); 创建表以后添加主键同时设置自动增长 ALTER TABLE stu CHANGE id id INT PRIMARY KEY AUTO_INCREMENT; 删除stu表中的id自动增长,不是删除这一列哈,只是删除它的约束(这个和唯一约束不一样). ALTER TABLE stu MODIFY id INT; 外键约束 外键主要是为了让表与表之间产生关系,保证数据的正确性. 创建emp表同时赋值数据,我们发现这样子会很冗余,也就是说部门名字和部门位置会有很多重复的. – 创建emp表 CREATE TABLE emp( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(30) NOT NULL, age INT NOT NULL, dep_name VARCHAR(20),-- 部门名称 dep_location VARCHAR(20) ); 为了解决这个冗余的问题,我们进行表的拆分,然后两个表关联起来就好了, 即将一个表用来存放员工信息,一个表用来存放部门信息. 创建部门和员工表 – 创建部门表 CREATE TABLE department( id INT PRIMARY KEY AUTO_INCREMENT, dep_name VARCHAR(20),-- 部门名称 dep_location VARCHAR(20) ); – 创建员工表 CREATE TABLE employee( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(30) NOT NULL, age INT NOT NULL, dep_id INT,-- 对应部门表的主键id ); 在创建表时添加外键 语法: create table 表名( 字段名 字段类型, 字段名 字段类型, ... 外键字段名 字段类型, constraint 外键名称 foreign key(外键列名) reference 主表名称(主表字段名称) **千万注意这里constraint是另外一个语句,所以前面的要加逗号**. ); – 创建员工表 CREATE TABLE employee( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(30) NOT NULL, age INT NOT NULL, dep_id INT,-- 对应部门表的主键id constraint emp_dep foreign key(dep_id) reference department(id)-- 将部门表的id作为员工表dep_id的外键约束 ); 当创建成功外键后,我们去删除部门表中的某个部门会报错,因为员工表有这个部门的人存在,当我们去员工表添加不存在的部门的时候也会报错,这在没有外键约束的时候是没有的功能. 删除外键 alter table 要添加外键的表名 drop foreign key 外键名; -- 删除emmployee表中的外键约束 alter table employee drop foreign key emp_dep; 在创建表之后创建外键 alter table 要添加外键的表名 add constraint 自定义外键名 foreign key(要添加外键约束的字段名) reference 外键约束所在列表(外键约束字段) -- 给employee的dep_id添加外键约束 ALTER TABLE employee ADD CONSTRAINT emp_dep FOREIGN KEY(dep_id) REFERENCES department(id); 此时要保证employee中所有员工的部门标号在department中都是存在的,不然该语句不会更新成功. ##外键约束_级联操作 例如在上述例子中,我们希望当我们更改部门表中的id字段的时候,员工表自动更新为相应的id,如果没有级联操作,部门表的id字段修改会报错. 创建表之后添加外键的时候设置级联更新 ALTER TABLE employee ADD CONSTRAINT emp_dep FOREIGN KEY(dep_id) REFERENCES department(id) ON UPDATE CASCADE; 创建表之后添加外键的时候设置级联更新以及级联删除 已有外键要先删除外键 ALTER TABLE employee ADD CONSTRAINT emp_dep FOREIGN KEY(dep_id) REFERENCES department(id) ON UPDATE CASCADE ON DELETE CASCADE; 此时删除部门表中的相关部门就会删除员工表中的该部门的所有数据,所以级联删除慎用!!!!!!]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql学习-表的约束</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql学习-DML语句和DQL语句]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F06%2F05%2Fmysql%E5%AD%A6%E4%B9%A0-DML%E8%AF%AD%E5%8F%A5%E5%92%8CDQL%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[DML语句: 增删改表中数据(很重要) 添加数据 语法: insert into 表名(列名1, 列名2,…列名n) values(值1, 值2,…,值n); 应该在插入单行的时候使用VALUES，在插入多行的时候使用VALUE, 这样速度比较快一点,不过两个都是对的. 插入多行是这样的: insert into student(name, age) value(‘a’, 1)(‘b’,2); 注意事项: 列名和值要一一对应. 如果表名后不定义列名,则默认给所有列添加值. 字符串类型需要使用引号引起来,用单引号双引号都可以. 删除数据 语法: delete from 表名 [where 条件]; 如: delete from student where id = 1; 注意: []表示这个可选部分,可以写也可以不写. 如果不加where条件,则删除表中所有记录,和truncate效果一致. truncate table student; 表示删除表,然后在创建一个一模一样的空表,一般我们理解为删除所有数据但是保留表结构. 不推荐用delete删除表中所有数据,因为有多少条语句就会执行多少次delete语句,效率很低,但是如果我们用truncate, 它就只会执行两条语句,先drop表,然后create表,效率快很多. 修改数据 语法: update 表名 set 列名1 = 数据1,列名2 = 数据2,…列名n = 数据n [where 条件]; 注意: []表示这个可选部分,可以写也可以不写. 不加条件就会修改所有记录. DQL语句: 查询表中的记录 select * from 表名; 查询语句(单表) 语法: select 字段1,字段2... from 表名 where 条件1, 条件2... group by 分组字段 having 分组之后的条件 order by 排序字段1,排序字段2 limit 开始索引,每页条数 基本查询 多个字段查询 例: 查询student表中的姓名和年龄 select name, age from student; 去除重复 例: 查询student表中所有姓名,去除姓名重复的. select distinct name from student; 例: 查询student表中所有姓名,年龄,去除姓名和年龄重复的. select distinct name, age from student; 这里要注意,这样写要保证distinct后面的字段必须都相同才会被去除 计算列(数值型的加减乘除,字符型的没意义) 例: 计算student列中每个学生的数学和英语的分数以及两门课加起来的总分 select name, math, english, math + english from student; 这里会有一个问题,就是比如我数学有分数,但是英语是个null,总分就会是null 例: 计算student列中每个学生的数学和英语的分数以及两门课加起来的总分(排除null影响) select name, math, english, ifnull(math,0) + ifnull(english,0) from student; 起别名 例: 计算student列中每个学生的数学和英语的分数以及两门课加起来的总分(排除null影响以及起别名) select name, math, english, ifnull(math,0) + ifnull(english,0) as total from student; as可以省略 条件查询 where子句后跟条件 运算符 &gt;, &lt;, &lt;=, &gt;=, =, &lt;&gt;(不等号), !=. 例: 查询student表中分数大于60的人的信息. select * from student where score &gt; 60. between...and.... 例: 查询student表中分数在60-100的人的信息(包括60和100), select * from student where score between 60 and 100; select * from student where score &gt;= 60 and score &lt;= 100; in(集合). 例: 查询score为60,70的人的所有信息. SELECT * FROM student WHERE score = 60 OR score = 70; SELECT * FROM student WHERE score IN (60,70); is null. 注意两个单词之间有空格,以及注意区分和ifnull()的区别. is null是用来判断是否某个字段. ifnull是用来设置当碰到空值的时候如何处理. is null中间有空格而ifnull中间没有. 例: 查询score为null的人的信息 select * from student where score = null;– 这样什么都查不出来,即使用score为null的也不会显示任何信息,因为null不能用=(!=)判断. 正确写法: select *from student where score is null; 例: 查询score不为null的人的信息 select * from student where score is not null; and 或 &amp;&amp;. or 或 ||. not 或 !. 排序查询 语法: order by 子句 order by 排序字段1 排序方式1, 排序字段2 排序方式2… 例1:查询student表中所有信息,按照分数升序排序 select * from student. 例2:查询student表中的所有信息,按照分数升序,如果分数一样,则按照年龄升序. SELECT * FROM student ORDER BY score ASC, age ASC; 排序方式: 升序: asc, 不指定排序方式就默认升序. 降序: desc. 注意: 如果有多个排序条件,只有当第一个条件的值一样时,才会去判断第二个条件,以此类推… 聚合函数 将一列数据作为一个整体进行纵向的计算. count: 计算这一列的总个数. 例1: 计算student表中有多少条记录. select count(*) from student; 例2: 计算student表中age这一列一共有多少条记录. select count(age) from student; 例3: 计算student表中description这一列一共有多少记录(其中部分行为null,我们不能忽略null). 为了保证可以计算为空值的列,我们可以判断一下,如果为null,就当作为’未知’这个值来判断,这样子这个null的行也会被算进去,但是原表中的数据不是改变. select count(ifnull(description, ‘未知’)) from student; 我们也可以这样子,选择一个非空的列(例如id这个主键列)计算,或者写成count(*),只要这一条记录有一个不为null就会被计算(不过这个不推荐,选择主键列更好). select count(id) from student; max: 计算这一列的最大值. 例: 找出student表中score的最大值 SELECT MAX(score) FROM student; min: 计算这一列的最小值. 例: 找出student表中score的最小值 SELECT MIN(score) FROM student; sum: 计算这一列的和. 例: 计算student表中score列的总和. SELECT SUM(score) FROM student; avg: 计算这一列的平均值. 例: 计算student表中score列的平均值 SELECT AVG(score) FROM student; 注意: 所有聚合函数的计算会排除null值的列,也就是说,比如查询某一列的总数,null值得那一行会被忽略. 都可以通过IFNULL()函数解决,以上面的平均值为例 SELECT AVG(IFNULL(score, 0)) FROM student.这样就会把null的当作0处理,就会被计算在其中了. 分组查询 语法: group by 分组字段; 例: 将student表按照gender分组,分别查询男同学和女同学的平均年龄,要防止为空. SELECT AVG(IFNULL(age, 0)) FROM student GROUP BY gender; 例: 将student表按照gender分组,分别查询男女同学的平均分以及人数,其中分数低于60分的不参与分组. SELECT gender, AVG(IFNULL(score, 0)), COUNT(id) FROM student WHERE score &gt; 60 GROUP BY gender; 这就表示如果你的score小于60,你就不会参与分组过程,就相当于这个表中没有这些记录一样,所以count也不会把它计算在内. 例: 将student表按照gender分组,分别查询男女同学的平均分以及人数,其中分数低于60分的不参与分组,同时要使得分组之后显示的数据中,count(id)计算的人数都超过一个人. SELECT gender, AVG(IFNULL(score, 0)), COUNT(id) FROM student WHERE score &gt; 60 GROUP BY gender HAVING COUNT(id) &gt; 1; SELECT gender, AVG(IFNULL(score, 0)), COUNT(id) total FROM student WHERE score &gt; 60 GROUP BY gender HAVING total &gt; 1; 这就表示在满足要求的前提下,给count(id)加了个别名total. 注意: 分组之后查询的字段应该为分组字段或者聚合函数,其它的没有意义. 例: SELECT gender FROM student GROUP BY gender;– 输出’男’和’女’. 例: SELECT score FROM student GROUP BY gender;– 这样写只会输出第一个男和第一个女的分数. 例: 在student中按照性别分组,然后分别计算其score的平均值(防止null值). SELECT sex,AVG(IFNULL(score, 0)) FROM student GROUP BY gender;– 输出性别以及对应的平均分. 在student中按照性别分组,然后分别计算其score的平均值和男女同学各自的人数(防止null值). SELECT gender,AVG(IFNULL(score, 0)), COUNT(id) FROM student GROUP BY gender;–输出性别以及对应的平均分以及男女人数. 分组后查询的字段可以有多个,可以是多个聚合函数和分组字段结合. where和having的区别: where在分组之前进行限定,如果不满足where中的条件,则不参与分组. having在分组之后进行限定,如果不满足结果,则不会被查询出来. where后不可以跟聚合函数. having后可以进行聚合函数的判断,也可以跟字段名. 分页查询 语法: limit 开始的索引 每页查询的条数; 例: 在student表中,每页显示3条记录,而且当前是第一页. select * from student limit 0, 3; 例: 在student表中,每页显示3条记录,而且当前是第二页. select * from student limit 3, 3; 例: 在student表中,每页显示3条记录,而且当前是第三页. select from student limit (3 - 1) 3, 3; 公式: 开始的索引 = (当前页码-1) * 每页查询的条数. 注意: 索引从0开始. 注意这里是索引,不是id,和id没有关系的,指定开始的索引之后,它就会从指定的索引(比如索引0就表示第一行)开始输出,输出查询的条数,不管你的id是否是连续的,比如说我索引从1开始,查询3个,他就会从表中第二行开始输出,输出三行. limit进行分页操作是一个”方言”,每个数据库分页的关键字不一样,limit关键字只能在mysql中用. 模糊查询(like) like的占位符: _: 表示单个任意字符. %: 表示多个任意字符. 例: 查询student表中姓樊的同学的信息 select * from student where name like ‘樊%’; 例: 查询第二个字是磊的同学的信息 select * from student where name like ‘_磊%’; 例: 查询姓名是三个字的同学的信息(三个_就可以了) select * from student where name like ‘___’; 例: 查询姓名中包含李的人 selcet * from student where name like ‘%李%’;]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql学习-DML语句和DQL语句</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql学习-DDL语句]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F06%2F05%2Fmysql%E5%AD%A6%E4%B9%A0-DDL%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[sql基本概念 什么是sql? Structured Query Language 结构化查询语言 通俗来说就是定义了操作所有关系型数据库(如mysql,oracle,sqlserver等)的规则 每一种操作数据库的方式存在不一样的地方,类似于”方言”.sql通用语法 sql语句可以单行或多行书写,以分号结尾. 例如:(在cmd黑窗口下) 查看所有数据库名称: SHOW DATABASES;(切记后面要加s). 查看数据库物理存放位置: show global variables like &quot;%datadir%&quot;. 可使用空格和缩进来增强语句可读性. mysql语句中的sql不区分大小写,但是关键字建议大写. 有3种注释:(cmd窗口下) 单行注释: – 注释内容 注释内容(mysql特有) 注意--符号后面有一个空格,#后面有没有空格都行. 多行注释: / 注释内容 / sql分类 DDL(Data Definition Language)数据定义语言 用来定义数据库对象: 比如数据库,表,视图等. 关键字: create, drop, alter等. DML(Data Manipulation Language)数据操作语言 用来对数据库中表的数据进行增删改. 关键字:update, insert, delete等. DQL(Data Query Language)数据查询语言 用来查询数据库中表的记录(也就是数据) 关键字: select, where等. DCL(Data Control Language)数据控制语言(不管) 用来设置或更改数据库用户或角色权限的. DDL语句: 操作数据库,表 操作数据库: CRUD C(Create): 创建 例如:(在cmd黑窗口下) 创建一个名为`db1`的数据库(条件语句是判断是否存在) create database if not exists db1; 创建一个字符集为gbk的数据库 create database db1 character set gbk; 创建一个名为`db1`且字符集为gbk的数据库 create database if not exists db1 character set gbk; R(Retrieve): 查询 例如:(在cmd黑窗口下) 查询所有数据库名称: SHOW DATABASES;(切记后面要加s). 查询test数据库创建语句(还可以查看该数据库的字符集是utf-8还是啥): show create database test; 查询数据库物理存放位置: show global variables like &quot;%datadir%&quot;. U(Update): 修改 例如:(在cmd黑窗口下) 修改db1数据库的字符集为utf8(不能写成utf-8): alter database db1 character set utf8. D(Delete): 删除 例如:(在cmd黑窗口下) 删除db1数据库: drop database db1. 删除db1数据库,先判断是否存在: drop database if exists db1. 使用数据库 使用db1数据库: use db1; 查询当前正在使用的数据库名称: select database(); 操作表: CRUD C(Create): 创建 例如:(在cmd黑窗口下) 在db1数据库中创建一张学生表student use db1; create table student( id int, name varchar(23), score double(5,2), birthday date, add_time timestamp ); * 语法: * create table 表名( 列名1 数据类型1, 列名2 数据类型2, ... 列名n 数据类型n ); * 注意: 最后一列不需要加逗号!!! * 常用数据类型: * int: 整数类型. * 例如: age int. * double: 浮点数类型. * 例如: score double(5,2), 其中括号中第一个5表示小数一共最多5位,小数点后最多2位,所以他的最大值为999.99. * date: 日期类型, 只包含年月日, 格式为: yyyy-MM-dd. * datetime: 日期类型, 包含年月日时分秒, 格式为: yyyy-MM-dd HH:mm:ss. * timestamp: 时间戳类型, 包含年月日时分秒, 格式为: yyyy-MM-dd .HH:mm:ss. * date当不给值或给值为null时,表中就存放null,没有默认值. * timestamp和datetime区别: * 使用timestamp,如果将来不给这个字段赋值,或赋值为null,则默认使用当前系统时间来自动赋值. * varchar: 字符串类型. * 例如: name varchar(20), 括号中的参数表示姓名最大20个字符,超过了会报错,zhangsan占8个字符,而张三只占两个字符. * R(Retrieve): 查询 例如:(在cmd黑窗口下) 查询db1数据库中所有表的名称(要先使用数据库哈) use db1; show tables; 查询db1数据库中db表的信息(包括字段及其信息): use db1; desc db; * U(Update): 修改 * 修改表名 例如:(在cmd黑窗口下) 修改stu表的表名为students alter table stu rename to students; * 修改表字符集 例如:(在cmd黑窗口下) 修改students表的字符集为gbk 先查看字符集 show create table students; 然后修改字符集为gbk alter table students character set gbk; * 修改列 * 修改列名,类型 * modify只能修改类型,而change可以修改类型和列名. * 修改类型的时候用modify可以比change少写一个列名哈哈哈. 例如:(在cmd黑窗口下) 在students表中将nickname列改成gender列 alter table students change nickname gender varchar(1); 在student表中将nickname的类型改为10个字符 alter students modify nickname varchar(10); alter student change nickname nickname varchar(10). * 添加列 例如:(在cmd黑窗口下) 在students表中添加列nickname alter table students add nickname varchar(20); * 删除列 例如:(在cmd黑窗口下) 删除student表中的nickname列 alter table students drop nickname; * D(Delete): 删除 例如:(在cmd黑窗口下) 删除db1数据库下student表 use db1; drop table if exists student; * 删除表中数据可以用delete(DML语句)和truncate(DDL语句) * truncate用于删除整张表的数据,但是保留表结构,格式为: truncate table 表格名, 和没有where的delete类似. * 当你不再需要该表时， 用 drop；当你仍要保留该表，但要删除所有记录时， 用 truncate；当你要删除部分记录时（always with a WHERE clause), 用 delete. * 效率方面:drop &gt; truncate &gt; delete * 复制表 例如:(在cmd黑窗口下) 在db1数据库下复制studen表为stu表 use db1; create table stu like student;]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql学习-DDL语句</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[maven学习]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F06%2F03%2Fmaven%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[maven概念 我们之前写代码时,会导入很多需要的jar包,都放在项目中,然后这就会造成我们开发完成后项目变得很大,而maven就是来解决这种问题的,用maven开发项目,jar包不在项目中,而在jar包仓库中存放着,通过pom.xml文件的配置获取jar包，而不用手动去添加jar包,所以我们的项目空间就会占用的很少,一个普通web项目要几十兆的话,一个maven只需要几百k. 所以说,maven就是用来合理叙述项目间的依赖关系的.可以这么理解,当有十个相同需要jar包的项目的时候,传统的项目都会导入这些相同的jar包,而maven的jar包都在仓库中放着,只需要导入一次,是不是就节省了空间,就跟代码重用一样的道理. maven的核心功能: 其一就是依赖管理: 即maven工程对jar包的管理过程. 其二就是一键创建. maven项目的一键构建: 我们之前的项目,使用本地安装的tomcat的时候,都是要经过编译,测试,运行,打包,安装,部署等一系列过程. 什么是maven构建: 指的是项目从编译,测试,运行,打包,安装,部署整个过程都交给maven管理. 什么是maven一键构建: 指的是我们不再使用本地安装的tomcat,而使用maven自身继承的tomcat插件,整个构建过程,使用maven一个命令就可以轻松完成. 关于maven的安装流程(切记要先装jdk). maven仓库的种类和各个仓库间的关系maven工程-----里面放的有jar包坐标 --首先.它会自动去c盘找本地仓库: `${user.home}/.m2/repository`,其中`${user.home}`就表示系统盘. --**刚安装好maven**的时候我们电脑上的**本地仓库**是没有jar包的. --本地仓库找不到之后,这时候如果我们电脑联网了,它就会自动去网上的中央仓库(放着几乎所有开源的jar包)下载jar包,没联网就会报错. 总结一下: 仓库分三类: 本地仓库: jar包在本地的放置位置,启动maven项目首先会默认在本地找jar包. 中央仓库: 启动maven项目在本地找不到对应jar包的时候,就会去中央仓库找. 远程仓库(私服): 在公司中,一般都会自己建一个远程仓库供公司使用,和maven项目所在的电脑在同一个局域网的时候,本地找不到它会先在远程仓库找,远程仓库找不到再去中央仓库下载. 本地仓库位置的修改: 找到maven解压目录下的conf文件夹—&gt; settings.xml—&gt; 通过’自定义本地仓库路径‘修改, 注意路径不能有中文,不能有空格. maven标准目录结构 maven项目构成 核心代码部分 核心代码配置文件部分 测试代码部分 测试代码配置文件部分 传统的都是放在src目录下的 maven项目标准目录结构 src/main/java目录 放置核心代码部分. src/main/resource目录 放置核心代码配置文件部分. src/test/java目录 放置测试代码部分 src/test/resources目录 放置测试配置文件部分 (web工程比java工程多一个)src/main/webapp目录 放置界面资源,包括js,css,图片等 maven常用命令我传了一个很简单的maven项目,大家可以根据这个来掌握命令,尤其是注意一下其中路径的写法: maven项目. mvn clean 会删除maven项目下的target目录 mvn compile 重新生成maven项目下的target目录(里面放着src/main/java目录下编译后的class文件等) mvn test 会在target目录下生成一个test-classes文件夹,里面放着src/test/java下的代码的编译class文件 注意: 如果直接编译test文件,没有target目录会自动生成,而且还会编译src/main/java下的核心代码 mvn package 打包项目,没有target目录会生成target目录,里面放着打包生成的war包,而且会自动编译核心代码和测试代码. mvn install 该命令相当于执行了前面三个命令,没有target目录会生成target目录,会自动编译核心代码和测试代码,而且该命令生成的war包也会放在该目录下,同时会自动将该war包安装到本地仓库. 后一个命令的执行,都包含了前一个命令的执行,即我执行mvn test,会包含执行mvn compile这个意思. maven生命周期 清理生命周期 即: mvn clean. 默认生命周期 即: mvn compile-&gt;test-&gt;package-&gt;install-&gt;deploy 站点生命周期(不管) maven概念模型图. 项目对象模型中包括: 项目自身信息,项目运行所依赖的jar包信息,项目运行环境信息,比如jdk等. 依赖管理模型放的都是jar包的坐标,它指向的三个箭头从下往上依次是: 本地仓库, 远程仓库, 中央仓库. 注意: maven的生命周期中的每个构建命令都对应了maven底层的一个插件. idea如何使用maven的话,我百度云上面有视频,我分享给大家吧: idea创建项目-要提取码的话就是:tk6r.几个问题 在用idea创建maven的web项目的时候,我碰到了一个问题,就是src/main/java下不能创建servlet,搞了半天,解决办法如图:. 我们在web项目中需要导入jar包时就只需要在pom.xml下添加这样一段话就好了: &lt;dependencies&gt; 要多少个jar包就写多少个&lt;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 在这里还要注意: 这个idea是可以帮我们完成的,在报错的地方看提示:类似添加到dependencies的字样 当我们自己添加的时候,先填&lt;artifactId&gt;,如果你的本地仓库有这个jar包,填的时候有提示,如果本地仓库没有,就要去中央仓库找 可以直接百度maven中央仓库,我把链接放这里: maven中央仓库 然后搜索你要的jar包,然后复制对应jar包的&lt;dependency&gt;到当前项目下的pom.xml中来就ok,如果电脑联网了,它会自动下载jar包到本地来的. 我在创建maven项目后,运行的时候,报错说无法编译jsp文件,也搞了我好久,原因是因为tomcat和jdk不兼容,我的jdk是1.8,需要tomcat7才可以兼容,而maven默认用的是tomcat6,解决办法如图: 注意: 在这期间可能tomcat下载不下来,反正我就是这样,你只需要选中右侧的那个Dependencies,然后鼠标右键点击Download Resources就可以完美解决.. 还有一个错就是说在运行的时候,报错说不能将servlet作为httpservlet,反正就是这么个意思,原因是因为本地tomcat中的jar和maven中的jar包重合了,解决办法是在依赖中添加一句话,是的编译的时候用依赖中的jar,运行的时候用tomcat的jar.如图: 对于maven项目中xml依赖配置的问题: 一般它的属性默认就可以了,也就是编译运行测试都用,但是有几个常用的不是这样子 jsp和servlet设置为provided,只用于编译和测试,因为它会和tomcat中的jar冲突,造成不能将servlet识别为httpservlet. jdbc驱动设置为runtime,只用于运行时. junit设置为test,表示只用于测试时. 记得在maven安装路径下的config文件夹下的setting.xml中把&lt;mirrors&gt;改成阿里云的,贼快,国外的网如果你没有翻墙你会哭的,相信我,直接复制下面的过去就可以了,亲测有效. &lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;/mirrors&gt; 还有就是在用maven连接数据库的时候,这个依赖不是最新最好,而是要适应自己数据库版本才行!!!!我上过当,我是5.1的数据库下载了一个8.0的依赖,搞死我了!!!!]]></content>
      <categories>
        <category>javaee</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法_初级4]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F05%2F25%2F%E7%AE%97%E6%B3%95-%E5%88%9D%E7%BA%A74%2F</url>
    <content type="text"><![CDATA[猫狗队列问题. 猫狗队列代码. 转圈打印矩阵(matrix)给定一个矩阵,请你按照顺时针转圈的方式打印它,如图: 如下: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 打印结果应该为:1 2 3 4 8 12 16 15 14 13 9 5 6 7 11 10. 这类似的题目不能去想如何由第一个下标变成第二个下标,然后第二个下标如何变成第三个下标这样子,这样子会贼难写,而且边界还很容易出错. 正确思路:用一种宏观的感觉,找到矩阵的左上角位置(a,b),和右下角下标(c,d),我们通过a,b,c,d四个点可以确定一个框,这个框正是我们要打印的一圈, 如图: . 转圈打印矩阵代码. 将二维数组旋转90°然后输出 例子: 原数组: 1 2 3 4 5 6 7 8 9 转换后的数组: 7 4 1 8 5 2 9 6 3 思路:和上面一样,用一种宏观的思路,给定左上角和右下角的坐标位置,先转外面一圈,然后转里面一圈,直到左上角元素坐标大于右下角坐标为止,不过这种题就有点扣边界,反正我做这种题就很难受,可能因为我逻辑思维太差了吧. 旋转二维数组代码. 之字形打印矩阵1.题目: . 2.示例: . 3.思路: . 4.之字形打印矩阵代码.5.注意: 暂时不变的放在前面,免得暂时变化的会影响,比如这题中的左上角的行要放在列的后面!!!!不然会搞死人的. 反转链表这个博客的图画的巨好,巨容易懂,也算是夏天的一丝清凉,真的是要热死了: 理解反转链表 题目: 输入一个链表，反转链表后，输出新链表的表头 反转链表代码. 在行列都排好序的矩阵中找数 题目: . 思路: 注意这里的行和列都是从小到大有序的. 先确定右上角A的坐标(左下角也行,其实四个角都行,看你自己,这里以右上角为例),然后判断和要找的元素的大小. A比目标元素大,就左移. A比目标元素小,说明A这个元素左边的都比目标元素小,就往下走. 总的来说,就是大就往左移,小就往下移,最后还没有就返回false. 在行列都有序的矩阵中找目标值代码. 打印两个有序链表的公共部分 思路: 可以理解为归并排序的归并部分执行的行为. 打印有序链表公共部分代码. 判断一个链表是否为回文结构 题目: . 最难理解的就是两个逆序的过程,多想想画一画,我反正这个题搞了我一上午. 判断一个链表是否为回文结构代码. 将单向链表按某值划分成左边小, 中间相等, 右边大的形式. 第一问: 思路: 类似荷兰国旗,因为第一问不要求稳定性,所以我们可以把单向链表放在一个数组中,然后在数组中排好序以后,再转化为链表形式. 将链表存放在数组中代码. 此时时间复杂度和额外空间复杂度都为O(N). 第二问(被这个链表搞的有点烦,这个第二问就没搞):别人的第一问和第二问的代码. 复制含有随机指针节点的链表(这个题我没做) 哈希表的增删查时间复杂度都是O(1) 代码. 有哈希表的时候额外空间复杂度为O(N),时间复杂度为O(N),不用哈希表的时候额外空间复杂度为O(1),时间复杂度为O(N) 两个单链表相交的一系列问题(这个题我没做). 对于单链表,一个链表有环,一个链表无环,不可能相交 代码.]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法_初级4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法_初级3]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F05%2F23%2F%E7%AE%97%E6%B3%95-%E5%88%9D%E7%BA%A73%2F</url>
    <content type="text"><![CDATA[1.注意: * 栈中: push是压栈,peek是返回栈顶元素,pop是弹栈. * 队列中: offer是进队列,poll是出队列,peek是返回队列首元素. * linkedlist实现了queue接口,所以我们可以把linkedlist当作队列来使用.其中queue接口和list,set接口一样都是继承自collection接口. 实现一个特殊的栈,在实现栈的基础功能的基础上,再实现返回栈中最小元素的操作. 要求: pop, push, getMin操作的时间复杂度都是O(1). 设计的栈类型可以使用现成的栈结构. 思路: 设计两个栈,一个和正常栈一样放数据,另一个用来放最小值 每次数据栈中有数进来的时候,就和最小值栈中的栈顶元素比较,当数据栈栈顶元素&gt;最小值栈栈顶元素的时候,最小值栈再存入一个当前栈顶元素,反之存入数据栈栈顶元素. 如图: 特殊栈找最小元素图解. 代码. 如何用队列结构实现栈结构? 思路: 用两个队列,当push的时候,就放在其中一个队列中,然后要弹栈和返回栈顶元素的时候,将除了最后一个元素的其它元素倒入另一个队列中,然后返回队列中剩余的最后一个元素. 队列实现栈结构代码. 看了代码以后要注意的地方: 交换的函数swap不能带参数,带参数之后,它改变的就只是参数,而不是成员变量,就相当于swap没发挥作用,因为变量有就近原则,找离自己进的,有参数的时候找参数哈哈哈. 只能将数据队列最后一个参数赋值给一个局部变量然后返回,不能直接返回数据队列的最后一个元素,因为在返回前,数据队列和辅助队列引用交换了 如何用栈结构实现队列结构? 思路: 用两个栈,一个栈专门给offer方法用,另一个栈专门给poll和peek方法用,当需要出队列或者返回队列首元素的时候,就把offer方法专用的栈中的数据全部倒入另一个栈中,然后返回和出队列. 注意事项: 专门给poll和peek用的栈有两个注意事项: 倒就要一次性全部倒完. 倒的时候要保证该队列为空. 栈结构实现队列代码.]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法题目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Filter和Listener]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F05%2F22%2FFilter%E5%92%8CListener%2F</url>
    <content type="text"><![CDATA[servlet+filter+listener被称为javaweb的三大组件 Filter(重要) Filter: 过滤器 生活中的过滤器: 如生活中的净水器,空气净化器等都是过滤器. web中的过滤器: 当浏览器通过请求访问服务器资源时,过滤器可以将请求拦截下来,来完成一些特殊的功能. 过滤器的作用 一般用于完成通用的操作. 登录验证(类似淘宝要加入购物车必须先登录这样子). 统一编码处理,我们当提交表单的方式为post的时候,我们都要设置request的编码防止乱码. 敏感字符过滤. ……. filter快速入门 步骤 定义一个类,实现接口Filter,和servlet类似的. 复写接口中的方法. 配置拦截路径(即访问什么样的资源过滤器会生效),servlet配置的是访问路径. 第一种配置方式: web.xml. 第二种配置方式: 注解(常用),和servlet一样,写在urlPattern后面,且urlPattern几个字可以省略,一般后面写/*,表示访问所有资源之前都要先执行过滤器,写/demo.jsp则表示只有访问demo.jsp的时候才会执行过滤器. 放行,即让访问的资源中的内容显示出来 chain.doFilter(req, resp);, 其中的chain, req, resp这都是doFilter中的参数. 过滤器快速入门代码. 过滤器快速入门index.jsp页面. 这里有一个点要注意一下,就是如果你配置过滤器为/*的时候,就表示访问所有资源都要先执行过滤器,此时运行服务器,通过上面的代码,访问index.jsp,会发现index.jsp中的内容不会被显示出来,这个就可以理解为这样子: 假设我要回家.路上有土匪,这个土匪就相当于那个过滤器,我能不能过去,就要看土匪能不能放我过去,这就相当于上面的我访问index.jsp前执行了过滤器,我能不能显示index.jsp的内容,要看过滤器让不让我看这样子. 过滤器的细节 web.xml配置(反正我一般不用hhh,知道就行) &lt;filter&gt; &lt;filter-name&gt;demo1&lt;/filter-name&gt; &lt;filter-class&gt;这里填的是src下(不包括src)到资源文件的路径(就是包名.包名...类名)如`filters.IntroductionOfFilter`&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;demo1&lt;/filter-name&gt; &lt;url-pattern&gt;/*(注意这个是拦截路径,不是访问路径)&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 过滤器执行流程 大体来说就是,先通过对应的url访问资源,然后途中经过过滤器,过滤器经过处理后放行,放行后执行url对应资源的内容,结束之后又回到过滤器中,执行放行语句后面的操作. 放行语句前,会收到浏览器传来的请求,如果有操作request的语句,它会先执行操作request的语句. 执行放行语句,回到资源文件中执行相应操作. 资源文件执行结束后,回到过滤器中,执行放行语句下面的操作,即对相应消息的操作. 过滤器生命周期方法(三个) 服务器启动时创建Filter对象,然后由该对象执行init()方法去加载资源,而且只执行一次 —&gt; 每一次浏览器访问服务器经过过滤器时,由Filter对象去执行doFilter()方法,可以执行多次 —&gt;服务器停止时,Filter对象被销毁,如果服务器正常关闭(就是点红色的点,不是直接关闭之前说的tomcat窗口,反正我们在集成开发环境中点击关闭都是正常关闭的),此时执行destroy()去释放资源,只执行一次. 过滤器配置详解 拦截路径配置(有4种) 拦截具体的资源路径: /index.jsp, 表示只有访问index.jsp资源时,过滤器才会被执行. 注意,这里是不存在一个项目中有两个同名的index.jsp的,不管你在什么地方,都会报错的. 拦截具体目录: /user/*, 表示访问/user下的所有资源时,过滤器都会被执行 这里的/user/*不一定非得是一定存在user这个目录,也就是说/user/servlet并不一定表示servlet就放在真正存在的user包下,它只是表示所有前面有/user的url都会被user这个东西限制,也就是会经过过滤器. 如果真的是有这个目录,那么就要把东西放在目录下,同时在idea中要注意这里拦截的是具体目录不是模块包哈,目录和模块包有区别的,目录是自己新建的,模块包是idea生成的,如src,web模块包等,同时这样设置以后,访问的url也要变了,要加上目录了就要. 后缀名拦截的方式: *.jsp, 表示访问所有后缀名为.jsp资源时,过滤器都会被执行,注意前面没有斜杠. 拦截所有资源: /*, 表示访问所有资源时,过滤器都会被执行. 拦截路径设置代码. 拦截方式配置(两种方式): 指的是资源被访问的方式, 也就是说,比如我设置了浏览器直接访问资源的过滤器,当我从服务器内部转发的时候,就不会被拦截,但是重定向这种两次请求的就也会被拦截. 注解配置: 在注解filter注解中设置dispatcherTypes属性(有5种取值) REQUEST: 默认值.表示浏览器直接请求资源url,即直接在地址栏输入url路径访问. FORWEAD: 服务器内部转发访问资源. INCLUDE: 包含访问资源(了解) ERROR: 错误跳转资源(了解) ASYNC: 异步访问资源(了解) 当我既要在直接访问时能被过滤器加强,还要在内部转发时也被过滤器加强怎么办呢? 其实很简单,我们通过看webfilter的源码知道,它的dispatcherTypes属性是一个数组,所以我们直接这样写: dispatcherTypes = {DispatcherType.FORWARD,DispatcherType.REQUEST}. 当这样写的时候: urlPatterns = &quot;/*&quot;, dispatcherTypes = {DispatcherType.FORWARD,DispatcherType.REQUEST}, 表示转发和直接请求访问所有类型资源都会被过滤器加强,但是这样子的话,假如是以请求转发的方式访问index.jsp,过滤器就会被执行两次. web.xml配置: 配置资源路径的时候多设置这样一个标签即可,也有上述五个取值,一样的. 注解配置拦截方式代码. 过滤器链(配置多个过滤器) 执行顺序: 如果有两个过滤器(过滤器1,过滤器2) 过滤器1先执行 过滤器2再执行 资源执行 过滤器2回来执行 过滤器1回来执行 这个怎么测试呢?其实很简单,你就直接写两个过滤器,采用注解配置,其中过滤的url写成/*,然后随便访问一个路径,比如index.jsp的路径,然后你就会发现它两个都执行了(在注解配置中只要两个的filterName不一样,就会都执行,两个名字一样就只会执行前一个). 12345678910111213141516171819 @WebFilter(filterName = &quot;FilterDemo4&quot;, urlPatterns = &quot;/*&quot;) public class FilterDemo4 implements Filter &#123; public void destroy() &#123; &#125; public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException &#123; System.out.println(&quot;FilterDemo4执行了&quot;); chain.doFilter(req, resp); System.out.println(&quot;FilterDemo4回来了&quot;); &#125; public void init(FilterConfig config) throws ServletException &#123; &#125;&#125; 过滤器的先后顺序问题(两种): 注解配置的过滤器: 根据类名,按照字符串比较规则去比较,值小的先执行. 例如: AFilter和BFilter,它会先第一个字符比较,然后第二个字符比较…一次类推,在这里,第一个字符A&lt;B,就比较出来了,所以先执行AFilter. 又比如: Filter6和Filter17,它依次比较,比较到6 &gt; 1,所以Filter17会先执行. web.xml配置: 谁定义在上面谁先执行,就是谁写在前面就先执行谁,知道就好了. Filter案例 案例1_登录验证 需求 访问之前的用户增删查改的案例的资源。验证其是否登录,即权限控制. 如果登录了，则直接放行。 如果没有登录，则跳转到登录页面，提示”您尚未登录，请先登录”. 案例2_敏感词汇过滤 需求 对用户增删查改案例录入的数据进行敏感词汇过滤 敏感词汇比如坏蛋`菜鸟`等. 如果是敏感词汇，替换为 ***. 分析: 对request对象进行增强,增强获取参数的方法,获取敏感词汇变成以后要将再放回到request中,而request没有addParameter方法. 增强后,放行,传递代理对象. 增强对象的功能: 设计模式: 一些通用的解决固定问题的方式. 装饰模式. 代理模式(我们用这个). 概念: 可以理解为代理商,代购 真实对象: 即被代理的对象,比如说我们要买国外的东西,找了代购,国外的东西就是真实对象. 代理对象: 即代理的对象,比如说我们要买东西的找的代购,就是代理对象,但是代理对象还是要去国外买真实对象,然后赚取差价. 代理模式: 代理对象代理真实对象,达到增强真实对象的目的. 可以这么理解,代理商并没有卖电脑的功能,它只是增强总部卖电脑的动能,它要卖电脑,它就要去总部,也就是真实对象那里获取它卖电脑的功能. 实现方式 静态代理: 代理对象的生成方式—&gt;有一个java的类文件描述代理模式. 动态代理: 代理对象的生成方式—&gt;在内存中动态形式代理类,我们这里用动态代理. 实现步骤: 代理对象和真实对象实现相同的接口. 在使用代理对象的方法中,通过语句:代理对象=Proxy.newProxyInstance()创建代理对象. 使用代理对象去调用对应方法. 增强方法. 增强方式: 增强参数列表. 增强返回值类型. 增强方法体执行逻辑 动态代理案例代码. 实现上述功能后完整代码. Listener Listener: 监听器,web的三大组件之一,不过用的比较少,我就没怎么管嘿嘿嘿. 事件监听机制 事件: 一件事情. 事件源: 时间发生的地方. 监听器: 一段代码或一个对象. 注册监听: 将事件,事件源,监听器绑定在一起,当事件源发生时间后,执行监听器代码. servletContextListener(接口,自己写实现类作为监听器对象): 表示监听servletContext对象的创建和销毁. void contextInitialized(ServletContextEvent sce): servletContext对象创建后会调用该方法. void contextDestroyed(ServletContextEvent sce): servletContext对象销毁前会调用此方法. 步骤: 定义一个类实现servletContextListener接口. 重写方法. 配置 web.xml配置. xml配置只需要配置一个就可以了,注意这里的路径是全路径,就是src下从包名开始.包名.类名. 注解配置. 直接写一个@WebListener就完事了. 案例代码.]]></content>
      <categories>
        <category>javaee</category>
      </categories>
      <tags>
        <tag>Filter和Listener</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试题之java基础知识]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F05%2F20%2F%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8Bjava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[Java基础知识面向对象的特征表现在哪些方面?* 封装: 最常见的就是把属性私有化封装在一个类里面,提供公共的方法去访问. * 继承: 子类继承父类,从而继承父类的方法和属性. * 但是有一点要注意: 那就是子类不能继承并使用父类的私有属性和方法,但是如果子类中公有的方法用到了父类的私有属性,那么子类调用该方法是不会报错的. * 抽象: 比如一个抽象类,抽象出一个共同的属性,放在一个类中,使得开发过程更易理解. * 多态: 多态包括操作符的多态和类的多态. * 类的多态的三个必要条件: * 父类引用指向子类对象. * 有继承. * 有重写. * 操作符多态: * `1 + 2`的值就是`3`,这就是简单的算术运算. * `&quot;1&quot; + 2`的值却是`12`,这是字符串相加. java的基本类型有哪些?java有8中基本数据类型: byte,short,int,long,float,double,char,boolean byte,short,int,long 属于整数类型 float, double 属于浮点数类型 char 为字符型 boolean 为布尔类型 String是基本数据类型吗?* 不是!!!String是类类型,它是一个类 * 基本数据类型有八种 * 整型(4种): byte(1个字节,占8位), short(2个字节), int(4个字节) ,long(8个字节). * 字符型(1种): char(2个字节). * 浮点型(2种): float(41个字节), double(8个字节). * 布尔型(1种): boolean. * 转换顺序: byte,short,char ---&gt; int 一个java源文件中是否可以有多个类(不是内部类)?有什么限制?可以有多个类 但是只能有一个public的类,而且public的类必须和文件名一致 java中有没有goto?goto是保留字,现在没有在java中使用 &amp;和&amp;&amp;的区别二者都可以作为逻辑与运算 只要有false,表达式的结果就为false,只有两边的结果都为true的时候才为true 但是二者也有区别:以如下代码为例 int a = 3, b = 3; int c = 3, d = 3; boolean flag1 = (++a == 3 &amp;&amp; ++b == 4);//值为false System.out.println(a + &quot;--&quot; + b);//输出4--3 boolean flag2 = (++c == 3 &amp; ++d == 4);//值为false System.out.println(c + &quot;--&quot; + d);//输出4--4 &amp;符号做运算时,不管前一个表达式的正确与否,第二个表达式都会被运算,所以上面d的返回值为4而不是3 &amp;&amp;做运算时，它具有短路功能，即当前面一个表达式为false后,第二个表达式就不会被运算了,所以b的返回值是3而不是4 switch语句的参数可以为哪些类型?switch参数在jdk7以前(不包括jdk7)只能用int类型和枚举类型,在jdk7及以后可以用string作为参数. 而byte,short,char可以自动转换为int类型,所以也可以作为switch的参数 ArrayList和LinkedList的异同:* arraylist和linkedlist都不保证线程安全. * arraylist底层使用的是object数组,linkedlist底层使用的是双向链表结构. * 插入和删除是否受到元素位置影响? * arraylist采用数组存储,所以插入和删除元素受元素位置影响,数组默认添加元素到末尾(时间复杂度为O(1)),向长度为n的arraylist中插入和删除的位置为i时,其时间复杂度为(O(n-i));而linkedlist采用链表存储,所以插入删除元素都不受元素位置影响. * 是否支持快速随机访问? * linkedlist不支持快速随机访问,而araylist支持,其中快速随机访问指的是根据下标快速获取元素对象(通过get(int inde))方法. * 内存空间占用. * arraylist的空间浪费主要体现在需要随时在末尾预留一些空间,而linkedlist的空间浪费主要体现在它的每个元素都需要消耗比arraylist更多的空间,因为要拿一些空间出来存前后节点. * 补充一点: **RandomAccess接口** public interface RandomAccess{ } * 这个接口什么都没有实现,所以我觉得RandomAccess接口就只是一个标识,标识着实现这个接口的类具有随机访问功能,所以我们可以猜到,arraylist实现了这个接口但是linkedlist没有实现这个接口,因为数组可以随机访问但是链表不可以,不过这里要区分开RandomAccess接口只是标识了这个功能,不是因为实现了这个接口才有这个功能! * 总结一个list的遍历方式: * 实现了RandomAccess接口的list: 优先选择普通for,然后foreach. * 没有实现RandomAccess接口的list: 优先选择iterator遍历(foreach其实也是迭代器),当size比较大的时候,千万不要用普通for,巨慢. ArrayList和Vector的区别:* Vector的所有方法都是同步的,也就是线程安全的,多线程的时候可以保证安全,但是单线程很慢,而且现在这个也不用了!!!! * arraylist不是同步的,在不需要保证线程安全的时候建议使用. HashMap和HashTable的区别* 线程是否安全: hashmap线程不安全,hashtable线程安全,因为其中的方法基本都被synchronized修饰(如果要保证线程安全的话就用concurrenthashmap). * 效率: 由于hashtable是线程安全的,所以效率肯定比hashmap要低一些,然后的话,hashtable他们说基本不怎么用了. * 对空键,空值的支持: hashtable的键值不可以为null,而hashmap都可以为null,但是hashmap和hashtable的键都唯一!!! hashset和hashmap的区别* hashset底层就是基于hashmap实现的. * hashset实现了set接口,而hashmap实现的是map接口. * hashset存储的是对象,hashmap存储的是键值对. * hashset使用add()方法添加元素,而hashmap使用put()方法添加元素. * hashset元素不重复,hashmap中键不重复. * hashset的速度比hashmap慢,因为hashmap是唯一的键获取对象]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试题之java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSP,EL和JST]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F05%2F17%2FJSP-EL%E5%92%8CJST%2F</url>
    <content type="text"><![CDATA[JSPJSP基础语法jsp中既可以写java代码,也可以写html等静态代码,其本质就是一个servlet 指令 作用: 用于配置jsp页面, 以及导入一些资源文件. 格式: &lt;%@ 指令名称 属性名1=属性值1 属性名1=属性值1 …%&gt; 分类: page: 配置jsp页面. contentType: 等同于response.setContentType()这个方法. 可以用于设置响应体的mime类型和字符集. 设置当前jsp页面的编码(只能是高级的ide才能生效,如果使用记事本这样的低级开发工具,那就需要使用pageEncoding()来设置). import: 用来导java包,和java中导包一样. errorPage: 当前页面发生异常后,会自动跳转到指定的错误页面, 例如: &lt;%@page errorPage=&quot;index.jsp&quot; %&gt;,注意这个errorPage不能是当前页面,必须是其它的jsp页面. isErrorPage: 标示当前页面是否是错误页面,默认为false,但是,标示当前页面的isErrorPage为true之后,就可以使用内置对象exception了. isErrorPage示例代码 include: 页面包含的,导入页面的资源文件,比如我这个页面值写头部,其它页面要这个头部的时候直接包含进去就可以了. &lt;%@include file=”top.jsp”%&gt; taglib: 导入资源,一般用于导入标签库,相当于导包. &lt;%@taglib prefix=”a” uri=”http://java.sun.com/jsp/jstl/core&quot;%&gt; prefix: 前缀,自定义的名字这个标签的名字. uri: 标签库的url. 注释 html注释: : 只能注释html代码片段,注释的东西你再浏览器中查看源码还是可以看到. jsp特有的注释 &lt;%– –%&gt;: 可以注释所有(推荐使用,注释的东西就不会发送到浏览器,相当于删除了) 内置对象 在jsp页面中不需要创建可以直接使用的对象,一共有9个. pageContext(jsp中的域对象),真实类型为PageContext,其作用范围为: 当前页面,可以在当前页面共享数据,还可以获取其它八个内置对象(通过get方法). 12345&lt;% request.setAttribute(&quot;msg&quot;, &quot;hello&quot;);%&gt;&lt;%= request.getAttribute(&quot;msg&quot;)%&gt; request(jsp中的域对象),真实类型为HttpServletRequest,,其作用范围为: 一次请求访问的多个资源(通过转发实现). session(jsp中的域对象),真实类型为HttpSession,其作用范围为: 一次会话的多个请求间. application(jsp中的域对象),真实类型为ServletContext,其作用范围为: 所有用户间共享数据,服务器开启被创建,服务器关闭被销毁. response,真实类型为HttpServletResponse,其作用为: 作为一个响应对象. page,代表当前对象,等于this,真实类型为Object,其作用为: 表示当前页面(servlet)的对象 this. out,真实类型为JspWriter,其作用为: 输出对象,将数据输出到页面上. config,真实类型为ServletConfig,其作用为: 作为servlet的配置对象. exception(要声明该页面为isErrorPage=true才能使用),真实类型为Throwable,,其作用为: 作为一个异常对象. MVC开发模式(知道什么代码往哪儿写,很重要) jsp的演变历史 早期只有servlet,没有jsp,只能使用response输出标签数据,非常麻烦. 后来就有了jsp,简化了servlet的开发,但是如果过度使用jsp,在jsp中既写大量代码,又写一堆html标签,后期很难维护,别人也看不懂. 再后来,Java的web开发就借鉴了mvc的开发模式,使得程序的设计更加合理. MVC详解 M: Model, 模型.JavaBean 完成具体的业务操作,如: 查询数据库(对数据库的操作都放在Dao包下),封装对象. V: View, 视图. JSP 仅展示数据,就不写java代码了尽量. C: Controller, 控制器. Servlet 获取用户输入. 调用模型. 将数据(包括用户输入的和模型返回的)交给视图进行展示. 优点 耦合性低,所以方便维护,有利于分工协作. 重用性高. 缺点: 使项目架构变得复杂,对程序猿的要求更高,要有一个很完整的构思. 如图: . EL表达式(简化JSP中java开发代码) 概念: Expression Language 表达式语言. 作用: 替换和简化jsp页面中java代码的编写,注意它只能获取域中的数据,所以所有要使用el表达式的都需要先存到域对象中. 语法: ${表达式}. 注意: jsp默认支持EL表达式. 如果要忽略EL表达式,即将EL表达式当作普通字符串输出,有两种方法: 设置jsp中的page指令中的isELIgnored属性为true,即 &lt;%@page isELIgnored=&quot;true&quot; %&gt;,表示忽略当前jsp页面中所有的EL表达式,这样整个页面的EL表达式都会被当作字符串处理. 在EL表示式前加一个反斜杠\就可以了,例如 \${3 &gt; 4},表示忽略当前这个EL表达式. 作用: 运算 运算符 算术运算法: + - * /(div) %(mod),注意除法后默认是double类型. 比较运算符: &gt; &lt; &gt;= &lt;= ==. 逻辑运算符: &amp;&amp;(and) ||(or) !(not). 空运算符: empty,用于判断字符串,集合,数组对象是否为null并且长度是否为0. 例如: ${empty list},判断list对应的字符串,集合,数组对象是否为空或者长度为0,满足一个就返回true. ${not empty list},判断字符串,集合,数组对象是否不为null并且长度&gt;0,满足则返回true. 案例代码: 运算符示例代码. 获取值(通过属性获取值,越界时候输出都是空字符串,不会报错) 注意这里的属性就是get和set方法去掉get和set,剩下的部分再将首字母小写,即getAge()–&gt;age属性. EL表达式只能从域对象中获取值. 语法: ${域名称.键名称}: 从指定域中获取指定键的值. 域(4个): pageScope —&gt; pageContext. requestScope —&gt; rquest. sessionScope —&gt; session. applicationScope —&gt; application(即java中的servletContext). 举例: 在request中存储了name=饭饭,通过${requestScope.name}就可以得到张三. ${键名}: 表示依次从最小的域pageContext开始查找是否有该键对应的值,知道找到为止. 获取对象, List集合, Map集合的值 获取对象: ${域名称.键名.属性名}. 本质上是用对象去调用对应的get方法. List集合: ${域名称.键名称[索引]}. 比如说当索引为0,表示获取该集合中的第一个元素. 没有索引就输就所有值. 下标越界就输出空字符串,不会报错. Map集合: ${域名.键名.key名}或者${域名.键名[key名]}. 获取对象中的数据案例代码. 隐式对象: 可以直接拿来用,类似于jsp的内置对象,el表达式中有11个隐式对象. 这里注意一下pageContext就可以了: 可以获取jsp其它八个内置对象. 可以动态获取虚拟目录: ${pageContext.request.contextPath},可以用在jsp页面的form表单中,例如: action=”${pageContext.request.contextPath}/loginServlet”. JSTL标签(简化JSP中java开发代码) 概念: Java Server Pages Tag Library 即JSP标准标签库 是由Apache阿帕奇组织提供的开源的免费的jsp标签库 &lt;标签&gt;. 用于简化和替换jsp页面上的java代码. 使用步骤: 导入jstl相关的jar包. 引入标签库: taglib指令 &lt;%@ taglib %&gt; 使用标签. 这里在运行的时候我遇到了一个错The absolute uri: [http://java.sun.com/jsp/jstl/core] cannot be resolved in either web.xml or the jar files deployed with this application,这个错就是项目在部署的时候jstl的jar包在tomcat下的WEB-INF的lib中没得,将jar包复制到目录下就行了 常用的jstl标签 if,相当于java中的if,但是没有else. 属性 test, 必须属性,接收boolean表达式, 如果表达式为true,则显示if标签体内容 如果表达式为false,则不显示if标签体内容 如果表达式什么都不是也不会显示if标签体内容 一般情况下,test属性值会结合el表达式的empty运算符,比较运算符,逻辑运算符等一起使用. 注意: c:if标签没有else情况,想要else情况,就要重写一遍c:if标签. choose,相当于java中的switch. choose标签写一个星期几小案例 在域中存储一个数字. 使用choose标签取出数字 相当于switch的声明. 使用when标签做数字的判断,相当于case, &lt;c:when test=&quot;${number == 1}&quot;&gt;. otherwise标签做其它情况的声明,相当于default, &lt;c:otherwise&gt;. foreach,相当于java中的for循环. 属性: items: 容器对象 var: 容器中的临时变量 varStatus: 循环状态对象 index: 容器中元素的索引,从0开始 count: 循环次数,从1开始 jstl入门案例代码. 练习: 需求: 在request域中有一个存有user对象的list集合,需要使用jstl+el将list集合数据展示到jsp页面的表格中. 练习代码.三层架构(针对服务器而言): 软件设计架构 界面层(表示层): 即用户看到的界面,用户可以通过界面上的组件和服务器进行交互例如将数据封装提交. 业务逻辑层: 处理业务逻辑的. 数据访问层: 操作数据存储文件,如数据库,txt文件等. 针对web服务器而言,上述三层架构又叫web层, service层, dao(data access object)层. 其关系如图: . 案例: 用户信息列表展示1. 需求: 用户信息的查询操作 综合案例练习1. 简单功能 1. 列表查询(就是上面的,我是直接复制过来的). 2. 登录. 3. 列表添加. 4. 列表删除. 5. 列表修改. 2. 复杂功能 1. 删除选中的多条信息. 2. 数据分页查询. 3. 复杂条件查询. 3. [案例完整代码](https://github.com/fanfan999/WebCodes/tree/master/user_crud_complete).]]></content>
      <categories>
        <category>javaee</category>
      </categories>
      <tags>
        <tag>JSP,EL和JST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[桶排序]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F05%2F15%2F%E6%A1%B6%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[桶排序,计数排序,基数排序都不是基于比较的排序,也就是说他们与样本的实际数据情况有很大关系,实际中不经常使用,其时间复杂度都为O(N),额外空间复杂度都为O(N),而且都是稳定的排序 桶排序 桶排序就是一个概念,不是具体的一种排序方法,其中的基数排序和计数排序才是桶排序的具体实现. 举例: 现在有一个数组arr,里面存放着从0-60的共计61个元素,我们可以拿一个同样长度为61的新数组countArr,用来记录arr数组中每个数字出现的次数,最后遍历数组countArr就可以知道每个数出现了几次,就从0开始输出几次就好了,比如说1出现了3次,就输出111就可以了.计数排序 计数排序就是有多少个数对应放多少个桶,然后统计对应数出现的个数,最后遍历输出,不过这个很不实用,要是数据量太大了,就贼慢,所以一般桶的数量不会很多,就是这么个意思,理解理解就好了.基数排序(后面再说) 补充问题1. 案例(很重要): 给定一个无序数组,求如果排序之后,相邻两数的最大差值,要求时间复杂度为**O(N)**,且要求**不能用非基于比较**的排序. * 举例: 数组array: [3,1,6,2,7] 排序后: [1,2,3,6,7] 返回最大差值: 3 则本题解为 : 3 * 解法: 借用桶概念,但是没用桶排序 ![案例图解思路](https://github.com/fanfan999/MyPostImage/raw/master/%E6%A1%B6%E6%8E%92%E5%BA%8F/%E6%A1%88%E4%BE%8B%E8%A7%A3%E9%A2%98%E5%9B%BE%E8%A7%A3.jpg). * 代码: **[案例代码](https://github.com/fanfan999/AlgorithmsCodes/blob/master/SortingCodes/Max_Gap.java).** 2. 在这里要注意一个问题: int i = 0; int j = 0; i = i++; 此时的i是为0的. i = i + 1; j = ++j; 此时i和j都是等于1的,一定要想清楚啊!!! 3. 用数组实现固定大小的栈,越界就报错: 实现添加功能`push`,取出栈顶元素但是不删除功能`peek`,取出栈顶元素并删除`pop`这三个功能 * **[数组实现固定大小的栈代码](https://github.com/fanfan999/AlgorithmsCodes/blob/master/SortingCodes/MakeArrayAsStack.java).** 4. 用数组实现固定大小的队列,越界就报错: 实现添加功能`push`,取出队列首元素但是不删除功能`peek`,取出队列首元素并删除`poll`这三个功能 * **[数组实现固定大小的队列代码](https://github.com/fanfan999/AlgorithmsCodes/blob/master/SortingCodes/MakeArrayAsQueue.java).**]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>桶排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cookie和Session]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F05%2F15%2FCookie%E5%92%8CSession%2F</url>
    <content type="text"><![CDATA[会话这些会话里的东西都是针对http协议而言的,而且,对于一个类,如果想被外界访问到,那这个类必须是servlet,因为只有servlet能被外界访问 会话: 一次会话中包括多次请求和响应,比如说两个人之间交谈,肯定不只有一句话,然后以其中一个人不说话了离开了为结束. 什么是一次会话呢: 浏览器第一次给服务器资源发送请求,会话建立,直到有一方断开请求连接为止. 会话的功能: 在一次会话的范围内的多次请求之间来实现共享数据. java中共享数据的两种方式: 客户端会话技术: cookie 服务器端会话技术: sessionCookie 概念: 它是客户端会话技术,它将数据保存在客户端. cookie快速入门 使用步骤: 服务器端创建cookie对象,其中cookie是一个类,绑定数据. 通过javax.servlet.http包下的Cookie实体类中的构造方法: public Cookie(String name, String value). 服务器端发送cookie对象. 通过javax.servlet.http包下的HttpServletResponse接口中的方法: void addCookie(Cookie cookie). 服务器端获取cookie,拿到数据. 通过javax.servlet.http包下的HttpServletRequest接口中的方法: Cookie[] getCookies(). cookie发送数据代码. cookie接收数据代码. 注意,当这个servlet在同一个浏览器运行时,response能够正常获取数据,但是如果不在同一个浏览器运行,就不会获取到数据. cookie实现原理 基于响应头set-cookie和请求头cookie来实现,这个可以在浏览器运行servlet的时候通过F12查看网络中响应头和请求头的变化知道. 如图: . 我们要知道不论是发送cookie还是接收,都是以http协议的响应和请求形式来实现交互的. 一个小技巧: 每次我们在idea中创建servlet时每次都要自己去写urlPattern还要在get方法里面调用post方法,这个就有点麻烦,这个过程是可以省略的,我们可以在idea中设置servlet的模板来解决这个问题. 如图: . idea中out目录中存放的是部署到tomcat中的文件,javase项目存放的就是编译后的文件,反正就是所有编译后的东西都在里面. cookie的细节内容 一次可不可以发送多个cookie? 可以 如何做到: 可以创建多个cookie对象,使用response调用多次addCookie()方法即可. 如果,多个servlet发送的cookie的键是相同的,虽然发送会都发送,但是接收的时候只会接收最后一个发送的, 假如两个甚至多个servlet中如果键都是”msg”,最后得到的值只有最后发送的一个msg的值. 默认情况下,在浏览器没有关闭前,运行同一个src文件夹下面的某个servlet之后,然后运行其它servlet,我们都会发现前面运行过的servlet中cookie对象中的的键值对也会带过去,而且是在请求头中带过去,哪怕你重启了服务器,只要没有关闭浏览器,下次运行前面的值都还在. 在浏览器中,每个cookie对象只会有一个备份,怎么理解呢,就是说你不管调用多少次某个servlet,在请求头中都只会有一个该servlet中的键值对信息,不会因为你刷新了多次就有多个,这也就侧面验证了假如多个servlet有相同键的cookie,只会保留最后一个的结论. cookie在浏览器中保存多长时间呢? 默认情况下: 当浏览器关闭后,cookie数据被销毁,说明cookie是存在于浏览器的内存中,也就是说重新打开浏览器就需要重新请求重新响应cookie数据. 设置cookie的生命周期让cookie实现持久化存储 使用cookie对象中的方法setMaxAge(int seconds)其中参数有三种取值: 当参数为正数时: 表示将cookie数据写到硬盘数据中,也就是实现了持久化存储,其中这个参数的大小就表示了cookies对象的存活时间,例如参数为30,表示30秒以后cookie文件就会被自动删除,在30秒内关闭浏览器重新打开再次获取该cookie对象依旧存在. 当参数为负数时: 表示使用默认值. 当参数为0时: 表示删除cookie信息. cookie持久化存储示例案例. 能不能存中文呢? 在tomcat8之前,cookie中不能直接存储中文数据,在tomcat8之后,cookie支持中文数据存储,但是还是不支持特殊字符. 在cookie中不要使用符号,会报错的. 那么,如果要在tomcat7及之前存储中文数据或者现在在cookie中带特殊符号,如空格,逗号等,就需要将它们进行转码—一般采用URL编码. 怎么实现URL编码呢?下面的记住上一次访问时间案例中有,通过URLEncoder类中的静态方法encode(String s, String enc). cookie存储中文示例代码. cookie获取的范围是多大呢,即共享问题. 假设在一个tomcat服务器中部署了多个web项目,那么在这些web项目中的cookie能不能共享? 默认情况下是cookie是不能共享的 但是可以通过方法: setPath(String path)来设置cookie获取的范围,默认该方法的参数设置为当前的虚拟目录. 即不调用该方法等同于cookie.setPath(&quot;/虚拟目录&quot;),表示只有在该虚拟目录下的资源,才能获取该cookie下的信息. 当我们将方法写成这样的时候: cookie.setPath(&quot;/&quot;),这表示在服务器根目录下的所有文件都可以访问该cookie下的信息,其中/表示服务器根路径,即localhost/,后面跟什么都行,例如localhost:8080/cookie/cookieServlet1和localhost:8080/cookie1/cookieServlet1都可以访问上面的cookie对象中的信息. 不同的tomcat服务器间cookie共享问题(有印象就行) 通过cookie的方法: setDomain(String path), 如果设置其一级域名相同(如news.baidu.com和tieba.baidu.com中的.baidu.com为他们的一级域名,所以他们的cookie数据可以共享),那么多个服务器之间cookie信息就可以共享了. cookie的特点和作用 特点 cookie存储数据在客户端浏览器,没有存储在服务器那么安全. 浏览器对于单个cookie的大小由限制(4KB左右,据浏览器而定),以及对同一个域名下的总cookie数量也有限制. 作用 cookie一般用于存储少量的不太敏感,不太重要的数据. 在不登录的情况下(登录之后我们的信息都是存储在数据库中)完成服务器对客户端的身份识别,例如我们对百度这个网页设置了不在首页显示天气,当我关闭浏览器下次再打开百度页面的时候,是不会显示天气的,这就是因为我们在设置了不显示天气以后,百度服务器就把这个设置用cookie对象响应给了浏览器并保存到硬盘中,下次我们再打开的时候,就是带着cookie数据打开的,此时该页面会自动读取我所带着的cookie中的数据并进行相应的设置. cookie案例(记住上一次访问时间) 需求: 访问一个servlet,如果是第一次访问,则提示: 您好,欢迎您首次访问. 如果不是第一次访问,则提示: 欢迎回来,您上次的访问时间为: xxxxxxxxx. 分析: 可以采用cookie来完成. 在服务器中的servlet判断是否有一个名为time的cookie 有,说明不是第一次访问 提示: 欢迎回来,您上次的访问时间为: 2019/05/15 16:30:55. 写回cookie: time=2019/05/15 16:31:00. 没有,说明是第一次访问 没有就去响应数据: 您好,欢迎您首次访问. 写回cookie:time=2019/05/15 16:30:55. 记住上一次访问时间代码实现. 一点小问题 我由于自己不小心在设置response编码格式的时候,把response.setContentType(&quot;text/html;charset=Unicode&quot;);写成了response.setContentType(&quot;content-type:text/html;charset=Unicode&quot;);,这样会导致什么问题呢?会导致直接把你要输出的内容下载下来,切记切记!. JSP入门 概念: Java Server Pages 即java服务器端页面,可以理解为一个特殊的页面,其中既可以直接定义html标签,又可以定义java代码. 用于简化书写!!!!! 原理 jsp本质上就是一个servlet,浏览器通过页面访问服务器的时候,服务器会将jsp转换为java文件,然后编译成.class字节码文件,最后通过字节码文件做出响应. jsp脚本:jsp定义java代码的方式 &lt;% java代码 %&gt;: 定义的java代码放在jsp文件转换为java文件后中的service方法中.该脚本中可以写所有在servlet的service方法中语句. &lt;%! java代码%&gt;: 定义的java代码,在jsp转换为java类后的成员位置,可以是成员变量,也可以是成员方法,这种用的不多. &lt;%= java代码%&gt;: 这就相当于一个输出语句,输出语句中可以定义什么,该脚本中就可以定义什么,如果成员位置和局部位置都有同一个变量,会输出成员变量的值. jsp内置对象: 指在jsp页面中不需要获取和创建就可以直接使用的对象,比如request对象,一共有9个内置对象,包括request,response,out(字符输出流对象,将数据输出到页面上和response.getWriter()类似)等,具体的后面再写. response.getWriter()和out.write()的区别: out对象定义在哪个位置就在哪个位置输出,而response.getWriter()对象不论定义在哪里,都会先于out对象输出,因为tomcat在给客户端做出响应前,会先找response缓冲区数据,再找out缓冲区数据. 我们用的时候尽量都要其中一个就可以了. jsp改造记住上一次访问时间代码. Session(接口) 概念: 服务器会话技术,在一次会话(表示session的范围)的多次请求间共享数据,将数据保存在服务器端的对象中—HttpSession,session也是域对象. 什么是一次会话呢,就比如我现在有两个servlet,通过session共享数据,当我把浏览器关闭后,这次会话就结束了,再打开浏览器就是一个新的会话,如果此时访问获取数据的servlet就会报错,就说明session的作用范围是一次会话. 快速入门 获取session对象: HttpSession session = request.getSession(). 使用session对象: 即HttpSession对象 Object getAttribute(String name). void setAttribute(String name,Object value). void removeAttribute(String name). 域对象都有这几个方法.. session快速入门发送数据代码. session快速入门接收数据代码. 原理: session的实现是依赖于cookie的 当我们第一次请求,服务器创建了session对象后,只有本次会话没有结束,后面一直都不会再创建新的session对象了,也就是说,你没有关闭浏览器之前,虽然多次运行发送请求的servlet网址,响应头也不会再有带session的id的键值对了. 原理图: . session的细节 当客户端关闭,服务器不关闭后,两次获取的session是否是同一个? 默认情况下,不是同一个. 那么我希望客户端关闭重新打开后后,session也能相同,而且可以直接获取session的数据,应该怎么做呢? 在获取session的servlet中创建一个cookie,键为JSESSIONID,值为session的id值,通过response的响应头set-cookie将其发送给浏览器,同时让cookie实现持久化存储.Cookie cookie = new Cookie(“JSESSIONID”, session.getId());cookie.setMaxAge(60*60);response.addCookie(cookie); 客户端不关闭,服务器关闭后,两次获取的session是同一个吗? 服务器关闭了,session对象就被销毁了,因为内存被释放了,所以说不是同一个. 因为对象不是同一个,所以说,原来的session对象中的数据我们是访问不到的,这就产生了数据丢失,这肯定是不希望看到的,所以这里需要提到两个点. session的钝化: 即在服务器正常关闭之前,将session对象序列化到硬盘上. session的活化: 即在服务器启动后,就session文件转化为内存中的session对象. 上面的两个功能tomcat已经为我们实现了,找到上述项目编译后的保存位置,放在tomcat保存目录下的webapps目录下,然后通过tomcat的lib目录启动tomcat,可以正常访问servlet,然后通过tomcat的lib目录正常关闭tomcat,我们会发现在tomcat的work目录会多一个session.ser的文件,里面就保存着session的id,重新正常启动tomcat之后,那个文件就会自动被删除,我们再次读取session的值的时候,它会自动把session的id通过请求头传递给服务器,所以我们可以正常读取session中的值. idea可以实现钝化,但是不可以实现活化的操作,重新启动服务器它会直接删除work目录然后新建一个,所以读取不到原session的数据. session的失效时间,即session什么时候被销毁 服务器关闭,session被销毁. session对象调用invalidate()方法自己销毁自己. session默认失效时间为30分钟,可以在apache-tomcat-9.0.19\conf\web.xml中查看到. session的特点: session用于存储一次会话的多次请求的数据,存储在服务器端. session可以存储任意类型,任意大小的数据. session与cookie的区别 session存储数据在服务器端,而cookie在客户端. session没有数据大小限制,而cookie有. session数据安全,cookie相对不安全. session可以存储任意类型的数据,而cookie只能存储string类型的,通过session.setAttribute()和新建cookie对象时可以知道. 案例:验证码 需求: 访问一个带有验证码的登录页面login.jsp. 用户输入用户名,密码以及验证码. 如果用户名和密码输入有误,跳转登录页面,提示: 用户名或密码错误. 如果验证码输入有误,跳转登录页面,提示: 验证码错误. 如果全部输入正确,则跳转到主页success.jsp,显示:用户名,欢迎您! 验证码案例代码.]]></content>
      <categories>
        <category>javaee</category>
      </categories>
      <tags>
        <tag>Cookie和Session</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法的稳定性及其汇总]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F05%2F14%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%8F%8A%E5%85%B6%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[排序算法的稳定性 什么是稳定性: 稳定性不是指在不同样本量的情况下,排序算法的时间复杂度的变化,而是指的是,在排序完成后,数组中相同元素的相对顺序不变,本来在前面的还是在前面. 能做到稳定性的排序算法 冒泡排序: 能实现成稳定的. 冒泡排序代码. 选择排序: 不能实现成稳定的. 选择排序代码. 插入排序: 可以实现成稳定的. 插入排序代码. 快速排序: 不能实现成稳定的. 快速排序代码. 归并排序: 可以实现成稳定的. 归并排序代码. 堆排序: 不能实现成稳定的,例如[5,5,5,6,6]. 堆排序代码. 稳定性的意义 如图: . 在工程中排序算法的综合应用 当数组元素为基本类型例如int,char等的时候,用快排,因为快排不需要区分原始顺序,1和1不需要管哪个在前哪个在后,因为基本类型相等的数无差异. 当数组元素为自定义对象例如Student,按照对象的某个字段来排序,用归并排序,自定义对象,就算某个字段相同,但是对于对象也可能是有差异的,所以用归并排序. 当数组长度很短(&lt;60)的时候,不管什么类型,用插入排序,因为常数项很低,在样本量低的时候就跑起来很快,比如在一个很大数组的归并的过程中,当分治的数组长度小于60的时候,可以直接用插入排序给后面的数组排序. 有关排序问题的补充 有一个问题,是奇数放在数组的左边,偶数放在数组的右边而且相对顺序不变,然后让你做到额外空间复杂度为O(1),时间复杂度为O(N),这个问题,我们是实现不了的,快排一般人是实现不了稳定的,面试问到了就怼一怼面试官把,这个面试官不是个好人哈哈哈.]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序算法的稳定性及其汇总</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP响应协议和Response]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F05%2F12%2FHTTP%E5%93%8D%E5%BA%94%E5%8D%8F%E8%AE%AE%E5%92%8Cresponse%2F</url>
    <content type="text"><![CDATA[HTTP响应协议: 响应消息 请求消息: 客户端发送给服务器端的数据. 数据格式: 请求行: 请求方式 url信息 请求协议/版本号. 请求头 请求空行 请求体: 针对post请求方式的,get请求方式没有请求体. 响应消息: 服务器端发送给客户端的数据. 数据格式 响应空行 响应头 响应行 响应体: 真实传输的数据,也就是我们传输的html这些文本文件,图片,音频等,这些浏览器都会解析出来. 响应字符串的格式 123456789101112131415161718192021HTTP/1.1 200 OKBdpagetype: 1Bdqid: 0xeaa47fdd0001895fCache-Control: privateConnection: Keep-AliveContent-Encoding: gzipContent-Type: text/html;charset=utf-8Cxy_all: baidu+42cf0987fef07e22ea09fde2f722a2b8Date: Sun, 12 May 2019 00:31:06 GMTExpires: Sun, 12 May 2019 00:31:06 GMTServer: BWS/1.1Set-Cookie: delPer=0; path=/; domain=.baidu.comSet-Cookie: BDSVRTM=13; path=/Set-Cookie: BD_HOME=0; path=/Set-Cookie: H_PS_PSSID=28883_1449_28981_21108_28518_28775_28721_28964_28830_28585_22160; path=/; domain=.baidu.comStrict-Transport-Security: max-age=172800Vary: Accept-EncodingX-Ua-Compatible: IE=Edge,chrome=1Transfer-Encoding: chunked空行写响应体,即页面展示的html内容. 响应行 组成: 请求协议/版本号 http响应状态码 状态码描述,如: HTTP/1.1 200 OK. 响应状态码(都是三位数字): 服务器告诉客户端浏览器本次请求和响应的状态,其大概分类有五种. 1xx: 可以理解为客户端给服务器发送消息,服务器只接收到了一半就没有数据了,然后服务器就在那里等着,等待一段时间后,就向客户端发送1xx的状态码,问客户端你到底还有没有东西这样子, 这个出现不多. 2xx: 表示本次请求和响应成功.代表状态码:200. 3xx: 表示重定向,就是说客户端浏览器访问到了服务器,说我要干这个事,这个servlet说,我干不了,但是我知道servlet2可以干,它就给浏览器返回一个响应说我干不了,同时给浏览器了一个小纸条,让它去找servlet2. 例如: 302(重定向),和request通过forward方法请求装发类似,都是敲一次回车,访问两个地方,不过这个是客户端去访问,而不是和forward方法一样服务器内部跳转. 例如: 304缓存,这么理解吧,就是客户端向服务器请求图片这些二进制数据,只能用字节流,每次请求都要从服务器下载就会很慢,它就想了个办法,当客户端第一次请求时候,就把这张图片缓存到浏览器客户端本地,下次客户端访问同一图片(图片未更改)时,服务器就返回304状态码,让客户端去自己本地找就好了. 4xx: 客户端错误 代表状态码: 404,表示浏览器所请求的url路径在服务器中没有对应的资源,一般都是由于浏览器url写错了或者servlet中资源路径错了的原因. 405,表示请求方式没有对应的doxxx方法对应响应,例如,我们在浏览器直接输入url地址时都是通过get方法访问的,但是我们不小心在servlet中把doget()方法删除了,就会出现这个状态码. 5xx: 服务器端错误,代表服务器内部出现异常了,代表状态码500,例如,我在dopost()方法中写了一个语句int i = 5/0,这个会抛出下标不能为0异常,此时我们在浏览器通过url访问该servlet路径,就会报错500. 响应头: 格式: 头名称: 值,和请求头一样,也是键值对. 常见的响应头 Content-Type: 服务器告诉客户端本次响应体数据格式以及编码格式,然后浏览器改变接收编码格式等保证接收正常不出现乱码,例如: Content-Type: text/html(表示文本格式);charset=utf-8. Content-disposition: 服务器告诉客户端以什么格式打开我的响应体数据. 默认值: in-line,表示在当前页面内打开. attachment;filename=xxx: 以附件形式打开响应体,比如说我们点一个超链接,它不会直接跳转到另一个页面,它会直接下载一个文件. Response 功能: 设置响应消息 设置响应行. 格式: 例如: HTTP/1.1 200 OK. 设置状态码: setStatus(int sc). 设置响应头. 方法: setHeader(String name ,String value). 设置响应体. 使用步骤: 获取输出流 字符输出流: ServletOutputStream getOutputStream(). 字节输出流: PrintWriter getWriter(). 使用输出流,将数据输出到客户端浏览器中 案例(代码): 重定向: 也是资源转发的方式. 完成重定向代码. 服务器输出字符数据到浏览器代码. 服务器输出字符数据到浏览器代码. 几个注意的点: 重定向的特点 转发特点 转发后浏览器地址栏路径不变. 转发只能访问当前服务器下的资源,就是同一个src下的资源. 转发是一次请求,两次跳转,不过是只按一次回车就可以了,可以通过request对象来共享数据. 重定向特点 重定向后地址栏发生变化,request的forword()方法跳转到另一个servlet,浏览器中url路径是不会变的,是跳转前的一个servlet路径;而response的重定向,浏览器中的url路径会直接变成最终的servlet路径.. 重定向可以访问到其它地方(服务器)的资源,就是在idea中不是一个项目中的资源,但是这个项目要部署到tomcat中哈,不然不知道虚拟路径的,以idea为例 首先两个项目都要加载到服务器. 然后在servlet中调用sendRediect(string url)方法跳转到目标servlet中就可以了,但是这里注意url必须是**/虚拟路径/资源路径**.. 当然也可以重定向到其它网站中去,例如: response.sendRedirect(&quot;https://www.baidu.com&quot;);,运行后就会直接跳转到百度页面去了,而request请求转发也是不可以的. 重定向是两次请求,访问两个页面,不过也是只敲一次回车,这个可以在浏览器中通过快捷键F12,然后在网络中查看到变化,这里我就不多赘述了哈,同时这里就不能用request对象来共享数据了. 路径写法 路径的分类 相对路径(不推荐使用): 通过相对路径不可以确定唯一资源,如: ./index.html,表示当前目录下,有一个index.html页面,你可以认为它不以/开头,以.开头. 规则: 要使用相对路径,就必须先找到当前资源和目标资源之间的相对位置关系. ./xx,代表当前目录. ../xx,代表后退一级目录. 绝对路径: 通过绝对路径可以确定唯一资源,如: http://localhost:8080/response/ResponseDemo1, 其也可以简化写成/response/ResponseDemo1,我们 可以认为以/开头的路径是绝对路径. 规则: 判断定义的路径是给谁用的, 通过这个请求将来从哪儿发出,从服务器发出就是给服务器使用的,从浏览器页面发出就是给客户端浏览器用的. 给客户端浏览器使用: 需要加虚拟目录,我们建议对虚拟目录动态获取. 给服务器使用: 不需要加虚拟目录. 基本上哈,就是除了@WebServlet(urlPatterns=&quot;/xx&quot;)中的url和request的请求转发中的路径为资源路径以外,其它所有地方填的url路径都是/虚拟路径/资源路径这个格式,例如重定向的时候(这个是从浏览器发出去的要注意啊),form表单中等. 还有一个要注意的点,就是重定向的到其它项目的时候,那个url也要带虚拟路径,这个其实就理解为是从浏览器发出的数据就完事了. 例子: 相对绝对路径举例. 注意 由于虚拟目录可能随时都需要改变,所以虚拟目录不能一次写死,要动态获取,这里就需要用到request对象中的String getContextPath()方法,当然这个只能用在类方法里面哈,html里面用不了的. 举例: 12String contextPath = request.getContextPath();response.sendRedirect(contextPath+&quot;/responseDemo2&quot;); 所以说,你要是还不知道虚拟目录是啥,你就打印一些context再去tomcat-&gt;编辑结构下面找一下就晓得了. 重定向方式: 告诉浏览器要重定向,通过setStatus()设置状态码302实现;然后告诉浏览器重定向servlet的路径,通过setHeader()方法设置响应头location:告诉浏览器重定向servlet的资源路径实现 这也是最常用的方法重点掌握: 通过sendRedirect(String url)实现,其中url表示重定向资源路径,格式和form表单中action的路径一致,都是/虚拟路径/资源路径,这两个东西不清楚就去看Request博客下request案例第5点的注意事项. 服务器输出字符数据到浏览器 步骤: 获取字符输出流. 输出数据. 产生乱码 乱码原因: 编码和解码使用的码表,即字符集不一致 浏览器使用的字符集可以通过IE浏览器点击右键查看编码知道,我电脑是Unicode编码. 而服务端的编码表由于是response调方法产生的,不是new出来的(new出来的那就和系统保持一致),而response对象又是tomcat产生的,tomcat又不是中国人写的,所以用的字符集不是Unicode,一般来说是ISO-8859-1的拉丁编码. 乱码解决办法: 在获取流之前,设置流的编码,通过一条语句设置: response.setContentType(&quot;text/html;charset=utf-8&quot;);,通过这句话可以告诉浏览器我的响应信息是文本类型的同时字符集是utf-8类型的. 服务器输出字节数据到浏览器 步骤: 获取字节输出流. 输出数据.注意: 这里为了防止出现乱码,在用response对象设置编码前,把request的编码设置为相同,同时设置字节流输出时byte数组的编码 案例: 简单的验证码 本质是一张图片 验证码的目的: 防止恶意表单注册,就是比如说没有验证码,我可以写个程序,生成不重复的你表单需要填的东西然后无限注册,你数据库迟早崩溃. 这个前端的js我就不会了,然后那个点击验证码换图片我不晓得咋整,暂时也不想去想那个东西. 前端代码: 验证码案例前端代码. 其余部分代码如下: 验证码案例代码.ServletContext(接口) 概念: 代表整个web应用,即整个web工程,可以和程序容器(服务器)例如tomcat进行通信. 功能: 获取MIME类型: MIME类型: 在互联网通信过程中定义的一种文件数据类型. 格式: 大类型/小类型, 例如: text/html,表示纯文本/html类型. 方法: String getMimeType(String file); 获取MIME类型案例代码. 域对象: 域对象主要是用来共享数据的,如request对象通过调用getAttribute()来共享数据. 域对象都有的几个方法: void setAttribute(String name, Object value)给name赋值; Object getAttribute(String name)通过名称获取值; void removeAttribute(String name); servletContext范围: 能共享所有用户所有请求的数据,就是只要你是在这个服务器运行的,在哪里运行都可以获取到,而且只要存储数据的类运行一次,它就会一直存在知道类被销毁. 共享数据示例代码_设置数据代码. 共享数据示例代码_获取数据代码. 获取文件的真实路径(服务器路径). 方法: String getRealPath(String path); 获取文件的服务器路径代码. 获取ServletContext对象 通过request对象获取: request.getServletContext(). 通过HttpServlet类获取: 这是该类的父类GenericServlet中的一个方法,由于我们的servlet都是继承子httpServlet,所以通过httpservlet获取也行,反正子类具有父类属性,即: this.getServletContext(). 文件下载案例用谷歌浏览器会直接下载,没有提示框,建议用ie 需求: 页面显示超链接 点击超链接后弹出下载提示框 完成图片文件下载 分析: 超链接指向的资源(比如图片)如果能够被浏览器解析,则该资源会在浏览器中展示,如果不能解析(比如视频),才会弹出下载提示框,这是不满足需求的.我们的需求应该是任何时候都要弹出提示框,这就需要response的响应头Content-disposition了. 使用响应头来设置资源的打开方式为附件形式: Content-disposition: attachment;filename=xxx. 步骤: 定义页面,编辑器超链接属性,让其指向servlet,但是这里就需要想到,我们有多个文件,每次弹出的提示框是不一样的,但是指向的都是同一个servlet,这时我们就需要在超链接中用到响应头Content-disposition中的filename=xxx来设置参数了!!! 定义servlet 获取文件的名称. 使用字节输入流加载文件进内存. 指定response的响应头Content-disposition. 将数据写出到response的输出流即可. 案例代码. 问题: 中文文件名问题(注意这个是不能用response.setContentType解决的),比如我的图片名字是哆啦A梦.jpg,在谷歌浏览器里面,它依旧会下载,但是下载名是空白或者下划线,那当然下载下来的东西自然也是看不了的;在ie里面直接会报错400. 解决思路: 获取客户端使用的浏览器版本信息. 根据不同的版本信息响应不同的数据,即设置filaname的编码方式不同,这里需要用到一个工具类. 今天用git推送资源的时候报了个错: unable to access &#39;https://github.com/fanfan999/WebCodes.git/&#39;: SSL certificate problem: self signed certificate,百度了一下,解决方案是: 输入这行命令 git config --global http.sslVerify false就可以了.]]></content>
      <categories>
        <category>javaee</category>
      </categories>
      <tags>
        <tag>reponse</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[堆排序]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F05%2F10%2F%E5%A0%86%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[堆排序(重要)前言: 时间复杂度为O(N*logN),额外空间复杂度为O(1). 二叉树: 二叉树就是一棵特殊的树,即每一个节点只有两个子节点. 满二叉树: 首先它是一个二叉树，如果这个二叉树的每一个层的结点数都达到最大值(或者理解为除了最下面一层没有任何子节点以外,其它所有层都是满满当当的二叉树)，则这个二叉树就是满二叉树。也就是说，如果一个二叉树的层数为K(K从1开始)，且结点总数是(2^k) -1 ，则它就是满二叉树,从形状上看,满二叉树就是一个完整的三角形. 叶结点: 当一个节点没有左节点和右节点的时候,这个节点就叫叶子节点. 完全二叉树: 若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。还有一种理解就是,如果除了最后一层和倒数第二层不满,其它层都是满的,并且最后这两层的节点都是从左到右依次补齐的,这个这个….大家画个例子就容易理解了,我也说不清楚了,大家百度一下哈哈哈. 二叉树其实是可以和数组对应起来的,我们可以通过数组在脑子里脑补出来它对应的完全二叉树结构,如图所示.. 堆(就是完全二叉树) 大根堆: 在这棵完全二叉树中,整棵树的最大值就是这棵树的根节点(也可以理解为它的头,反正就是最上面那一个节点),这个规则对于它的左右子树也同样成立,如[6,5,4,3,4],根据我上面画的自己脑补一下子哈. 小根堆: 同理,任何一颗子树(包括整个树)的最小值都是根节点,如[1,2,3,4,5]. 建立一个大根堆的时间复杂度是O(N),因为比如来说第一个数和根节点,也就是自己比较,时间复杂度为log1,第四个数,需要和自己的父节点和父节点的父节点比较,也就是要比较两次,即log(4),所以N个数的时间复杂度为: log(1) + log(2) +……+log(N) = O(N). 堆排序过程(以[3,5,4,5,6]为例) 让数组变成大根堆,即[6,5,4,5,3]. 把大根堆的最后一个位置和堆顶位置做交换,同时让堆的大小减一,此时,大根堆的根节点,也就是本数组中的最大值6就固定在数组最后一个数不动了. 让数组从0到array.length - 2(也就是大根堆的长度,本来是减1,但是因为刚才6放下来又减1了)重新建立大根堆,就变成了[5,5,4,3,6]. 然后又把大根堆第一个位置5的数和最后一个位置的数3,注意是3,不是6交换,再重复步骤3……循环往复. 当最后大根堆中只有一个元素就停止,此时数组就有序了,即[3,4,5,5,6]. 堆排序代码.]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>堆排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Request]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F05%2F10%2FRequest%2F</url>
    <content type="text"><![CDATA[Request Request和Response对象的原理 request和response这两个对象是由tomcat服务器创建的,我们不创建它们,我们只使用他们. request对象是来获取请求消息的,response对象是用来设置响应消息的. 原理图: . request对象的继承体系结构 ServletRequest(接口) HttpServletRequest(接口): 继承自ServletRequest. org.apache.catalina.connector.RequestFacade@1b59119e: tomcat实现了HttpServletRequest接口,编写了这个RequestFacade类,通过这个类创建request对象. request对象: 获取请求消息数据 获取请求行数据 请求行格式: GET /requestDemo(虚拟目录)/requestDemo1?name=fan HTTP/1.1 方法: 获取请求方式(GET): String getMethod(). 这个方法就是在service中判断判断是什么请求方法,然后由service去掉用对应的方法,所以我们不怎么用到. (重要)动态获取虚拟目录(/requestDemo): String getContextPath(). 获取资源路径,也可以称为servlet路径(/requestDemo1): String getServletPath(). 获取get方式的请求参数(name=fan): String getQueryString(). (重要)获取请求的uri,即虚拟目录+资源目录(/requestDemo(虚拟目录)/requestDemo1): String getRequestURI(). StringBuffer getRequestURL(): 返回整个url路径,比如http://localhost:8080/requestDemo/requestDemo1. url: 统一资源定位符. uri: 统一资源标识符,其代表的范围大于url,可以理解为url是中华人民共和国,而uri是共和国. 获取协议和版本(HTTP/1.1): String getProtocol(). 获取客户机的ip地址: String getRemoteAddr(). 演示代码. 获取请求头数据 方法 (重要)String getHeader(String name): 通过请求头的名称来获取请求头的值,其中name不区分大小写. Enumeration getHeaderNames(): 获取所有请求头的名称. 演示代码. 获取请求体数据 请求体只有POST请求方式才有请求体,在请求体中封装了POST请求的请求参数. 步骤: 获取流对象(字节流,字符流). BufferedReader getReader(): 获取字符输入流,只能操作字符数据. ServletInputStream getInputStream():获取字节输入流，可以操作所有类型的数据,这个在文件上传再说. 再从流对象中拿数据. 演示代码, 这个代码中文读出来是乱码,怎么搞都是乱码,果断放弃,后来才知道,这里需要将request的编码设置为Unicode,因为浏览器的编码表是Unicode的. 其它功能 获取请求参数通用方式(GET, POST都可以用来获取请求参数) String getParameter(String name): 根据参数名称来获取参数值,例如你有这样一串参数: user=饭饭&amp;password=123,我传入参数为user就可以得到饭饭这个值. String[] getParameterValues(String name): 根据参数名称获取参数值的数组,例如: hobby=abc&amp;def&amp;hij,我们通过这个方法就可以获取多个值,多用于复选框. Enumeration getParameterNames(): 获取所有请求的参数名称. Map&lt;String, String[]&gt; getParameterMap(): 获取所有参数的键值对集合. 中文乱码问题 通过实验发现有一个问题,就是如果表单的提交方式是post,传中文就会乱码;但是如果表单提交方式是get,传中文就不会出现乱码,为什么呢? get方式: tomcat8 就已经将get方式乱码问题解决了. post方式: 在获取参数前设置request的编码格式,多写一行代码就可以了: request.setCharacterEncoding(&quot;UTF-8&quot;);,括号中的参数和html文件中的编码格式一样就可以了,一般都是utf-8. 获取请求参数通用方式示例代码. 请求转发: 可以理解为一种在服务器内部的一种资源跳转方式,形象一点就是在同一个tomcat中,多个serevlet类之间互相跳转的方式. 步骤: 通过request对象调用RequestDispatcher getRequestDispatcher(String path)方法,获取请求转发器对象. 使用RequestDispatcher对象调用void forward(ServletRequest request, ServletResponse response)方法进行转发. 请求转发示例代码. 特点: 浏览器地址栏路径没有发生改变,就算跳转到了另一个servlet,但是地址栏中还是原来的servlet地址. 只能转发到当前服务器的内部资源中,就是说只能转发到一个tomcat服务器下的的东西,也就是同一个src文件夹下面的不同类可以相互随便转发,不在一个包没得事. 这样子的转发只发出一次请求,通过浏览器的f12然后查看网络,当我们输入链接后,发现浏览器只有一次请求. 共享数据 域对象: 一个有作用范围的对象,可以在范围内共享数据. request域: 代表一次请求的范围,一般用于一次请求转发到多个资源中去共享数据. 方法(都是用request对象调用的) void setAttribute(String name , Object obj): 存储数据,说白了就是给name赋值,而且什么值都可以,int,String都行. Object getAttribute(String name): 通过键获取值. void removeAttribute(String name): 通过键移除键值对. 示例代码1. 示例代码2. 获取servletContext对象 方法: ServletContext getServletContext(). 案例代码: System.out.println(request.getServletContext());,在浏览器输入网址:http://localhost:8080/requestDemo8后得到一个对象的地址. request案例: 用户登录 需求: 编写login.html登录页面,有username和password两个输入框. 使用druid数据库连接池技术,操作mysql. 使用jdbcTemplate技术封装jdbc. 登录成功跳转到SuccessServlet,同时显示: 登录成功! 用户名, 欢迎您!字样. 登录失败跳转到FailServlet,同时显示: 登录失败! 用户名或 密码错误!字样. 开发步骤: 创建项目,创建html页面,导入druid配置文件以及一系列jar包. 创建数据库环境,在数据库中建表,插入一点数据等. 创建一个domain包,创建一个实体类User 这里有一个叫法,我们把实体类也叫做javabean,就是一般都只有get和set方法,提供属性这些的. 创建一个dao包,创建类UserDao,在类中提供login方法. 创建servlet包,同时创建loginServlet类. 注意: login.html中form表单的action的路径的写法: 虚拟目录(就是我之前说的点击tomcat-&gt;编辑结构-&gt;Deployment-&gt;Application context中的路径,如果只是一个斜杠就表示虚拟目录不用写) + servlet的资源路径. 创建SuccessServlet和FailServlet类. 建立一个BeanUtils工具类,简化数据的封装(我这里会有问题,就是用这些工具类永远获取不到用户名,我也不晓得为啥). 登录案例代码. JavaBean: 标准的Java类(一般放在domain包里面) 要求 类必须被public修饰. 必须提供空参的构造器. 成员变量必须使用private修饰. 提供公共的getter和setter方法. 功能: 封装数据的 成员变量: 如private int age中的age就是成员变量. 属性: getter()和setter()方法截取后的产物,例如: getAge()方法中的Age就是属性,一般和成员变量名字相同. 方法: setProperty(Object bean, String name, Object value): bean表示一个javabean对象,例如user; name表示一个属性名,例如getAge中的age,这个必须写成小写,虽然方法名中是大写; value表示前一个参数属性名的属性值. getProperty(Object bean, String name): 含义和上面一样. populate(Object obj, Map map):这个比较重要,将map集合中的键值对信息封装到对应的javabean对象中.]]></content>
      <tags>
        <tag>Request</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速排序]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F05%2F08%2F%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[快速排序(重要,用的很多)一个引入例子 荷兰国旗问题 荷兰国旗问题就是指,给定一个目标数target和目标数组array,设计一个方法,使得该数组中大于target的数都放在左边,小于target的数都放在右边,等于target的数都放在中间. 步骤: 设计一个左边界,使其初始位置在下标0的左边一位. 设计一个右边界,使其初始位置在最后一个元素下标的的右边一位即array.length. 给定一个计数变量cur,记录当前数组中第几个数在被操作比较. 如果array[cur] &gt; target,则左边界的下一位数和当前位置的数交换,同时左边界移动到下标为1的位置,即左边界++右移一位,以及当前位置下移一位. 如果array[cur] &lt; target,则右边界的前一位数和当前位置的数交换,同时右边界下标为array.length - 1的位置,即右边界--左移一位,注意,此时当前位置不移动,因为交换过来的数没有进行判断. 如果array[cur] == target,不坐任何操作,当前位置++. 这个代码其实很简单,可能我说不是很好理解,我直接贴代码: 荷兰国旗问题代码. 其时间复杂度为o(N),额外空间复杂度为O(1). 根据荷兰国旗问题的快速排序 快速排序怎么排? 给定一个数组[1,2,3,4,5,4,3],然后把数组的最后一个数1作为比较的数. 和最后一个数1相比,跟荷兰国旗一样,小的放左边,大的放右边,等于的放中间. 然后再去对小于区和大于区这样做 ……如此循环下来,数组就有序了. 快速排序代码. 这种快排别经典快排要快一些,经典快排一次只排一个数,而这种一次可以把相等的都放好,反正我学了这种我就把经典快排忘了哈哈哈. 它的时间复杂度: 当已经有序的来排序的时候,例如[1,2,3,4,5,6],来排序的时候,每次都用最后一个去比较,每次都只能排序一个,这样子的左右部分规模差别很大的时候,时间复杂度为O(N^2). 最好的情况是,每次左边界和右边界的数都差不多相等,然后就是一个递归的过程,时间复杂度就和归并一样了,为O(N*logN). 这就是经典快排的缺点,和数据的状况有一定关系. 随机快排 随机快排就是指在给定排序的数组中随机选择一个数去作为本次的参照数,虽然这样子还是有可能出现左右部分的规模差别很大,不过这个就是概率问题了,所以这样的快排时间复杂度就只能用平均时间复杂度,也就是我们的期望值来表示. 这个时间复杂度就记住就可以了,反正我不会证明,数学不好,随机快排期望时间复杂度为: O(N*logN),额外空间复杂度为O(log(N))(这个就可以理解为每次断点打在中间,因为要记录相等点的位置,所以浪费了空间,最差额外空间是O(N),因为就相当于每个点都要记下来). 随机快排相较于上面的快排就只多了一行代码,这行代码使得我们随机找出来一个数作为最后一个数,也就是参照数哈哈哈,我在代码里标注出来了,代码: 随机快排代码.]]></content>
      <categories>
        <category>快速排序</category>
      </categories>
      <tags>
        <tag>快速排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet和HTTP请求协议]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F05%2F08%2FServlet%E5%92%8CHTTP%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[Servlet 什么是servlet? 即server applet, 运行在服务器端的小程序 一个小技巧,java里面的规则都可以理解为接口. servlet就是一个接口,定义了java类被浏览器访问到(可以被tomcat识别)的规则,这也就是为什么servlet不用main方法也可以执行的原因,它是由tomcat执行的. servlet是用在动态项目里的,我们都知道动态项目,每个人去访问得到的结果可能是不一样的,那么怎么使得结果不一样呢? 就是通过java代码来实现的,而这些java代码,满足servlet定义的规则,不需要主方法,被tomcat这个服务器软件执行,例如: 张三发出请求,服务器响应张三欢迎你,李四发出请求则响应李四欢迎你这样子. 可以通过javaee的api找servlet看一看,直接百度就有,javaee的api7. 将来我们自定义一个类,实现servlet接口,重写其方法,那么这个类就被称为servlet,也可以被tomcat识别并执行. servlet快速入门 创建一个javaee项目. 定义一个类,实现servlet接口(要导入servlet包,idea会提示你的). public class ServletDemo1 implements Servlet. 重写接口中的抽象方法. 在web.xml中的标签下配置servlet. servletDemo1 servlets.ServletDemo1 &lt;!--对servlet做一个映射,表示servletDemo1对应的类是servlets.ServletDemo1--&gt; &lt;servlet-name&gt;servletDemo1&lt;/servlet-name&gt; &lt;!--表示这个类可以被哪个路径访问到, 所以/demo1表示一个资源路径--&gt; &lt;url-pattern&gt;/demo1&lt;/url-pattern&gt; 完成之后,访问localhost:8080/demo1就会在控制台输出写在service方法中的hello,servlet,因为我们之前设置tomcat的时候,把虚拟路径是省略了的,所有直接访问url名称,然后通过url去找到servlet类就可以了. servlet快速入门案例代码. servlet执行原理 当服务器接收到客户端浏览器的请求后,服务器会解析请求的url路径,获取访问的的servlet的资源路径,如通过”http://localhost:8080/day3_tomcat/demo1&quot;这个url路径,我们可以知道`demo1`这个东西在`day3_tomcat`目录下. 查找对应的web.xml文件,看是否有与demo1这个资源路径对应的&lt;url-pattern&gt;标签. 如果有,则再在&lt;/servlet-mapping&gt;中通过&lt;servlet-name&gt;找到对应的&lt;servlet-class&gt;标签下的内容,找到对应的类. tomcat通过反射会将字节码文件加载进内存(Class.forName()),然后创建其对象(通过newInstance()). 调用其方法. servlet中的方法(5个) public void init(): 初始化servlet,在创建servlet的时候执行,只会执行一次. servlet什么时候被创建呢? 默认情况下,第一次被访问时,servlet被创建. 我们可以在xml文件中配置指定servlet的创建时机. 在xml中的&lt;servlet&gt;标签下,加入一行语句: &lt;load-on-startup&gt;&lt;/load-on-startup&gt;,当该标签内容为0或正整数时,表示servlet在创建时就被初始化;而当该标签内内容为负数时,表示servlet在第一次被调用时初始化,同时该内容默认为-1. init()方法只执行一次,说明servlet在内存中只存在一个对象,也就是说,servlet是单例的. 当多个用户同时访问时,可能存在线程安全问题. 解决方案: 尽量不要在servlet中定义成员变量,就没有共享的变量了,而且,即使定义了成员变量,也不要对其进行修改操作,就不会出问题. 修改初始化时机示例代码. public ServletConfig getServletConfig(): 获取ServletConfig对象,该对象就是servlet的配置对象,了解一下就行. public void service(): 提供服务的方法,servlet被调用就会被执行,可以执行多次. public String getServletInfo(): 获取servlet的一些信息,如版本,作者等,了解就行. public void destroy(): 销毁servlet,在服务器正常关闭,servlet被杀死的时候执行,也只执行一次. destroy()方法执行时机在servlet销毁前,可以把这个方法理解为临终遗言哈哈哈. 生命周期 被创建 提供服务 被销毁 servlet3.0 好处: 支持注解配置,也就是说不需要注解文件配置. 步骤: 创建javaee项目,选择servlet的版本为3.0以上(就是idea创建java enterpeise模块的时候选择web application之后下面的version在3.0以上就可以了,在jdk6以后就支持了),此时就可以不用创建web.xml文件了. 定义一个类,实现servlet接口,作为servlet使用. 重写servlet接口中的抽象方法. 在类上(就是继承servlet接口的类!!)使用注解(annotation)@WebServlet进行配置. @WebServlet(“urlPatterns = “/servlet资源路径即“”). 再次回想虚拟目录,虚拟目录就是我们项目文件夹的访问方式,也就是localhost:8080/day1_servlet/demo中的day1_servlet,我们之前给他省略了. servlet3.0示例代码. idea与tomcat相关配置 idea会为每一个tomcat部署的项目单独建立一个配置文件. 启动tomcat在控制台会有这样一个语句Using CATALINA_BASE: &quot;C:\Users\asus\.IntelliJIdea2018.3\system\tomcat\_Web_Codes&quot;. 工作空间项目和tomcat部署的web项目存放的目录不在一起,后者放在idea中直接打开文件位置的out目录下面,我这里在D盘,前者就是直接打开在文件夹中位置的目录(通过上述路径下配置文件中的root.xml也可以看到). tomcat真正访问的是tomcat部署的web项目,该项目对应着工作空间项目的web目录下的所有东西,其实就是idea直接能看到的东西. WEB-INF目录下的资源不能直接被浏览器访问,即如果不小心将html文件写到了该目录下,输入对应的url是访问不到的. servlet接口的实现体系结构 我们直接让类继承servlet接口的时候,接口中的所有方法我们都必须重写,但是很多时候其它方法我们用不到,我们只需要一个service()方法就可以了,这样子就显得代码很冗余,所以servlet做了一些改进. 它其中的两个实现类 GenericServlet: 抽象类 HttpServlet: 抽象类 因为上述两个是抽象类,所以我们写servlet的时候可以不用去实现servlet,可以直接继承上述servlet的实现类. GenericServlet类(不怎么用) 它将servlet接口中的其它方法做了默认空实现,只将service()方法作为抽象方法,子类必须实现,其它方法子类可以手动选择重写. 所以将来定义servlet类时,可以继承自该类,同时只需要实现service()方法. HttpServlet类(推荐),可以不用管是get还是post方式获取数据,service()方法中自动判断,然后调用对应的doGet或者doPost方法. 该类可以理解为是对http协议的一种封装,简化操作. 步骤: 定义类继承HttpServlet类. 重写doGet或者doPost方法. 浏览器访问servlet是get(浏览器地址栏会显示你输入的信息)方法,表单可以设置为post(不显示输入信息)方法. servlet的相关配置 : servlet访问路径. 路径定义规则: /xxx. /xxx/xxx/……,多层路径,访问时必须把多层路径都写上,当然这也有一个特殊写法: /xxx/*,这表示第二层你随便写什么都行,甚至只写/xxx/都可以,/*表示通配符,不过这个优先级很低,要等其它的都找完了才来找它. *.do,前面不能加/,就直接写urlPatterns = &quot;*.do&quot;),这表示用例如demo4.do就可以访问到demo4这个资源了. 注意: 我们查看WebServlet的源码可以知道,使用注解定义url-pattern时,url-pattern在源码中是一个数组,说明是可以有很多个的,即可以让多个访问路径访问一个servlet. 书写方法: @WebServlet(urlPatterns = {&quot;/访问路径1&quot;, &quot;/访问路径2,......&quot;}). 这里当访问路径只有一个的时候{}才能省略,多个的时候不可以省略.HTTP请求协议HTTP 概念: Hyper Text Transfer Protocol 超文本传输协议 传输协议: 定义类了客户端和服务端通信时发送数据的格式,有了这个协议,两边才可以读懂传输信息的内容. 特点 基于TCP/IP的高级协议,所以http也是一种安全的协议. http默认端口号: 80,当我们把tomcat的端口号设置为80的时候,此时的访问网址中的端口写不写都一样,例如: http://localhost:80 == http://localhost. 基于请求响应模型,响应和请求是一一对应的,即一次请求对应一次响应. http协议是一种无状态的协议,即每次请求之间相互协议,请求与请求之间没有关系,不能相互交互数据. 历史版本(现在有2.0版本) 1.0: 每一次请求响应都会新建一个连接,请求响应完成就断开本次连接. 1.1: 不会每一次请求响应都新建一个连接,它会复用同一个连接来完成多次请求响应,本次请求响应完成后在那里等一会,还有东西来就继续传,没有了再断开. 请求消息数据格式(四部分) 请求行 请求方式 请求url 请求协议/协议版本 对于login.html文件其请求行是这样的 GET /login.html HTTP/1.1 请求方式: HTTP协议有7种请求方式,常用的有两种. GET: 其请求参数在请求行中,即在url网址后面(重要). 请求的url长度是有限制的. 不太安全. POST: 其请求参数在请求体中,不放在网址中(重要). 请求的url长度是没有限制的. 相对安全. 请求头: 浏览器告诉服务器一些信息. 格式为: 请求头名称: 请求头值,多个值中间用,隔开,类似于键值对的形式. 常见的请求头 Host: 找到访问的主机:应用程序. User-Agent: 浏览器告诉服务器,我访问你是用的浏览器版本信息,可以在服务器端获取该头的信息来解决浏览器的兼容性问题. Accept: 告诉服务器我可以接受什么样的格式的信息响应. Accept-Language: 告诉服务器我支持的语言环境. Referer: 告诉服务器,我(当前请求)从哪里来,例如:http://localhost:8080/hello.html. 作用: 防止盗取链接,举一个例子: 比如我们在腾讯视频看电影,都是点击电影名字超链接比如速度与激情,然后就会跳转到电影播放页面,这个过程腾讯是需要给这部电影版权费的,但是有些盗版网站,他没钱买版权,但是又想蹭热度,所以他就也写了一个名字超链接如速度与激情1080P,然后把这个超链接的地址指向腾讯的播放页面,这就叫盗链,为了防止别人盗链,就用到了refer这个请求头,设置了该请求头之后,我就会判断一下这个超链接是否是从腾讯首页跳转过来的,是就正常播放,不是就不播放. 统计工作,还是上面的例子,虽然盗链不可取了,那么我就只能去买版权,买了之后我要挣回本甚至赚钱呀,我就需要把我的网站推广,我就给很多推广公司给钱,比如给百度给了100W,搜狐给了100W,然后我通过设置referer这个请求头计数每个月从百度过来的流量是多少,从搜狐过来的流量是多少,就可以知道以后在哪里多投资了. Host: localhost:8080User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:66.0) Gecko/20100101 Firefox/66.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,/;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateConnection: keep-aliveUpgrade-Insecure-Requests: 1If-Modified-Since: Thu, 09 May 2019 02:41:59 GMTIf-None-Match: W/“247-1557369719386”Cache-Control: max-age=0 请求空行: 就是一个空行,用作分隔请求头和请求头和请求体等. 请求体(正文): 传输的内容(参数),比如username= fan,用于封装POST请求的请求参数,GET请求没有请求体.]]></content>
      <categories>
        <category>Servlet</category>
      </categories>
      <tags>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F05%2F08%2FTomcat%2F</url>
    <content type="text"><![CDATA[Tomcatweb相关概念回顾 软件架构 C/S: 客户端/服务器端. B/S: 浏览器/服务器端(javaee重点,下面都是针对B/S模式的),通过url域名访问,浏览器不用向客户端那样维护. 浏览器发出请求给服务器接收处理. 服务器端对浏览器的请求做出响应. 资源分类(对于服务器来说) 静态资源: 如html,css,js等,所有用户访问得到的结果都是一样的. 浏览器请求访问静态资源时,静态资源直接交给浏览器,而浏览器中有针对静态资源的解析引擎,所以浏览器可以直接解析静态资源展示效果. 动态资源: 每一个用户访问相同资源后得到的结果可能不一样.比如:servlet,jsp,php等. 浏览器请求访问动态资源时,动态资源首先要转换为静态资源再返回给浏览器解析从而展示效果. 网络通信三要素 IP: 找到服务器电脑,这是电子设备(这里就是计算机)在网络中的唯一标示. 端口: 应用程序在计算机中的唯一标示,0~65536,自己写代码的时候一般我们都写10000以上. 传输协议: 数据传输规则. TCP: 安全协议,三次握手保证安全连接,速度稍慢. UDP: 不安全的协议,不建立连接,速度快.web服务器软件: Tomcat 什么是服务器呢? 服务器就是指安装了服务器软件的计算机,例如装了MySql我的电脑就可以被叫做MySql服务器. 服务器软件的作用: 接收用户请求,处理请求,做出响应. web服务器软件: 接收用户请求,处理请求,做出响应. 在web服务器软件中,我们可以部署web项目,让用户通过浏览器来访问这些项目. 也可以被称为web容器. 常见的java相关的web服务器软件 WebLogic: oracle公司的, 大型的javaee服务器,支持所有的Javaee规范,收费的. 什么是javaee呢? javaee是指java在企业级开发中使用的技术规范的综合,一共规定了13项大的规范. WebSphere: IBM公司的,大型的javaee服务器,支持所有的Javaee规范,收费的. JBOSS: JBOSS公司的,大型的javaee服务器,支持所有的Javaee规范,收费的. Tomcat: Apache(阿帕奇)基金组织的,中小型的javaee服务器,仅仅支持少量的javaee规范,开源的. Tomcat: web服务器软件 下载: tomcat下载地址 ,去下载自己电脑对应的版本就可以了. 安装: 解压压缩包就算安装好了哈哈. 安装目录最好不要带中文和空格. 卸载: 删除tomcat的安装目录就可以了. 启动: win: bin目录–&gt;start.bat,linux: bin目录–&gt;start.sh. 注意: 当你点击启动后窗口一闪而过,就是你没有配置环境变量,要配置四个环境变量,反正我是这样子了才可以的. 新建环境变量CATALINA_BASE并配置为: E:\Java\apache-tomcat-6.0.29. 新建环境变量CATALINA_HOME并配置为: E:\Java\apache-tomcat-6.0.29. 新建环境变量TOMCAT_HOME并配置为: E:\Java\apache-tomcat-6.0.29. 在环境变量Path中，新增加“%TALINA_HOME%\bin\ “. tomcat启动报错,就是启动成功后再一次启动黑窗口一闪而过的样子,通过查看日志文件可以知道,原因是因为端口号被占用了. 解决方案1: 停止占用该端口号的应用程序进程.可以在dos窗口下输入netstat -ano通过找到本地地址后四位为8080的进程,记住其PID,然后在进程中停掉它就可以了. 解决方案2: 修改自身的端口号,在config目录下找到配置文件server.xml中修改port就可以了. 一般我们修改tomcat的端口号为80,因为80是http协议的默认端口号,这样我们访问就不需要输入端口号了. 完成这四步以后,再点击start.bat就可以成功启动tomcat了,有可能有乱码问题,这个无关紧要. 然后打开浏览器,输入http://localhost:8080,就可以访问到tomcat的官网去了哈哈,当然要通过别人电脑访问的话,localhost就要换成你电脑的ip地址了. 关闭: 正常关闭: 理解为电脑关机. 双击bin目录下的shutdown.bat. 在启动的黑窗口按下ctrl+c. 强制关闭: 把黑窗口关掉,可以理解为电脑突然断电了哈哈哈. 配置: 部署项目的方式: 直接将项目放到webapps目录下即可,就可以通过例如: http://localhost:8080/hello/hello.html访问了 其中hello表示一个名为hello的文件夹. /hello:表示项目访问路径,也就是虚拟目录,一般名称与目录名相同,访问的时候,就是通过虚拟目录名称找到文件所在文件夹的. /hello.html: 表示文件名称. 简化部署: 将项目打包成一个.war压缩包,再将.war包放到webapps下面,他就会自动解压缩,删除的时候也只需要删除.war包就可以了,解压的文件他会自动删除. 配置config目录下的server.xml文件中的&lt;Host&gt;标签体,在其中添加一些语句: &lt;Context docBase = &quot;文件路径(文件所在文件夹的路径)&quot; path = &quot;/servlet资源路径,即url路径,一般写成和文件名称相同,也就是项目名称,也就是最终通过这个path访问的东西&quot; /&gt;. (推荐)在apache-tomcat-9.0.19\conf\Catalina\localhost目录下新建一个任意名称的xml文件,然后在文件中添加一句&lt;Context docBase = &quot;文件路径(文件所在文件夹的路径)&quot;/&gt;. 注意: 此时的虚拟目录就是xml文件的名称,这是一种热部署方式,当我们不想运行这个文件了,但是又不想停掉服务器,我们就可以给这个xml文件加上后缀_bak,我们就访问不了了. 静态项目和动态项目 静态项目: 只能放静态资源 动态项目: 可以放静态资源和动态资源 目录结构(以java动态项目的目录结构为例): —项目的根目录(例如tomcat中webapps下面的root目录) —WEB-INF目录(只有动态项目才有这个目录) —web.xml: web项目的核心配置文件 —classes目录: 放置字节码文件的目录 —lib目录: 放置依赖的jar包. tomcat解压后各个目录分别是干啥的呢? bin目录: 可执行文件. conf目录: 配置文件. lib目录: 依赖的jar包. logs目录: 日志文件. temp目录: 临时文件. webapps目录: 存放web项目的. work目录: 存放运行时的数据. 将tomcat集成到idea中,并且创建javaee项目,部署项目. emm,这个东西不大好写,百度也有好多,我就我就不写了哈. 然后有个技巧就是,热部署,就是你修改了html文件这些会自动跟新,在On update action里面,这些百度也有,我就是提醒一下那个就叫热部署罢了,然后一般选第一个选项update resources就可以了,不要选第二个,因为java代码带动可能会很多,改一下重新部署一次有点浪费资源,这个就手动重新部署吧哈哈,不过电脑比较好选也没事. 还有一个要注意的点就是:我们eclipse直接输入localhost:8080就可以访问index.jsp页面,但是idea默认情况下localhost:8080/......,这个斜杠后面就是我们上面说的虚拟目录,怎么让他消失呢?你点tomcat会有一个下拉栏,点击编辑结构,然后把Deployment下面的Applicationic context改为/就可以了. 今天有点懒,就懒得贴图了,不懂就给我发消息吧,我帮你搞也行.]]></content>
      <categories>
        <category>Tomcat</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[xml基础]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F05%2F07%2Fxml%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[xml基础xml 概念: Extensible Markup Language 可扩展标记语言. 可扩展: xml标签都是自定义的,例如,. 功能 存储数据: 可用作配置文件. 可用于在网络中传输. xml与html的区别: 他俩的亲爹都是w3c(万维网联盟),XML 是 W3C 的推荐标准.xml晚于html产生,因为html由于浏览器的恶性竞争(浏览器解析能力不同)导致html语法不那么严格也可以达到相同的效果. xml始终争不过html,所以它改为与properties(只能存键值对)竞争,例如name = zhang, gender = nan 和 name = li, gender = nv 在这里我凭什么不可以认为zhang的性别是nv呢?而xml可以通过标签包裹用户信息,例如&lt;user id = &#39;1&#39;&gt;&lt;name&gt;zhang&lt;/name&gt; &lt;gender&gt;nan&lt;/gender&gt;&lt;/user&gt;,这样子可读性更高,而且容易理解. 区别1: xml的标签都是自定义的,html标签都是预定义的. 区别2: xml的语法严格,html的语法松散,很难写错. xml是存储数据的,html是展示数据的(将数据内容展示到页面上). 语法 基本语法: xml文档的后缀名: .xml. 第一行必须是文档声明,即&lt;?xml version = &#39;1.0&#39; ?&gt;,顶行写,必须在第一行,不过我在谷歌浏览器,不写文档声明也没有报错,但是还是写上最好. 一个xml文档有且只有一个根标签,如例子中的&lt;users&gt;. 属性值必须使用引号引起来,单双引号都可以. 标签必须为一对,即有开始就必须有结束,如&lt;abc&gt;&lt;/abc&gt;,或者为自闭合标签,如&lt;abc/&gt;. xml标签区分大小写,如&lt;abc&gt;&lt;/ABC&gt;会报错. 快速入门:将下列例子存放在xml文本文件中再直接用浏览器打开,没报错就说明写对了 . 1234567891011&lt;?xml version = &apos;1.0&apos; ?&gt; &lt;users&gt; &lt;user id = &apos;1&apos;&gt; &lt;name&gt;fan1&lt;/name&gt; &lt;age&gt;2&lt;/age&gt; &lt;/user&gt; &lt;user id = &apos;2&apos;&gt; &lt;name&gt;fan2&lt;/name&gt; &lt;age&gt;2&lt;/age&gt; &lt;/user&gt; &lt;/users&gt; 组成部分: 文档声明 格式: &lt;?xml 属性列表 ?&gt; 注意:在&lt;?xml 属性列表 ?&gt;中,?和&lt;&gt;和xml三者之间不能有空格,有空格就会报错. 属性列表: version: 版本号,只写1.0,写1.1会出问题,它不向下兼容,没有1.2版本,而且,这个version是必须写的,不写会报错. encoding: 编码方式,告知解析引擎当前文档使用的字符集,默认是UTF-8,不写也可以,一般就写UTF-8就行,写其他的可能会出错. standalone(了解): 是否独立. 有两个值yes和no. yes表示不依赖其他文件. no表示依赖其他文件. 不过这个我们一般不管他. 指令(了解) 可以结合css使用,现在不用,现在xml只用来存储数据. 标签 标签名称是自定义的. 命名规则超链接: xml命名规则. 属性 id属性值唯一. 文本内容 CDATA区: 在该区域的数据会被原样展示,因为有的符号需要转义xml才能识别,有了这个就不需要转义了. 格式: &lt;![CDATA[语句]]&gt; 约束 谁编写xml?—用户写,即软件的使用者(就是程序猿啦) 谁解析xml?—被使用的软件(半成品软件,理解为框架),但是这里有一个问题,就是我的这个框架怎么知道程序猿写的标签是要干嘛的呢?所以这里就需要一个约束来规定一下,什么标签是用来干嘛的,这就是该软件提供的说明文档,也叫约束文档,用于说明xml文档的书写规则. 约束概念: 规定xml文档的书写规则. 作为框架的使用者(程序猿): 能够在xml中引入约束文档. 能够简单的读懂约束文档. 分类: DTD: 简单的约束技术,不过缺陷蛮多. 引入dtd文档到xml文档中 内部dtd: 将约束的规则定义到xml文档中(了解). 外部dtd: 将约束的规则定义在外部的文件中. 本地引入: &lt;!DOCTYPE 根标签 SYSTEM &quot;dtd文件的位置&quot;&gt;. 网络引入: &lt;!DOCTYPE 根标签 PUBLIC &quot;dtd文件的名字&quot; &quot;dtd文件的位置(url位置)&quot;&gt;. 缺陷: dtd中的约束为sex必须字符串,我希望的是只有男和女,但是如果xml文档中写了个不知道也是不会报错可以正常运行的,这个就不合规范比较随意,不是我们想要的. DTD工具和例子. Schema: 较复杂的约束技术,可以限制内容. Schema工具和例子. 解析: 操作xml文档,将文档中的数据读取到内存中. 操作xml文档: 解析(读取):将文档中的数据读取到内存中. 写入: 将内存中的数据保存到文档中,持久化的存储. 解析xml的方式: DOM:将标记语言文档一次性加载进内存,在内存中形成一颗DOM树结构 优点: 操作方便,可以对文档进行CRUD的所有操作. 缺点: 由于是一次加载所有的进内存,所以比较占内存. SAX:逐行读取,而且是读到下一行,上一行就释放了,所以在内存中一直都只有一行代码,同时这个是基于事件驱动的. 优点: 不占内存. 只能读取,不能增删改. xml常见解析器: JAXP(sun公司提供的):支持DOM和SAX两种思想,性能很低,不用. DOM4J:一款非常优秀的解析器,基于DOM思想. Jsoup:本来是用来解析html的,是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。 Jsoup工具. PULL:安卓操作系统内置的解析器,是SAX方式的. Jsoup解析器 快速入门: 使用步骤: 导入jar包如: jsoup-1.11.2.jar. 获取Document对象. 获取对应的标签(Element对象). 获取数据 代码: Jsoup快速入门代码. 123456789101112131415161718//获取student.xml的路径 String str = JsoupDemo.class.getClassLoader().getResource(&quot;student.xml&quot;).getPath(); //解析xml文档,加载文档进内存,获取dom树,即document对象 try &#123; Document document = Jsoup.parse(new File(str), &quot;utf-8&quot;); //获取元素对象,即element(标签)对象,Elements就是一个list列表,会存放所有name Elements elements = document.getElementsByTag(&quot;name&quot;); System.out.println(elements.size()); //获取第一个name的element对象 Element element = elements.get(0); //获取数据 String name = element.text( ); System.out.println(name); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; 对象的使用: Jsoup: 工具类, 可以解析html和xml文档,返回Document对象. 注意其中的parse()方法,用于解析html和xml文档,返回Document对象. (重点)`public static Document parse​(File in,String charsetName)`:解析html或xml文件的. public static Document parse​(String html): 解析xml或html字符串. `public static Document parse​(URL url,int timeoutMillis)`: 通过网络路径获取指定的html或xml的文档对象. Jsoup对象案例代码. Document(继承自Element): 文档对象,代表内存总的dom树. 主要用于获取Element对象(Element是Elements的父类) public Elements getElementsByTag​(String tagName): 根据标签名称获取元素对象的集合. public Elements getElementsByAttribute​(String key): 根据属性名称来获取元素对象集合. `public Elements getElementsByAttributeValue​(String key,String value)`: 根据对应的属性名和值来获取元素对象集合. public Element getElementById​(String id): 根据id值获取唯一的Element对象. document对象演示案例代码. Elements: 元素Element对象的集合,可以当作ArrayList来使用. Element: 元素对象,可以获取元素名称,属性等. 获取子元素对象 public Elements getElementsByTag​(String tagName): 根据标签名称获取元素对象的集合. public Elements getElementsByAttribute​(String key): 根据属性名称来获取元素对象集合. `public Elements getElementsByAttributeValue​(String key,String value)`: 根据对应的属性名和值来获取元素对象集合. public Element getElementById​(String id): 根据id值获取唯一的Element对象. 获取属性值 public String attr(String attributeKey): 根据属性名称(不区分大小写)获取属性值. 获取文本内容 public String text​(): 获取所有子标签的纯文本内容. public String html​(): 获取标签体的所有文本内容,包括子标签的字符串内容. Element对象案例代码. 节点对象: 上述几个对象的爹,是Document和Element的父类. 快捷查询方式: selector: 选择器,在Element类中 使用的方法: public Elements select​(String cssQuery). 语法: 参考Selector类中定义的语法. 选择器查询示例代码. XPath: XPath即为XML路径语言（XML Path Language），它是一种用来确定XML文档中某部分位置的语言,在其中xml是被用来当作节点树对待的. 使用Jsoup的XPath需要额外导入一个jar包,我放在Jsoup工具里了. 语法学习: XPath语法学习. XPath案例代码.]]></content>
      <categories>
        <category>xml</category>
      </categories>
      <tags>
        <tag>xml基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDBC-day02]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F05%2F06%2FJDBC-day02%2F</url>
    <content type="text"><![CDATA[JDBC-day02JDBC控制事务(重要): 事务: 其实是一个包含多个步骤的业务操作,如果这个业务操作被事务管理,则这多个步骤要么同时成功,要么同时失败. 事务操作: 开启事务 提交事务 回滚事务 使用Connection对象来管理事务 方法: 开启事务: setAutoCommit(boolean autoCommit): 调用该方法设置参数为false,则表示开启事务. 在执行sql前开启事务 提交事务: commit(). 当所有sql执行完成后提交事务 回滚事务: rollback(). 在catch中回滚事务,保证任何地方出现问题后都可以回滚,而且catch中抛出的异常要是Exception,保证可以捕捉所有异常. 案例-JDBC管理事务的实现: 代码: JDBC事务管理代码JDBCDemo3 数据库连接池(重要): 我们之前写的代码都是运行一次申请一次资源,资源一用完就释放,就相当于你招聘了一个服务员来给顾客服务,顾客吃完走了你就把这个服务员开除了,下次有顾客来吃饭你就再招聘一个,吃完又把这个服务员开除了,循环往复… 显然这样是不合理的,正常的情况应该是,多招聘几个服务员,当这个服务员服务完这个顾客以后,应该等着给下一位顾客服务,这个就和数据库连接池的定义是类似的. 概念: 其实就是一个容器(集合),存放数据库连接. 当系统初始化结束后,容器就被创建,容器中会申请多个数据库连接对象,当用户来访问数据库时,从容器中获取连接对象,用户访问结束后,就将数据库连接对象还给容器. 好处: 节约资源,使得资源循环利用. 用户访问高效,因为可以节省掉申请资源这些时间. 实现: 使用标准接口: javax.sql包下的DataSource接口. 方法: 获取连接: Connection getConnection(). 归还连接: Connection.close(),如果连接对象Connection是从连接池中获取的,那么调用Connection.close()方法,则不会再关闭连接了,而是去归还连接. 一般我们不去实现它,由数据库厂商实现,例如: C3P0: 数据库连接池技术(较老). Druid(德鲁伊): 数据库连接池技术(较新),由阿里巴巴提供的,用的更多. C3P0: 数据库连接池技术 使用步骤: 导入jar包(两个,还有一个是依赖包),如c3p0-0.9.5.2.jar和mchange-commons-java-0.2.12.jar,注意不要忘记导入数据库的驱动jar包,因为这个说到底还是对数据库的操作. 定义配置文件: 名称: c3p0.properties或者 c3p0-config.xml等,在c3p0 - JDBC3 Connection and Statement Pooling中能看到. 路径: 直接将文件放在src目录下即可,它会自动加载,我们一般用c3p0-config.xml这种文件. 创建核心对象: 数据库连接池对象: ComboPooledDataSource对象. 获取连接: getConnection(). 例子代码我放github了: c3p0工具jar包. c3p0测试代码. Druid(德鲁伊): 数据库连接池技术 使用步骤: 导入jar包druid-1.0.9.jar,同时也不要忘了导入数据库驱动包. 定义并加载配置文件: 是Properties形式的文件,如: druid.properties. 可以叫任意名称,可以放在任意目录下,同时也不会自动加载了(我们都放在src文件夹下面,因为放在其他地方怎么搞都加载失败). 加载配置文件,ProPerties. 获取数据库连接池对象: 通过一个工厂类来获取: DruidDataSourceFactory. 获取连接: getConnection(). 代码,超链接如下 : druid工具jar包. druid测试代码. 定义druid工具类: 定义一个类: JDBCUtils 提供静态代码块加载配置文件,初始化连接池对象. 提供方法: 获取连接方`: 通过数据库连接池获取连接. 释放资源. 获取连接池的方法. 代码超链接如下: druid工具类. druid工具类测试代码. Spring JDBC: JDBC Template(重要): Spring框架提供的对JDBC的简单封装,提供了JDBC Template 对象来简化JDBC的开发. 步骤: 导入jar包,还要导入数据库连接池的包和数据库驱动包. JDBC Template的jar包. 创建JDBC Template对象,但是这个对象创建的时候要依赖于数据源DataSource JdbcTemplate template = new JdbcTemplate(dataSource). 调用JDBC Template的方法来完成CRUD的操作. update()方法: 执行DML语句(增删改). queryForMap()方法: 查询结果将结果集封装为Map集合. 注意: 这个方法查询的结果集长度只能是一,也就是说只能查询一条数据,查询多条会报错,它会将字段名作为key,字段值作为value. queryForList()方法: 查询结果将结果集封装为List集合. 注意: 该方法是将每一条记录封装为一个Map对象,再将Map对象添加到List对象中. query()方法: 查询结果将结果集封装为JavaBean对象. query的参数: RowMapper 一般我们使用BeanPropertyRowMapper实现类,可以完成数据到JavaBean的自动封装,使用的时候,要这样用:new BeanPropertyRowMapper&lt;泛型&gt;(泛型类的字节码文件对象即类型.class). queryForObject()方法: 查询结果将结果集封装对象. 一般用于聚合函数的查询,如练习7,用法是这样的: Long count = template.queryForObject(sql, long.class);. 例子: JDBCTemplate快速入门. 练习: 针对cart数据库中的product表(只有name和product两个字段). 需求 将平板1的价格price修改为1000元. 添加一条记录. 删除刚才添加的记录. 查询id为1的记录,将其封装为Map集合. 查询所有的记录,将其封装为List集合. 查询所有的记录,将其封装为product对象的List集合. 查询总记录数. 代码: 练习代码合集.]]></content>
      <categories>
        <category>JDBC</category>
      </categories>
      <tags>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDBC-day01]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F05%2F05%2FJDBC-day01%2F</url>
    <content type="text"><![CDATA[JDBC-day01JDBC基本概念 概念: Java DataBase Connectivity 即Java数据库连接, 用java语言操作数据库. JDBC本质: 我们期望使用统一的一套java代码可以操作所有的数据库,为此,sun公司就定义了医药操作所有关系型数据库的规则(也就是接口),而其每个数据库对这个接口的实现类由该数据库公司自己实现.所以, 我们可以说JDBC的本质就是:官方(sun公司)定义的一套操作所有关系型数据库的规则,即接口.同时各个数据库厂商自己去实现这个接口,提供数据库驱动的jar包.从而我们可以使用这套接口(JDBC)编程,真正执行的代码是驱动jar包中的实现类 JDBC快速入门 步骤: 导入对应数据库的驱动jar包,要用mysql就导入mysql的. 复制jar包,到项目下(可以新建一个目录libs,jar包都放在该目录下). 将libs目录–&gt;右键–&gt;添加为库. 注册驱动,让程序知道是用哪个数据库. Class.forName(&quot;com.mysql.jdbc.Driver&quot;);. 获取数据库连接对象Connection. Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/cart&quot;, &quot;root&quot;, &quot;root&quot;);. 定义sql语句. String sql = &quot;update product set name = &#39;话说&#39; where id = 1&quot;;. 获取执行sql语句的对象 Statement. Statement state = conn.createStatement();. 执行sql语句,接收返回的结果. int count = state.executeUpdate(sql);. 处理结果. 释放资源. 对JDBC中各个接口和类详解 详解各个对象 DriverManager(类): 驱动管理对象. 功能 注册驱动,告诉我们的程序该使用哪个数据库的jar包. 使用的方法: public static void registerDriver​(Driver driver) throws SQLException. 写代码使用该方法:Class.forName(&quot;com.mysql.jdbc.Driver&quot;),通过查看Driver的源码,我们发现,在Driver类中存在静态代码块 static { try { DriverManager.registerDriver(new Driver()); } catch (SQLException var1) { throw new RuntimeException(&quot;Can&apos;t register driver!&quot;); } } * 注意:在导入mysql5的jar包以后,我们注册驱动的语句可以不用写,因为在jar包下的`META-INF`文件夹中的`services`中帮我们写了,不过我们还是建议写上,我们不知道驱动咋写的时候也可以去`META-INF`文件夹中的`services`中复制. 2. 获取数据库连接. * 使用的方法: `public static Connection getConnection​(String url, String user, String password)`. * 参数: * url:指定连接的路径 * 语法: jdbc:mysql://ip地址(或者域名,用于找到计算机):端口号(用于找到mysql软件)/数据库名称 * 例子:jdbc:mysql://localhost:3306/cart * 细节:如果连接的是本机的mysql服务器,并且mysql的默认端口是3306,则url中的`ip和端口`可以省略,所以url可以简写为:***jdbc:mysql:///数据库名称*** * user:用户名 * password:密码 * Connection(接口): 数据库连接对象 * 功能: 1. 获取执行sql语句的对象 * 方法1: `Statement createStatement()`. * 方法2: `PreparedStatement prepareStatement​(String sql)`. 2. 管理事务: * 开启事务: `void setAutoCommit​(boolean autoCommit)`,调用该方法设置参数为`false`则开启事务. * 提交事务: `void commit()`. * 回滚事务: `void rollback()`. * Statement(接口,重要): 执行静态sql语句对象 * 方法1(了解): `boolean execute​(String sql)`,返回true表示执行的是DQL语句,返回false表示执行的是DML语句. * 方法2: `int executeUpdate​(String sql)`,执行`DML语句(数据操作语言,增删改,insert,update,delete)`,`DDL语句(数据定义语言,创建/删除表和库,create,alter,drop)`. * 返回值: 表示影响的行数(针对DML语句,而对DDL永远返回0,因为它不返回任何内容). * 返回值作用: 可以通过影响的行数来判断DML语句是否执行成功,返回值&gt;0则执行成功,反之则执行失败. * 方法3: `ResultSet executeQuery（String sql）`,执行DQL语句(数据查询语言查询语句,select). * 练习,针对product表: 1. 添加一条记录:`String sql = &quot;insert into product(id,name,price) value(null , &apos;平板2&apos; , 500)&quot;,其中`product(id,name,price)`中的括号里的参数表示增加哪一个字段内容,不写就表示增加所有字段`. * 注意:这里`value`可以写成`values`,在插入一条数据时,用`values`较快,插入多行数据时,用`value`较快. 2. 删除一条记录: `String sql = &quot;delete from product where id = 2&quot;;`. 3. 修改一条记录: `String sql = &quot;update product set name = &apos;平板&apos; where id = 1&quot;;`. 4. 创建一张表: `String sql = &quot;create table student (id int, name varchar(20))&quot;;`. 5. 删除一张表: `String sql = &quot;drop table student&quot;;`. * ResultSet(接口): 结果集对象,封装查询结果. * next(): 游标向下移动一行(默认光标指向位置是表头,此时是没有数据的,向下移动一行后就有数据了),同时可以通过该方法判断是否到达最后一行末尾(即是否有数据),如果有数据,则返回true,反之则返回false. * getXxx(参数): 获取数据. * Xxx代表`数据类型`,因为它是一次获取一行当中某一列的值,不是一次获取一整行的,例如: int getInt(). * 参数有两种情况: 1. int类型: 代表列的编号,从`1`开始,不是从0开始,如:getInt(1). 2. String类型: 代表列的名称,如:getString(&quot;id&quot;). * 注意: * ResultSet的使用步骤: 1. 游标向下移动一行. 2. 判断是否有数据. 3. 获取数据. 1234567while (rs.next()) &#123; int id = rs.getInt(1); String name = rs.getString("name"); double price = rs.getDouble("price"); String data = "id = " + id + "name = " + name + "price = " + price; System.out.println(data); &#125; * 练习: * 定义一个方法,查询`db_student`数据库中`studentinfo`中的数据,并将其封装为对象,然后打印. * 思路:表其实和类的定义很类似,定义字段名,字段类型等,而表中每一行数据和一个对象类似,有表中每个字段的内容,所以我们可以把表映射成一个类,把查询的每一行数据封装成该类对象,然后用集合将所有对象都装载在一起返回. 1. 定义一个`Studentinfo`类,封装数据库中表的各个字段. 2. 定义方法 public List&lt;Studentinfo&gt; finaAll(),实现对数据库中所有数据的查询并将数据添加到list集合中. 3. 调用方法. * PreparedStatement(statement的子接口): 执行动态sql语句 1. **SQL注入问题**: 在拼接sql语句时,有一些sql的特殊关键字参与字符串的拼接,会造成一些安全性问题 * 例如: `select * from usertable where username = &apos;abc&apos; and password = &apos;a&apos; or &apos;a&apos; = &apos;a&apos;`,前面的账号密码是错的,但是这个sql语句是恒成立的,因为后面有个`or &apos;a&apos; = &apos;a&apos;`,这就会把数据库中所有数据都查出来,同时导致程序出问题. 2. 解决sql注入问题: 使用PreparedStatement对象来解决. 3. 预编译sql语句:参数使用`?`作为占位符,在执行的时候,给`?`赋值就行了,这个虽然步骤麻烦一点,但是安全一些. 4. 使用步骤: 1. 导入对应数据库的驱动jar包,要用mysql就导入mysql的.即复制jar包,到项目下(可以新建一个目录libs,jar包都放在该目录下). 2. 将libs目录--&gt;右键--&gt;添加为库. 3. 注册驱动,让程序知道是用哪个数据库. * `Class.forName(&quot;com.mysql.jdbc.Driver&quot;);`. 4. 获取数据库连接对象Connection. * `Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/cart&quot;, &quot;root&quot;, &quot;root&quot;);`. 5. 定义sql语句. * **注意**: sql的参数使用`?`作为占位符.如`String sql = &quot;update product set name = ? where id = ?&quot;;`. 6. 获取执行sql语句的对象 PreparedStatement: 方法为`PreparedStatement prepareStatement​(String sql)`. * `PreparedStatement ps = conn.prepareStatement(sql);`. 7. 给`?`赋值 * 用到PreparedStatement中的setXxx(参数1, 参数2)方法. * 其中,**参数1**表示?的位置编号,从1开始,**参数2**表示?的值. 7. 执行sql语句,接收返回的结果,在这里就不需要传递sql语句了,因为在步骤6中已经传递过了. 8. 处理结果. 9. 释放资源. 5. 改造登录例子代码:***[PrepareStatement改进登录代码](https://github.com/fanfan999/WebCodes/blob/master/JdbcDemo/fan/LoginUser_PrepareStatement.java)*** 6. 注意:我们以后使用PrepareStatement来完成增删查改的所有操作 1. 可以防止SQL注入. 2. 效率比Statement高. 抽取JDBC工具类: JDBCUtils类 目的: 简化书写 分析: 抽取注册驱动. 抽取一个方法,获取连接对象. 需求: 不想传递参数(url,user,password等),因为太麻烦,但是 又想保证工具类的通用性,即不同url,user等也可以运行. 解决办法: 使用配置文件: jdbc.properties url = user = password = 抽取释放资源. 代码:JDBC工具类及测试代码 练习: 需求: 通过键盘录入用户名和密码判断用户是否登录成功,给出提示. 步骤 创建数据库表,包括用户名和密码两个字段. 创建一个类LoginUser.java测试. 代码:用户登录测试类 需要注意的点: JAVA中两个基1的点: 在查询语句ResultSet中,参数是从1开始的. 在预编译接口PreparedStatement对象中,参数也是从1开始的. 当然,id这些基1的就不用说了,那是肯定的 上面提到的对象中,只有DriverManager是类,其它的都是接口.]]></content>
      <categories>
        <category>JDBC</category>
      </categories>
      <tags>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL学习笔记_day01]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F05%2F05%2FMySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-day01%2F</url>
    <content type="text"><![CDATA[MySQL笔记_day01数据库的基本概念 数据库的全称: DataBase 简称 : DB 什么是数据库？ 用于存储和管理数据的仓库. 数据库的特点,和存储在文件中有什么不一样呢? 持久化存储数据的,从这点来说,说白了数据库就是一个文件系统. 方便存储和管理数据. 使用统一的方式操作数据库 — SQL.MySQL数据库软件(Oracle公司的) 安装 反正我选择的是默认安装哈哈. 安装成功后,右键我的电脑,然后点击管理,点击服务和应用程序,点击服务,当看到mysql字样的时候说明安装成功了(也可以在dos窗口下输入services.nsc就可以直接跳转到服务界面了). 卸载 找到安装目录,找到my.ini文件,复制出来里面的datadir后面的路径 卸载mysql后,我们就要去通过刚才复制的路径去卸载其数据文件,就可以了. 配置 MySQL服务(service) 停止MySQL服务,在在dos窗口下输入net stop mysql SQL]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[归并排序]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F05%2F03%2F%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[归并排序 写在前面的话: 归并排序的时间复杂度为O(N*logN),额外空间复杂度为O(N). 什么是归并排序呢? 一点点专业叫法: 迭代就理解为递归,分治就理解为一分为二的过程. 举例:以[2,5,7,1,6,4]为例 首先将其一分为二,划分成两个部分,分别为[2,5,7]和[1,6,4]. 然后分别对左右两部分进行排序,得到[2,5,7]和[1,4,6]. 申请一个辅助数组,长度和原来的数组相同. 左右两个部分分别从左到右进行比较,谁小就放到辅助数组中去,例如此例中,执行顺序是这样的 先2和1比较,2大,就把1放在辅助空间中,然后左边数组下标不动,右边下标＋1. 再2和4比较,4大,就把2放进辅助空间,然后左边数组下标＋1,右边数组下标不变. ……以此类推,当一个到了末尾之后,比较停止,剩下的直接全部放到辅助数组中. 最后得到有序数组[1,2,4,5,6,7],再将其复制回原数组即可.分析其时间复杂度 这是一个递归的过程,我们可以用master公式(): T(N) = a * T(N / b) + O(N^d)来套一下. 假设数组样本量为N,划分成了两部分,所以两边的样本量是(N/2),有因为有两部分,所以为2*T(N/2). 额外空间复杂度为O(N),因为要申请一个长度为N的辅助数组. 用master公式套,可得T(N) = 2 * T(N / 2) + O(N),即a=2,b=2,d=1. 由此可知,(log(b,a)) =&gt; 1,而d == 1,所以可得归并排序的时间复杂度为`O(N^d logN) == O(Nlog(N))`. 对于额外空间复杂度,就把它当作只生成了一个最大的数组(就是初始化数组的长度),不考虑中间的就好了,所以是O(N).代码: 行数有点多,我就直接放github上了,需要的话就自己看下: 归并排序 举例: 小和问题(以[1,3,4,2,5]为例) 什么是小和问题: 就是在一个数组中,每一个数左边比当前数小的数累加起来,叫做这个数组的小和,求一个数组的小和的和. 分析: 1左边比1小的数: 没得. 3左边比3小的数: 1. 4左边比4小的数: 1,3. 2左边比2小的数: 1. 5左边比5小的数: 1,3,4,2. 所以总的小和为:1+1+3+1+1+3+4+2 = 16. 解决办法 每个数都遍历一下左边,小的数就相加,其时间复杂度为O(N^2),我们对数器就可以这么写. 用归并思想,产生小和就在合并过程中产生,但是其中有一个要注意的点: 在合并的时候,假如左边为[1,3,4],右边为[2,5]. 先1和2进行比较,发现2 &gt; 1,而此时,2右边包含2本身一共有两个元素,所以此时需要将1×2,然后在将右边的1放到辅助数组中. 再将3和2比较,发现3 &gt; 2,此时不产生小和,直接将2放入辅助数组. ……以此类推. 其实就是,合并的时候左边比右边大,就产生小和,左边比右边小就不产生小和,同时要注意右边的数比左边大的时候,要看右边较大的这个数的右边还有几个数,此时左边较小的数就要乘以几. 时间复杂度和归并排序一致,为O(N*log(N)). 代码超链接: 小和问题代码. 逆序对问题(以[1,3,4,2,5]为例) 逆序对就是指在一个数组中,左边的数比右边的数大,则这两个数构成一个逆序对,请打印所有的逆序对. 思路与小和问题相同,我就不多赘述了哈,就是在归并重组的时候找出逆序对,放在一个list中返回就可以了. 直接来代码吧哈哈.逆序对问题代码. 偶然发现的一个牛客剑指offer上的题目,就是一个归并的题目. 题目地址: 逆序对问题, 我的代码上面也有哈哈哈,大家可以参考,就是一个归并,不过多了一个取模操作而已.]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>归并排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于递归和递归时间复杂度的估算]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F05%2F02%2F%E5%85%B3%E4%BA%8E%E9%80%92%E5%BD%92%E5%92%8C%E9%80%92%E5%BD%92%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E4%BC%B0%E7%AE%97%2F</url>
    <content type="text"><![CDATA[递归两个小例子: 举例1: 在一个数组中找到最大值 我先找左边最大值和右边最大值(以下标中间为界),两者相比较,较大的就是全局最大值 我直接贴代码了哈: 12345678910111213141516//结束条件 if (L &gt;= R) &#123; return array[L]; &#125; //找到中间位置,划分为左右两边 int mid = (L + R) / 2; //左边最大值 int maxLeft = getMax(array, 0, mid); //右边最大值 int maxRight = getMax(array, mid + 1, R); //返回左右两边最大值 return Math.max(maxLeft, maxRight); 怎么理解呢? 我画了个图: 举例2:冒泡排序的递归实现: 因为冒泡排序的原理就是每一圈都让数组中的前后两个元素比较,大的放后面,小的放前面,,所以我们这里采用递归就要分为两步: 说明,这里的start第一圈就是下标0,end在第一圈就是数组长度 每一圈递归,其实就是遍历数组,让其两两比较,代码如下: 12345678if (start &lt; end - 1) &#123; if (array[start] &gt; array[start + 1]) &#123; swap(start, start + 1, array); &#125; bubbleSort(array, start + 1, end); &#125; else &#123; return; &#125; 让数组不断变成一个更小的数组(因为每一圈结束最后一个都是最大的),可以理解为递归圈数,代码如下: 1bubbleSort(array, start, end - 1); 完整代码我放github了,要的话自己可以看看:冒泡排序的递归版 这个就拿来当作理解就可以了,正式用的时候还是循环,不要用递归!不要用递归!不要用递归! 注意: 任何递归行为都可以变成非递归. 递归实际上就是在不停的压栈弹栈,很浪费空间. 循环基本都可以变递归,不过不建议使用递归,递归容易出问题,还不好理解,占用空间还多,除了代码简练一点. 递归时间复杂度怎么分析: 看这样一个用于估计递归时间复杂度一个通式(叫做master公式): T(N) = a * T(N / b) + O(N^d). 这个式子是用做第一次划分的过程的时候的,后面的划分不用管. 其中,T(N)表示样本量为N的情况下的时间复杂度,你就理解为T就是Time的缩写;a表示子过程的次数;N / b表示子过程的样本量;O(N^d)(这是N的d次方哈)表示除了调用子过程以后所需要的时间复杂度,下面我们以求最大值为例进行分析. 由于我们把整个数组划分为了左右两个部分,两边的样本量都是(N/2),所以说左边的时间复杂度就是T(N/2),而又有左右两个部分,所以一共要两个T(N/2)的时间复杂度,即2*T(N/2). 除了调用子过程意外,我们只需要对数组中元素两两比较,这个是常数级别的操作,所以最后一项O(N^d)为O(1). 从这里我们可以看出,上述求最大值的时间复杂度为T(N) = 2T(N/2) + O(1),就相当于a=2,b=2,d=0**. master的公式是有适用范围的:那就是划分子过程的时候,划分的子过程的规模必须是一样(或者差不多,多一个两个有限个的都无所谓)的,才可以用master公式. 对满足这个公式的算法有几个快捷使用公式: log(b,a) &gt; d –&gt; 复杂度为O(N^log(b,a)). log(b,a) == d –&gt; 复杂度为O(N^d * logN),(logN表示以10为底). log(b,a) &lt; d –&gt; 复杂度为O(N^d). 注意: 这里的log(b,a)都是表示以b为底,a为指数,读作以b为底的a的对数. 以1为底的任何数的对数都是0. 1的对数永远是0. 以求最大值为例进行分析: 最大值的时间复杂度为T(N) = 2*T(N/2) + O(1),就相当于a=2,b=2,d=0,所以log(b,a) == log(2,2),其值为1,是大于d=0的,所以其具体复杂度为O(N^log(b,a)) =&gt; O(N^1) == O(N).]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法中很好用的工具-对数器]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F05%2F02%2F%E5%AF%B9%E6%95%B0%E5%99%A8%2F</url>
    <content type="text"><![CDATA[对数器 当你碰到一个题,写好代码以后,你想验证是否正确,那么我们应该怎么办呢? 可以自己多举几个例子,但是自己举例子考虑得可能不够周全. 去找OJ(Online Judge在线评测),但是可能我们不知道这个题在哪个平台上有. 自己写一个对数器进行验证,说白了对数器的作用就是给定一组样本,在你的算法和对数器上跑,跑出来结果永远一样的话,那就说明算法是正确的. 对数器是什么: 说到底,对数器就是一个对应于你的算法所写的绝对正确的(或者直接调用的绝对正确的方法)方法,这个方法和你写的算法可以达到相同效果的方法,例如,你自己写的冒泡排序和java中系统给的Arrays.sort()方法.这个Arrays.sort()方法就可以作为对数器标准使用,而且,这个绝对正确的方法不需要在乎复杂度,只需要保证绝对正确就行. 对数器的使用步骤: 有一个你想要测的方法a; 实现一个绝对正确但是复杂度不好的方法b; 实现一个随机样本产生器; 实现比对的方法; 把方法a和方法b比对很对此来验证方法a是否正确; 如果有一个样本使得比对出错,打印样本,分析是哪个方法出错; 当样本数量很多时比对测试依旧正确,我们就可以确定方法a是正确的. 例子: 以冒泡排序为例 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134//自己写的冒泡排序算法 private static void bubbleSort(int[] array) &#123; //首先判断array对象是否为空 //然后判断array是否是单个元素数组 if (array == null || array.length &lt; 2) &#123; //是就直接退出 return; &#125; //控制次数(第一个~最后一个--第一个~倒数第二个--以此类推) //array.length - 1才是最后一个元素的下标,因为下标是从0开始的 for (int end = array.length - 1; end &gt; 0; end--) &#123; //j只能指向倒数第二个元素,防止越界 for (int j = 0; j &lt; end; j++) &#123; //前一个比后一个元素值大,交换位置 if (array[j] &gt; array[j + 1]) &#123; swap(j, j + 1, array); &#125; &#125; &#125; &#125; //交换位置 private static void swap(int i, int j, int[] array) &#123; int temp = array[i]; array[i] = array[j]; array[j] = temp; &#125; //for test //一个绝对正确的排序算法 public static void rightMethod(int[] array) &#123; //调用Arrays的sort()方法进行排序,这是绝对正确的 Arrays.sort(array); &#125; //for test /** * @param length 表示数组的长度 * @param maxValue 表示数组中元素的最大值 * @return 返回一个长度随机, 元素随机的数组 */ public static int[] createRandomArray(int length, int maxValue) &#123; //生成[0,length]范围的随机数使得randomArray的长度随机,因为Math.random()是不能到达右边界的,所以需要加1使它取到length这个数 int[] randomArray = new int[(int) (Math.random() * (length + 1))]; // 给随机数组赋值 for (int i = 0; i &lt; randomArray.length; i++) &#123; //因为Math.random()方法是不会产生负数的,为了更好的模拟真实情况,我们采用两个随机数相减,就有可能产生负数了 randomArray[i] = (int) ((Math.random() * (maxValue + 1)) - (Math.random() * (maxValue + 1))); &#125; return randomArray; &#125; //for test /** * 用于对比两个算法跑出来结果是否相同 * * @param array1 表示自己写的算法跑出来的结果 * @param array2 表示对数器中的算法跑出来的结果 * @return 返回true表示两者完全相同, false就打印错误样本 */ public static boolean comparator(int[] array1, int[] array2) &#123; int len = array1.length; //如果两个数组长度不相同一定不相同 if (array1.length != array2.length) &#123; return false; &#125; //一个为空一个不为空,一定不相同 if ((array1 == null &amp;&amp; array2 != null) || (array2 == null &amp;&amp; array1 != null)) &#123; return false; &#125; //遍历数组,进行比较 for (int i = 0; i &lt; len; i++) &#123; if (array1[i] != array2[i]) &#123; System.out.println(&quot;出错了!,此时自定义算法的数据为 : &quot; + Arrays.toString(array1) + &quot;, 对数器样本数据为 : &quot; + Arrays.toString(array2)); System.out.println(array1[i]); System.out.println(array2[i]); return false; &#125; &#125; return true; &#125; // for test /** * * @param array 表示要复制的样本 */ private static int[] copyArray(int[] array) &#123; int[] copyArray = new int[array.length]; for (int i = 0; i &lt; array.length; i++) &#123; copyArray[i] = array[i]; &#125; return copyArray; &#125; // for test public static void main(String[] args) &#123; int[] a = new int[0]; int[] b = null; System.out.println(a.length); System.out.println(b.length); boolean flag = true; //产生样本 for (int i = 0; i &lt; 10000; i++) &#123; int[] array = createRandomArray(10, 1000); //复制样本 int[] array2 = copyArray(array); //通过两种算法排序 bubbleSort(array); rightMethod(array2); //判断两个数组此时是否相同 flag = comparator(array,array2); //一旦有不相同,就退出循环 if (flag != true) &#123; break; &#125; &#125; System.out.println(flag == true ? &quot;恭喜你,你的算法是正确的!&quot; : &quot;继续努力!&quot;); &#125; 注意事项: 对于Math.random()和Random类不懂的话,我在网上找了一篇很详细的文章,大家可以看看,我就不自己写了,超链接 : 关于生成随机数的两个方法. 区别一下int[] a = new int[0];和int[] b = null;这两条语句,后者不是长度为0,它不赋值去调用任何东西都是报错. 代码我放我github仓库了,有需自取 : BubbleSort.java]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>对数器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[冒泡排序,选择排序,插入排序]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F04%2F29%2F%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%2C%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[冒泡排序 理解:在水里小泡泡往上面浮,大泡泡往水下沉,所以冒泡排序其实就是前一个和后一个比较,小的放前面,大的放后面. 原理:以int[] arr = {2,3,4,1,9,7,5}为例. 第一圈: 先数组中第一个元素(下标为0)和数组中第二个元素(下标为1)比较大小. arr[0] &gt; arr[1],两者交换. arr[0] &lt;= arr[1],两者不交换 然后比较数组第一个元素(下标为1)和数组第二个元素(下标为2)的大小. arr[1] &gt; arr[2],两者交换. arr[1] &lt;= arr[2],两者不交换 ……以此类推 第一圈结束后,数组中最后一个元素为当前数组最大值. 第二圈(不管第N-1个数): 先数组中第一个元素(下标为0)和数组中第二个元素(下标为1)比较大小. arr[0] &gt; arr[1],两者交换. arr[0] &lt;= arr[1],两者不交换 然后比较数组第一个元素(下标为1)和数组第二个元素(下标为2)的大小. arr[1] &gt; arr[2],两者交换. arr[1] &lt;= arr[2],两者不交换 ……以此类推 第二圈结束后,数组中倒数第二个为当前数组第二个最大值. ……以此类推,共执行N次 代码1234567891011121314151617181920212223242526272829303132333435363738394041public class BubbleSort &#123; public static void main(String[] args) &#123; int[] array = new int[]&#123;2,1,6,9,13,3,4,2&#125;; System.out.println(array.length); //排序前 System.out.println(Arrays.toString(array)); bubbleSort(array); //排序后 System.out.println(Arrays.toString(array)); &#125; private static void bubbleSort(int[] array) &#123; //首先判断array对象是否为空 //然后判断array是否是单个元素数组 if (array == null || array.length &lt; 2) &#123; //是就直接退出 return; &#125; //控制次数(第一个~最后一个--第一个~倒数第二个--以此类推) //array.length - 1才是最后一个元素的下标,因为下标是从0开始的 for (int end = array.length - 1; end &gt; 0; end--) &#123; //j只能指向倒数第二个元素,防止越界 for (int j = 0; j &lt; end; j++) &#123; //前一个比后一个元素值大,交换位置 if (array[j] &gt; array[j + 1]) &#123; swap(j, j + 1, array); &#125; &#125; &#125; &#125; //交换位置 private static void swap(int i, int j, int[] array) &#123; int temp = array[i]; array[i] = array[j]; array[j] = temp; &#125;&#125; 分析: 数组中两两交换和数组寻址都是常数时间O(1)的. 第一个for一共执行N次,第二个for一共执行N-1次,所以一共要执行N^2 + N次. 不要高阶项系数,不要低阶项,所以我们就可以评估冒泡排序的时间复杂度为O(N^2). 其空间复杂度为O(1),因为只用了一个变量没有开辟多余空间. 选择排序 理解:和冒泡排序相反,选择排序是第一个元素依次和后面的每一个元素相比,比后面的小就交换,所以结束第一圈后最小的数就放在了最前面…以此类推,就可以将数组从小到大排序好. 代码1234567891011121314151617181920212223242526272829303132333435363738public class SelectionSort &#123; public static void main(String[] args) &#123; int[] array = new int[]&#123;7, 6, 8, 9, 1, 2, 7, 6, 4&#125;; //排序前 System.out.println(Arrays.toString(array)); selectionSort(array); //排序后 System.out.println(Arrays.toString(array)); &#125; //选择排序代码 private static void selectionSort(int[] array) &#123; //首先判断数组对象是否为空以及是否为单个元素数组 if (array == null || array.length &lt; 2)&#123; return; &#125; //控制循环次数 for (int start = 0; start &lt; array.length; start++) &#123; //注意这里的i只能取到倒数第二个数,防止i+1越界 for (int i = star t; i &lt; array.length - 1; i++) &#123; //如果前一个比后面的大,就交换 if (array[start] &gt; array[i + 1]) &#123; swap(start,i + 1, array); &#125; &#125; &#125; &#125; private static void swap(int start, int i, int[] array) &#123; int temp = array[i]; array[i] = array[start]; array[start] = temp; &#125;&#125; 分析: 数组中两两交换和数组寻址都是常数时间O(1)的. 第一个for一共执行N次,第二个for一共执行N-1次,所以一共要执行N^2 + N次. 不要高阶项系数,不要低阶项,所以我们就可以评估选择排序的时间复杂度为O(N^2). 其空间复杂度为O(1),因为只用了一个变量没有开辟多余空间. 插入排序(重点) 理解:以int[] arr = {3,1,4,1,6}为例,可以理解为斗地主嘛,你手上的牌都从小到大排好序了,拿到一张新的牌可不就得和前面已经拿了的牌一个一个对比嘛,小的放前面,大的放后面,对吧? 首先,第一个位置的数(下标为0)不动,去和第二个位置的数(下标为1)比较(即拿3和1比较). 此时发现3&gt;1,所以arr[0]和arr[1]的值交换. 此时数组为[1,3,4,1,6]. 然后用第二个位置的数(下标为1)去和第三个位置的数(下标为2)比较,(即拿3和4比较) 此时发现3 &lt; 4,所以不交换. 此时数组为[1,3,4,1,6]. 然后用第三个位置的数(下标为2)去和第四个位置的数(下标为3)比较,(即拿4和1比较) 此时发现4 &gt; 1,所以4和1交换位置,得到[1,3,1,4,6]. 再将3和1比较,发现3 &gt; 1,两者交换,得到[1,1,3,4,6]. 再将1和1比较,发现1 == 1,所以不交换. …以此类推 当到数组末尾时结束,得到排序好的数组[1,1,3,4,6]. 代码12345678910111213141516171819202122232425262728293031323334353637383940public static void main(String[] args) &#123; int[] array = new int[]&#123;3, 1, 5, 2, 7, 6, 1&#125;; // 排序前 System.out.println(Arrays.toString(array)); insertionSort(array); // 排序后 System.out.println(Arrays.toString(array)); &#125; //插入排序 private static void insertionSort(int[] array) &#123; //判断数组对象是否为空和是否为单个元素数组 if (array == null || array.length &lt; 2) &#123; return; &#125; //控制开始和结束,到数组末尾就停,i表示右边第一个未排序的元素下标 for (int i = 1; i &lt; array.length; i++) &#123; // 让左边已经排好序的和右边未排序的依次比较,同时和已排序的进行比较,j表示左边已排序的最后一个元素下标 for (int j = i - 1; j &gt;= 0; j--) &#123; //大就交换 if (array[j] &gt; array[j + 1]) &#123; swap(array, j); &#125; &#125; &#125; &#125; //交换 private static void swap(int[] array, int j) &#123; int temp = array[j]; array[j] = array[j + 1]; array[j + 1] = temp; &#125;&#125; 分析: 首先数组寻址,交换位置这些时间复杂度都是O(1)这是没有问题的. 和选择排序和冒泡排序不同的点是:前两个时间复杂度一定是O(N^2),因为不管你数组有序或者无序,你都是要按照流程一个一个比较的,跟数据状况没关系的,但是插入排序不一样,插入排序和数据状况有关系,要分情况. 最好情况下的时间复杂度: 当数组本来就有序时,时间复杂度为O(N),因为没有交换,就和遍历一次数组一样. 最差情况下的时间复杂度 当数组是逆序,而我要的是正序时(比如我要的是[1,2,3,4,5],但是你给的是[5,4,3,2,1]),时间复杂度为O(N^2),每一次都要和前面所有的交换,(例如5要交换4次,4要交换3次这样子),这就形成了一个等差数列(联想到冒泡排序怎么形成等差数列的),所以评估其时间复杂度为O(N^2). 一般情况下的时间复杂度: 一般情况我们一律按照最差情况估计,所以我们一般说插入排序的时间复杂度为O(N^2).]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>冒泡排序,选择排序,插入排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于时间复杂度和额外空间复杂度]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F04%2F29%2F%E5%85%B3%E4%BA%8E%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[写在前面的话: 这里写logN就表示以2为底数,因为2为底数打不出来哈哈哈 时间复杂度 用于评价一个算法流程的好坏. 先看时间复杂度的指标(再看常数项),即(N^2)/100 + 10N + 1我们也看成时间复杂度是O(N^2),其中N就是样本量 . 然后再分析不同数据样本下的实际运行时间. 常数时间的操作: 概念:一个操作如果和数据量没有关系,每次都是固定时间内完成的操作,就叫做常数操作,例如加减乘除,位运算操作,数组寻址(就是根据下标获取数组中的元素,比如a[1])等. 时间复杂度为一个算法流程中,最差情况下常数操作数量的指标.常用O表示(读作big O),具体来说,在常数操作数量的表达式中,不要低阶项,只要高阶项,并且忽略掉高阶项的系数,剩下的部分如果记作f(N),那么时间复杂度为O(f(N)). 几个简单的理解时间复杂度的例子: 一个有序数组A,另一个无序数组B,请打印B中的所有不在A中的数,A数组长度为N,B数组长度为M. 算法流程1: 对于数组B中的每一个数,都在A中通过遍历的方式找一下. 很明显该算法的时间复杂度特别大,遍历一次代价为O(N),一共M个数,所以总的代价为O(M*N). 算法流程2: 对于数组B中的每一个数,都在A中通过二分的方式找一下. 二分搜索,比如针对一个有序(假定是从小到大)的数组,假设我要找2有没有在这个数组里. 我先找到中间位置的数,看比2大还是小. 比2大,因为是从小到大排序的,所以中间右边的数字一定比2大,我们就在左边继续划分一半一半地找,直到没有了或者找到了为止. 比2小,说明中间左边的数字一定比2小,我们就在右边继续划分一半一半地找,直到没有了或者找到了为止. 等于2,就直接返回 在这个过程中,我们数组寻址和两个数比较的过程都是常数操作时间的O(1),每次砍一半,这样下来,常数操作次数为logN(以2为底),即一个数组长度为8,最多砍3次. 由此可见,二分查找的时间复杂度为O(logN),以2为底 因此我们也可以推出,查找一次的时间复杂度为O(logN),一共有M个数,时间复杂度则为(MlogN). 算法流程3: 先把B数组排序,然后用类似外排的方式打印所有在A中出现的数. 思路就是,B排序后,两个数组同时从0位置开始,即A[i]和B[i]互相比较. 若A[i] &gt; B[i],则B[i]肯定不在A数组中,打印B[i],然后B数组下标++. 若A[i] &lt; B[i],B数组下标不动,A数组下标++. 若A[i] == B[i],A数组下标不动,B数组下标++. 针对这个流程 第1步:排序的时间复杂度,可以达到NlogN. 第2步:快排,时间复杂度为O(N + M)(N,M为A和B数组长度). 由此可见,该流程的时间复杂度为NlogN + O(N + M). 三个流程,三种时间复杂的表达…我们应该如何分析其好坏? 给长度为N的数组排序(其中寻址,比较操作都是常数级别的). 第一次从0-(N-1)中找出最小值min放在第0个位置,过N个数. 第二次从1-(N-1)中找出最小值min放在第1个位置,过N-1个数. ……以此类推. 一共需要找的次数为(N + (N-1) + ... + 2 + 1),这是一个等差数列,其和为n(n + 1) / 2(这个就可以理解为常数操作数量的表达式),再乘以一个O(1)(它是单次操作所需要的时间),即(n(n + 1) / 2) O(1). 估算其时间复杂度是这样子的: 不要低阶项,只要高阶项,并且忽略掉高阶项的系数. 由此推出上述排序算法时间复杂度为O(n^2). 额外空间复杂度 额外空间复杂度其实很好想,完成这个功能,我们额外开辟了几个新的空间,那就是几. 比如我一个循环,循环过程中我新开辟了一个长度为10的数组来存储数据,那么额外空间复杂度就是O(10) 再以冒泡排序为例,当两个数需要交换时,我们就会定义一个中间变量temp,这就是我们唯一新开辟空间的地方,这时我们就说冒泡排序的额外空间复杂度为O(1),其实,有限的几个变量(单个变量,不是数组这样子的哈)能跑完流程的话,额外空间复杂度都是O(1),不一定是一个.]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>时间复杂度,额外空间复杂度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基础加强_注解]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F04%2F29%2F%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%BC%BA-%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[本篇文章主要讲注解(Annotation)注解的基本知识 概念:和注释一样,是来说明程序的,但是这个是给计算机看的; 注释: 用文字描述程序的一段话,比如//这是一个方法,这个就是给我们程序猿看的; 关于注解的几个注意的点: JDK1.5之后的新特性 用来说明程序的 注解的格式:@注解名称 注解的作用分类: 编写文档(生成doc文档) 生成api帮助文档,也就是(doc文档),只需要文件夹中用cmd打开dos窗口,输入javadoc 类名.java就可以生成了,然后再打开index.html就可以看到我们写的注解了 直接用dos命令可能会报错或者API有乱码,因为我用的是utf-8但是系统不认识的,所以你这时候只需要用notepad++将该类的编码改成ANSI(即本地默认编码)就可以了(先复制,再粘贴,再保存后就是ANSI编码的了) 代码分析(使用反射) 编译检查(如果你重写方法改名了就会报错) JDK中预定义的一些注解: @Override : 用于检测被该注解标注的方法是否是继承自父类(接口)的,不是会报错; 例子: 1234@Overridepublic String toString()&#123; return super.toString(); &#125; @Deprecated[ˈdeprəkeɪtɪd] : 说明被该注解标注的内容已过时 @SupperessWarnings : 压制警告(黄色警告线) 一般情况下我们会写在类上,使得类中的左右黄色警告线都会没有而且参数一般传递的参数都是&quot;all&quot;; 例子: 1234@SupperessWarnings("all")public void show()&#123; System.out.println("abc");&#125; 此时比如show方法未使用这些黄色警告线都没有了 自定义注解: 格式(包括两部分): 元注解 : 用于描述注解的注解(放在注解类上面) @target : 描述注解能够作用的位置 例子 : @Target(value = {ElementType.TYPE, ElementType.METHOD, ElementType.FIELD}), 其中value还可以省略,因为只有他一个属性 ElementType(这是target的属性)取值 : TYPE : 表示只能作用在类上 METHOD : 表示只能作用于方法上 FIELD : 表示只能作用于成员变量上 @Retention : 描述注解被保留的阶段 @Retention(RetentionPolicy.RUNTIME) : 表示当前被描述的注解,会保留到class字节码文件中,并被jvm读取到(可以直接RetentionPolicy.RUNTIME这样子使用是因为RetentionPolicy是一个枚举类) @Documented : 描述注解是否被抽取到api文档中(生成api文档可以在dos窗口下使用如下命令 : javadoc Hello.java) @inherited : 描述注解是否被子类继承,使用后子类会自动继承这个注解 public @interface 注解名称(){} 例如这样子 : public @interface MyAnno{} 本质 : 注解本质就是一个接口,该接口默认继承Annotation接口(自己写一个接口MyAnno,再反编译一下就知道了) 反编译后就像这样子 : public interface MyAnnotation.MyAnno extends java.lang.annotation.Annotation { } 反编译有一个小技巧,你可以通过软件反编译,也可以通过javap HelloWorld.class这样的命令在dos窗口下反编译 注解的属性 : 即接口中定义的抽象成员方法,常量没啥用不用管 要求 属性的返回值类型(只有下列取值) : 基本数据类型 String(注意只有String,没有其它引用类型) 枚举 注解 以上类型的数组类型 例子如下 : 1234567891011121314public @interface MyAnno&#123; public abstract int show1(); public abstract String show2(); //Student为枚举类 public abstract Student show3(); //MyAnno2为注解类 public abstract MyAnno2 show4(); String[] strs();&#125; 定义了属性,在使用时需要给属性赋值,格式为 : @注解名(方法名 = 返回值类型的值)(其中返回值类型为int就是int类型,String就是String类型,当有多个值时,中间用,隔开就可以了) 例如这样 : @MyAnno(show1 = 10, show2 = &quot;fan&quot;) 但是有一个技巧,就是我们在定义属性的时候就可以给一个默认值(在属性名后面＋default＋默认初始化值),这样在使用时候就可以不给值了 例如 : String name() default &quot;fan&quot; 如果只有一个属性需要赋值,并且属性的名称为value,则value可以省略，多个参数时就必须写上属性 就像这样 : @MyAnno(10) 注意数组赋值时候,用{}包裹,如果只有一个元素的话{}可以不写 注解赋值的例子: @MyAnno(show1 = 10, show2 = &quot;fan&quot;, strs = {&quot;fan1&quot;, &quot;fan2&quot;, show3 = Student.P1}) 在程序中使用(解析)注解 即获取注解中定义的属性值,可以替代配置文件,这里用到了反射 获取注解定义的位置的对象(Class, Method, Field对象) 获取指定的注解 getAnnotation(类类型) 调用注解中的抽象方法来获取配置的属性值其实我觉得这个暂时意义不大,就懒得写了哈哈 小结 以后大多数时候,我们会使用注解,而不会自定义注解 注解给谁用? 编译器 解析程序 注解不是程序的一部分,可有可无,也可以理解为注解就是一个标签]]></content>
      <categories>
        <category>javaee</category>
      </categories>
      <tags>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Markdown图片无法显示的问题解决方法]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F04%2F28%2F%E5%85%B3%E4%BA%8EMarkdown%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E7%9A%84%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[备注: 在网上找了半天,一堆不靠谱的试了以后,终于被我试出来了哈哈哈,我可真是个小天才 步骤是这样子的 在自己的github上新建一个仓库, 怎么新建仓库大家应该都会吧,我这里就不赘述了,就像下面这样: 点开自己新建的仓库,在右边有个clone or download,复制下来地址,如图所示: 打开hexo所在文件夹,右键鼠标然后点击 Git Bash Here,然后在本机将github中的仓库克隆下来,命令是: git clone 仓库地址(地址就是你复制下来的地址),不懂就看图吧: 克隆成功后在hexo文件夹中会有一个以你的仓库名命名的文件夹,例如我的是MyPostImage,然后将图片放在该文件夹下就行; 注意: 这里有个小技巧:你可以每次要在一篇博客中添加图片时候,新建一个和本篇博客名字相同的文件夹放在MyPostImage下面,这样就比较容易整理; 你要是怕自己新建的文件夹和博客名字不一致,你可以这样子新建一篇博客文章:在bash窗口下输入命令hexo n &quot;博客名字&quot;,这样子系统就会自动在hexo &gt; source &gt; _posts路径下生成一个和本篇博客名相同的文件夹,然后将文件夹复制到MyPostImage下面就可以了. 进入MyPostImage文件夹(注意不是和博客名字相同的那个文件夹,是名字和仓库名相同的的文件夹),右键鼠标然后点击 Git Bash Here,打开Bash窗口然后输入git add .,(注意这里有一个点),然后输入命令git commit -m &quot;文件名&quot;,最后将内容推送上仓库就可以了,命令是:git push origin master; 上传成功后去自己的github仓库看看,你就会发现,产生了一个git commit -m &quot;文件名&quot;中以文件名为名字的文件夹,图片就在该文件夹中,就像这样子: 点击图片,当你看到图片以后,复制该图片的路径.就像这样: 然后打开我的新建的md文件,并且插入图片,代码是:![图片名](图片路径 &quot;图片无法显示或鼠标移上去的时候显示的文字&quot;),例子如下(这个图片是我在网上偷的啊哈哈): 但是我们预览的时候会出现一个问题,就是预览的时候图片还是显示不出来,这个时候我们改路径的一个文件名就可以了,因为github和md文件关联的图片地址是有一定格式的,格式如下: https://github.com/用户名/repository仓库名/raw/分支名master/图片文件夹名称/***.png or***.jpg 看不懂吧,其实就是将blob改成raw就行,万一还看不懂就看图: 在bash下运行博客,你会发现图片这时候就可以看到了,大功告成哈哈! 其实这里面可能还有很多技巧啥的,我暂时还不会,暂时会这个就可以了吧哈哈哈,因为反正图片不是太多,要是有啥不清楚的,随时可以通过博客联系我,在about里面可以找到我哈哈哈,最后附上一张我很喜欢的图片吧,希望各位和它一样每天都开心!]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown的基本语法]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F04%2F28%2FMarkdown%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[写在前面的话: 之前一直手抄做笔记复习,没有想着用博客,后来觉得手写太慢了,所以准备好好利用一下我的博客作为复习仓库,在这里先熟悉下Markdown语法 Markdown标题 使用#表示1-6级标题,一级对应一个#号,二级标题对应两个#号,以此类推; 其中一级标题还可以在文字下方加一行=====,这个等号几个无所谓;二级标题可以在下面加----,几个符号也是无所谓的; 注意事项: Markdown写文章时,一定要在符号后面空格一下再写文章,比如* a这样子,不然符号不会起到作用的; Markdown中可以行与行之间通过空一行来实现换行,也可以通过&lt;br&gt;来实现换行; 将文字放在可以实现高亮(不过这个不是分号,是esc键下面,tab键上面的那个按键)中间来实现高亮强调的效果; Markdown段落格式 字体 *斜体文本*和_斜体文本_都表示斜体; **粗体文本**和__粗体文本__都表示粗体;***粗斜体文本***和____粗斜体文本___都表示粗斜体文本; 分隔线 可以在一行下面用 *** 或者 --- 或者 ___ 来建立一个分隔线; 通过在文本前面添加&lt;u&gt;实现带下划线文本; 脚注 脚注是用来对文本进行补充说明的,你把鼠标移上去会有提示,格式是这样子的[^要注明的文本]; Markdown列表 无序列表 使用星号(),加号(+)或者减号(-)作为列表标记,我这里用的就是无序列表呀哈哈哈,如果要有层次感的话,就敲一个tab键再敲`,+,-`就好了,不过都要记得敲完符号了记得敲个空格哈; 例如这样子: 第1项 第1.1项 *第1.2项 第2项 第2.1项 第2.2项 第3项 第3.1项 第3.2项 有序列表 使用数字并加上.来表示; 就像这样子: 第1项 第1.1项 第2项 第2.1项 列表嵌套 列表嵌套很简单,下一行时,在前面添加四个空格就可以了; 就是这样子的: 第1项: 第1.1项 第2项 第2.2项 Markdown区块 这也是为了分层好看用的,其实和缩进也差不多了,就是用&gt;表示最外层,&gt;&gt;表示第二层,依次类推; 例子是这样的: 第1块 第1.1块 第2块 第2.2块 这个也是可以嵌套列表使用的; 例子如下: 区块中的列表 第1项 第2项 第1项 第2项 但是这里有两个要注意的地方: 就是如果要在列表中放区块,就需要在&gt;前面添加四个空格的缩进; 就像这个样子: 第一项 &gt; 我是fanfan999, 最爱lcl 使用&gt;缩进后,行与行之间必须空行,不然效果不出来; Markdown代码 这才是最重要的部分哈哈哈,不过前面都差不多提到了,那就再回顾一遍吧; 一点点代码可以用给包起来就行,例如System.out.println(&quot;fanfan999&quot;); 想要多行代码成为一块很显眼的地方,也就是高亮啦,我们可以使用在代码前一行和后一行添加三个这个`符号,在符号后面还可以备注什么语言,当然不备注也是可以的; 例子如下:123public static void main(String[] args)&#123; System.out.println("fanfan999");&#125; Markdown超链接 格式是这样子的:[要显示的文字](链接的地址); 例如我的: 我的博客; 当然也可以直接使用地址哈哈哈!不过要把网址用&lt;&gt;包起来 像这样:https://fanfan999.github.io/fanfan999.github.io/; Markdown插入图片 图片格式如下: ! [alt 图片的替代文字] (图片地址 “可选标题”),也就是一个感叹号!+一个方括号[]+一个普通括号(),其中的最后一个”可选标题”效果就是你鼠标放上去会显示的文字,可写可不写, 也可以放本地图片,语法一样的,只是地址改为本地地址就好了 这个图片嘛…emmm,我自己试了显示不出来哈哈哈哈,对不起,是我太菜了,我搞出来了再补充.]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Markdown&lt;br&gt;</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[这是我的第一篇博客了]]></title>
    <url>%2Ffanfan999.github.io%2F2019%2F04%2F12%2F%E4%BB%8E%E4%BB%8A%E5%A4%A9%E8%B5%B7%2C%2F</url>
    <content type="text"><![CDATA[从今天起, 我也是一个有博客的菜鸟了哈哈哈!用博客来记录我的复习,希望秋招能找到一个好工作吧!]]></content>
  </entry>
</search>
